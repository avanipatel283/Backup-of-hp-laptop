DSCRM.Core.registerModule("createNewTask", ["ajax","cache","util","alert","url"],function(sandbox) {
	
	var _taskCreationData, _entityID, _entityType, _oldTask, _isOperationOngoing = false;

	var constructTaskMap = function(map){

		var data = {}, field, formData = map.formData, areaCode="206",
			value, arr, name, str, user, taskTypeName, cmMapIndex,
			userID = sandbox.cache.get("loggedInUserID"), phoneNo,
			userName = sandbox.cache.get("loggedInUserName"),
			userEmail = sandbox.cache.get("loggedInUserEmail"),
			isTaskInfoNeeded = false, mapOfTaskData = {},
			isUpdateOperation = !!map.settings.taskID, taskObj = {},
			settingsData = map.settings;
		
		if(isUpdateOperation)
			_oldTask = taskObj = map.settings.task;

		data["ownerID"] = userID;
		
		if(!!map['notes']){
			data['notes'] = map['notes'];
			data['history'] = [{ type : "note", departmentID : data["deparmentID"], ownerID : userID, ownerName : userName, historyComments : map['notes']}];
		}
		
		for(var i=0,l=formData.length; i<l;i++){
			
			field = formData[i];
			value = field.value;
			name = field.name;
			
			if(name == "tags"){
				
				value = [];
				
				arr = field.value.split(", ");
				arr.map(function(tag){
					if(!!tag && value.indexOf(tag) == -1)
						value.push(tag);
				});
			}
			else if(name == "notes" && !!value){
				
				data[name] = value;
				name = "history";
				str = value;
				value = [{ type : "note", departmentID : data["deparmentID"], ownerID : userID, ownerName : userName, historyComments : str}];
				
			}
			/*else if(name == "linkedContact"){
				name = "linkedContacts";
				value = [value];
			}*/
			else
				value = ""+value;
			
			data[name] = value;
		}
		
		if(!!sandbox.url.entityID() && !isUpdateOperation){
			switch(sandbox.url.page()){
				case "deal": 
					var entityFromCache = sandbox.cache.get("deals")[sandbox.url.entityID()];
					if(!sandbox.util.isEmptyObject(entityFromCache)){
						data["brandID"] = entityFromCache["brandID"];
						data["rating"] = entityFromCache["rating"];
					}
					data["linkedDeal"] = sandbox.url.entityID();
					break;
				case "account": 
					var entityFromCache = sandbox.cache.get("accounts")[sandbox.url.entityID()];
					if(!sandbox.util.isEmptyObject(entityFromCache)){
						data["brandID"] = entityFromCache["brandID"];
						data["rating"] = entityFromCache["rating"];
					}
					data["linkedAccount"] = sandbox.url.entityID();
					break;
				case "task":
					
					if(!settingsData.hasOwnProperty("isCreateNewTicketFromDropdown"))
						break;
						
					var entityFromCache = sandbox.cache.get("tasks")[sandbox.url.entityID()];
					
					if(!sandbox.util.isEmptyObject(entityFromCache)) {
						data["productID"] = entityFromCache["productID"];
						
						if(entityFromCache.hasOwnProperty("linkedAccount"))
							data["linkedAccount"] = entityFromCache.linkedAccount;
					}
					
					break;
				case "contact": case "lead": data["linkedContacts"] = [sandbox.url.entityID()]; break;
			}
		}
		
		user = sandbox.cache.getUser(data.assigneeID);
		data["departmentID"] = user.defaultDepartmentID;
		data["department"] = user.defaultGroupID;
		
		taskTypeName = sandbox.cache.get("tasktype")[data.type].type;
		
		if(!!data.linkedContact){
			
			var typeMap = {"Call":"call", "Email":"email"}, type, cmMap, contactID;
			
			if(typeMap.hasOwnProperty(taskTypeName)){
				type = typeMap[taskTypeName],
				cmMap = map.settings.contactMethodMap[type][data.linkedContact];
				contactID = cmMap.contactID;
				cmMapIndex = data.linkedContact;
			}
			else
				contactID = data.linkedContact;

			if(!taskObj || !taskObj.linkedContacts || taskObj.linkedContacts.length == 0)
				data["linkedContacts"] = [contactID];
			else if(!!taskObj.linkedContacts && taskObj.linkedContacts.indexOf(contactID) == -1)
				data["linkedContacts"] = [contactID];
			
			delete data["linkedContact"];
		}
		
		if(user.isGroup)
			data["assigneeID"] = null;
				
		if(["Call", "Email","To-do"].indexOf(taskTypeName) != -1){
			
			delete data["history"];
			if(taskTypeName == "Call" && !!data.linkedContacts && data.linkedContacts.length > 0 && !isUpdateOperation){
				
				/*var cmMap = sandbox.cache.get("contacts")[data.linkedContacts[0]].contactmethods, 
					cmList= [], matchList = [];
				sandbox.dom.each(cmMap, function(cmID, cm){
					if(cm.type == "phone")
						cmList.push(cm.value);
				});
				
				matchList = data.comments.match( /\d+/g );
				sandbox.dom.each(matchList, function(index, str){
					if(cmList.indexOf(str) != -1 && str.length > 3)
						areaCode = str.substring(0,3);
				});*/
				
				phoneNo = map.settings.contactMethodMap["call"][cmMapIndex]["cmValue"];
				if(phoneNo.length > 3)
					areaCode = phoneNo.substring(0,3);
			}
		}
		
		if(isUpdateOperation && !phoneNo)
			areaCode = "";
		data["areaCode"] = areaCode;
		
		if(!data["dueDate"]){
			
			var coeff = 1000 * 60 * 30,
				date = new Date(Math.ceil(new Date().getTime() / coeff) * coeff);  // ceil - to round off to upper limit
				date.setHours(date.getHours()+1);
			
			data["dueDate"] = sandbox.util.formatDate(date,'MM/dd/yyyy h:mm a');
		}
		
		if(isUpdateOperation && !!data.assigneeID && data.assigneeID != taskObj.assigneeID){ //updateTask
			
			var ownerDetails = sandbox.cache.getUser(taskObj.ownerID);
			if(!!ownerDetails){
				mapOfTaskData['ownerName'] = ownerDetails["name"];
				mapOfTaskData['ownerEmail'] = ownerDetails["email"];
			}
			
			isTaskInfoNeeded = true;
			data["operation"] = "reassign";
			mapOfTaskData["taskID"] = map.settings.taskID;
		}
		else if(!!data.assigneeID && userID != data.assigneeID){
			isTaskInfoNeeded = true;
			mapOfTaskData['ownerName'] = userName;
			mapOfTaskData['ownerEmail'] = userEmail;
			
			if(!!map.settings.taskID)
				mapOfTaskData['taskID'] = map.settings.taskID;
		}
		
		if(isUpdateOperation && !!taskObj.linkedTags){
			
			var tagsRemoved = [], tagsFound=0;
				tags= !!data.tags? data.tags:[],
				tagsCache = sandbox.cache.get("tags");
			
			sandbox.dom.each(taskObj.linkedTags, function(index, tagID){
				if(tags.indexOf(tagsCache[tagID].name) == -1)
					tagsRemoved.push(tagID);
				else
					tagsFound++;
			});

			if(tagsRemoved.length == 0 && tagsFound == taskObj.linkedTags.length && tags.length == taskObj.linkedTags.length)
				delete data["tags"];
			else if(tagsRemoved.length > 0)
				data["removetags"] = tagsRemoved;
		}

		if(isTaskInfoNeeded) {

			//user = sandbox.cache.getUser(data.assigneeID);

			//listSubscriberEmails = getSubscriberEmailsForTask(linkedSubscribers);		
			
			mapOfTaskData['assigneeName'] = user.name;
			mapOfTaskData['assigneeEmail'] = user.email;
			mapOfTaskData['userName'] = userName;
			mapOfTaskData['userEmail'] = userEmail;
			mapOfTaskData['assigneeID'] = data.assigneeID;
			mapOfTaskData['ownerID'] = data.ownerID;
			
			//CHECK
			if(!sandbox.util.isEmptyObject(data.linkedTagNames))
				mapOfTaskData["tags"] = data.linkedTagNames;
			
			//mapOfData['subscribers'] = listSubscriberEmails;	
			mapOfTaskData['dueDate'] = data.dueDate;
			mapOfTaskData['operation'] = 'reassign';
			mapOfTaskData['taskassigneemail'] = true;
			data['taskinfo'] = mapOfTaskData;
		}

		data["utcOffsetString"] = sandbox.cache.get("timeZoneAndOffset")["offset"];
		
		if(map.settings.hasOwnProperty("isCreateNewTicketFromDropdown") && map.settings.isCreateNewTicketFromDropdown) {
			
			var ownerName = userName , ownerID = userID;
			
			if(map.settings.hasOwnProperty("linkedDocuments") && !sandbox.util.isEmptyObject(map.settings.linkedDocuments))
				data['linkedDocuments'] = map.settings.linkedDocuments;
			
			if(map.settings.hasOwnProperty("historyOwnerID"))
				ownerID = map.settings.historyOwnerID;
				
			if(map.settings.hasOwnProperty("historyOwnerName"))
				ownerName = map.settings.historyOwnerName;
			
			data['notes'] = "";
			data['history'] = [{ type : map.settings.type, departmentID : user.defaultDepartmentID, ownerID : ownerID, ownerName : ownerName, historyComments : map.settings.notes, taskComments : map.settings.comments, resolutionComments : map.settings.comments}];
			
		}

		//timezone for lead's task
		
		data = sandbox.util.removeEmptyValuePairs(data);
		
		if(isUpdateOperation && !!taskObj.notes && !data.notes)
			data.notes = "";
		
		if(user.isGroup)
			data["assigneeID"] = null;
		
		return data;
	},
	
	createTask = function(data){
		
		if(_isOperationOngoing)
			return;
		_isOperationOngoing = true;

		var map = constructTaskMap(data),
			metaDataForJS = {};

		if(!validateNewTask(map)){
			_isOperationOngoing = false;
			return;
		}
		
		if(data.hasOwnProperty("customField"))
			map["customField"] = data["customField"];
		
		map["utcOffsetString"] = sandbox.cache.get("timeZoneAndOffset")["offset"];
		
		metaDataForJS["page"] = sandbox.url.page();
		metaDataForJS["entityID"] = sandbox.url.entityID();

		_taskCreationData = data;
		sandbox.ajax.request({method: "POST", url: "/createTask?apikey="+sandbox.cache.get("accountID"), endpoint:"/createTask", data: map, callBack: createTask_Callback,metaDataForJS:metaDataForJS});
		sandbox.alert.message({text:"Creating task..."});
		sandbox.publish("hide-custom-popup");
	},
	
	createTask_Callback = function(data){
		
		if(!!data.tag)
			sandbox.publish("tags-created", data.tag);

		var id = data.task.id, task = data.task, newMap= {},
			page = data.metaDataForJS["page"],
			entityID = data.metaDataForJS["entityID"];
	
		newMap[id] = task;
		//sandbox.publish("hide-custom-popup");
		
		if(page != "tasks"){
			
			sandbox.publish("new-task-created-detailpage", { type : page, task: task});
			
			var cacheObj = sandbox.cache.get(page+"s"),
				obj = cacheObj[entityID],
				linkedTasks = obj.linkedTasks;

			linkedTasks = !linkedTasks?[] : linkedTasks;
			linkedTasks.push(task.id);
			obj.linkedTasks = linkedTasks;

			if(sandbox.url.page() != "lead")
				sandbox.publish(page+"-updated", {obj : obj, id : obj.id}); //deal-updated, account-updated, contact-updated
			else{
				  var leadMap = {};
				  leadMap[obj.id] = obj;
				  sandbox.publish("lead-updated", {obj :leadMap , id : obj.id, operation:"update"});
			}
			_entityID = entityID;
			_entityType = page;
			sandbox.publish("update-analytics",{category:"Create",action:page.charAt(0).toUpperCase() + page.substr(1)+"-Task",label: sandbox.cache.get("loggedInUserEmail")+ "-" +sandbox.cache.get("accountID") });
		}
		else{
			sandbox.publish("new-task-created", newMap);
			_entityID = id;
			_entityType = "task";
			sandbox.url.changeHash("task", id);
		}
		
		generateActivityLogForCreateAndUpdate({}, task, data);

		sandbox.alert.hideMessage();
		sandbox.alert.message({text:"Task created successfully.", time:2000});
		_isOperationOngoing = false;
		return;
	},
	
	updateTask = function(data){
		
		if(_isOperationOngoing)
			return;
		_isOperationOngoing = true;
		
		var map = constructTaskMap(data), metaDataForJS = {};
		
		if(!validateNewTask(map))
			return;
		
		metaDataForJS["page"] = sandbox.url.page();
		metaDataForJS["entityID"] = sandbox.url.entityID();
		
		sandbox.ajax.request({method: "PUT", url: "/updateATask/"+data.settings.taskID+"?apikey="+sandbox.cache.get("accountID")+"&isLoggedIn=true", endpoint:"/updateATask", data: map, callBack: updateTask_Callback,metaDataForJS:metaDataForJS});
		sandbox.alert.message({text:"Updating task..."});
		sandbox.publish("hide-custom-popup");
	},
	
	updateTask_Callback = function(data){
		
		if(!!data.tag)
			sandbox.publish("tags-created", data.tag);
		
		var id = data.task.id, 
			task = data.task,
			//page = sandbox.url.page(), contactsCache;
			page = data.metaDataForJS["page"],
			entityID = data.metaDataForJS["entityID"],
			contactsCache;
		
		//sandbox.publish("hide-custom-popup");
		
		if(page != "tasks"){
			
			sandbox.publish("new-task-updated-detailpage", { type : page, task: task});
			
			var linkedProp;
			
			switch(page){
				case "deal" :  linkedProp = "linkedDeal"; break;
				case "account" :  linkedProp = "linkedAccount"; break;
				case "contact": case "lead": linkedProp = "linkedContacts"; break; 
			}
			
			if(!task[linkedProp] || 
				(linkedProp == "linkedContacts" && (!task["linkedContacts"] || (!!task["linkedContacts"] && task["linkedContacts"].indexOf(entityID) == -1)))){
			
				var cacheObj = sandbox.cache.get(page+"s"),
					obj = cacheObj[entityID],
					linkedTasks = obj.linkedTasks,
					index = linkedTasks.indexOf(id);
	
				linkedTasks.splice(index,1);
				obj.linkedTasks = linkedTasks;
				
				sandbox.publish(page+"-updated", {obj : obj, id : obj.id}); //account-updated, deal-updated
			}
			_entityType = page;
			_entityID = entityID; 
			sandbox.publish("update-analytics",{category:"Edit",action:page.charAt(0).toUpperCase() + page.substr(1) + "-Task",label: sandbox.cache.get("loggedInUserEmail")+ "-" +sandbox.cache.get("accountID") });
		}
		else{
			sandbox.publish("task-updated", {id: id, obj: task});
			_entityType = "task";
			_entityID = id;
		}
		
		if(!!data.contacts){
			contactsCache = sandbox.cache.get("contacts");
			data.contacts.map(function(contact){
				contactsCache[contact.id] = contact;
				sandbox.publish("contact-updated",{id: contact.id});
			});
		}
		
		generateActivityLogForCreateAndUpdate(_oldTask, task, data);
		
		sandbox.alert.hideMessage();
		_isOperationOngoing = false;
	},

	validateNewTask = function(data){

		var isAdminUser = sandbox.cache.get("adminUser");
		
		if(!data.comments){
			sandbox.alert.message({text:"Please enter a brief summary of the task", time:3000});
			sandbox.dom("#addTaskPopupComments").addClass("error").focus();
			return false;
		}
		if(!sandbox.util.isEmptyObject(data.tags) && !isAdminUser){
			
			var tagsCache = sandbox.cache.get("tags"), isFound;
			
			sandbox.dom.each(data.tags, function(index, tagName){

				isFound = false;
				sandbox.dom.each(tagsCache, function(id, tag){
					if(tagName == tag.name){
						isFound = true;
						return false;
					}
				});
				
				if(!isFound){
					sandbox.alert.message({text:"Basic users cannot create new tags.", time:3000});
					return false;
				}
				
			});
			
			if(!isFound)
				return false;
		}
		
		return true;
	},
	
	//update operation for basic types like call, email,todo and sms using popup only
	generateActivityLogForCreateAndUpdate = function(oldTask, newTask, result){
		
		var isUpdate = true,
			taskID = newTask.id,
			historyComments, dueDateString, assignee = "Unassigned", count=0,fieldMap,
			userName = sandbox.cache.get("loggedInUserName"),
			taskTypeName = sandbox.cache.get("tasktype")[newTask.type].type,
			entityID, entityType, tagIDList, removedID=[], addedID=[],oldDueTime,
			oldAssignee, newAssignee, assigneeID,
			tagsCache = sandbox.cache.get("tags");
		
		if(sandbox.util.isEmptyObject(oldTask)){
			isUpdate = false;
			historyComments=userName+" Added a task<br/>";
		}
		else{
			historyComments=userName+" Edited a task<br/>";
			oldDueTime = new Date(oldTask.dueDate).getTime();
		}
		
		if(isUpdate)
			historyComments+='<br/><b style="color:#0084b0;">Summary :</b> '+oldTask.comments;
		
		historyComments+='<br/><b style="color:#0084b0;">TaskID :</b> '+taskID+'<br/><br/> Details :<br/>';
		
		if(!isUpdate || oldTask.comments != newTask.comments)
			historyComments+='<br/><b style="color:#0084b0;">Summary :</b> '+newTask.comments;
		if((!isUpdate && !!newTask.notes) || (isUpdate && oldTask.notes != newTask.notes))
			historyComments+='</br><b style="color:#0084b0;">Notes :</b> '+newTask.notes;
		
		if((!isUpdate && !!newTask.dueDate) || (isUpdate && oldDueTime != new Date(newTask.dueDate).getTime())){
			dueDateString = sandbox.util.formatDate(new Date(newTask.dueDate), "h:mm a d NNN y");
			historyComments+='<br/><b style="color:#0084b0;">Due Date :</b> '+dueDateString;
		}
		
		if(!isUpdate || (isUpdate && oldTask.assigneeID != newTask.assigneeID)){
			assignee = !!newTask.assigneeID? newTask.assigneeID:newTask.department;
			assignee = sandbox.cache.getUser(assignee).name;
			historyComments+='<br/><b style="color:#0084b0;">Assignee :</b> '+assignee;
		}
		else if(isUpdate){//for group to user or group to group
			assigneeID = !!oldTask.assigneeID? oldTask.assigneeID : oldTask.department;
			oldAssignee = sandbox.cache.getUser(assigneeID).name;
			assigneeID = !!newTask.assigneeID? newTask.assigneeID : newTask.department;
			newAssignee = sandbox.cache.getUser(assigneeID).name;
			if(oldAssignee != newAssignee)
				historyComments+='<br/><b style="color:#0084b0;">Assignee :</b> '+newAssignee;
		}
		
		if(!isUpdate)
			historyComments+='<br/><b style="color:#0084b0;">Added By :</b> '+userName;
		
		if(!isUpdate || (isUpdate && oldTask.type != newTask.type))
			historyComments+='<br/><b style="color:#0084b0;">Task Type :</b> '+taskTypeName;

		if(!isUpdate && !!result.tag){
			historyComments+='<br/><b style="color:#0084b0;">Tags :</b>';
			sandbox.dom.each(result.tag, function(key, value){
				if(count == 0)
					historyComments+=value.name;
				else
					historyComments+=", "+value.name;
				count++;
			});
		}
		else if(isUpdate){
			
			if(sandbox.util.isEmptyObject(oldTask.linkedTags) && !sandbox.util.isEmptyObject(newTask.linkedTags)){
				addedID = newTask.linkedTags;
			}
			else if(sandbox.util.isEmptyObject(newTask.linkedTags) && !sandbox.util.isEmptyObject(oldTask.linkedTags)){
				removedID = oldTask.linkedTags;
			}
			else if(!sandbox.util.isEmptyObject(newTask.linkedTags) && !sandbox.util.isEmptyObject(oldTask.linkedTags)){
				
				oldTask.linkedTags.map(function(tagID){
					if(newTask.linkedTags.indexOf(tagID) == -1)
						removedID.push(tagID);
				});
				newTask.linkedTags.map(function(tagID){
					if(oldTask.linkedTags.indexOf(tagID) == -1)
						addedID.push(tagID);
				});
			}
			
			if(!sandbox.util.isEmptyObject(removedID)){
				historyComments+='<br/><b style="color:#0084b0;">Removed Tags :</b> ';
				count =0;
				sandbox.dom.each(removedID,function(i,tagID){
					if(!tagsCache.hasOwnProperty(tagID))
						return true;
					if(count == 0)
						historyComments+=tagsCache[tagID].name;
					else
						historyComments+=", "+tagsCache[tagID].name;
					count++;
				});
			}
			if(!sandbox.util.isEmptyObject(addedID)){
				historyComments+='<br/><b style="color:#0084b0;">Added Tags :</b> ';
				count =0;
				addedID.map(function(tagID){
					if(count == 0)
						historyComments+=result.tag[tagID].name;
					else
						historyComments+=", "+result.tag[tagID].name;
					count++;
				});
			}
		}
		
		if(!isUpdate && !sandbox.util.isEmptyObject(_taskCreationData.customField)){
			
			historyComments+='<br/><br/><br/>Custom Fields</br>';
			fieldMap = sandbox.cache.get("fieldInfo");
			
			_taskCreationData.customField.map(function(cf){
				historyComments+='</br><b style="color:#0084b0;">'+fieldMap[cf.fieldInfoID].name+'</b> '+cf.value;
			});
		}

		sandbox.publish("insert-activity-log", { entityType : _entityType, entityID : _entityID, historyComments : historyComments, taskID: taskID});
		_entityType = _entityType = _taskCreationData = _oldTask = null;
		
	};

	return {
		
		init : function() {
			sandbox.subscribe("new-task-create", createTask);
			sandbox.subscribe("task-update-popup", updateTask);
		}
	};
});

DSCRM.Core.registerModule("tasksList", ["tables","util","ajax", "cache","alert","url"],function(sandbox) {
	
	var _self = null, _tableTag = "#tasklisting table",
		_template = dscrm.templates.tasks.taskList,
		_unreadTasksCount = 0,
		_tableID = 'user-tasks',
		_tableDom = 'tasks-listing',
		_timeZoneMap = {},
		_lateCount=0, _todayCount =0, _tomorrowCount = 0,
		_isTableInitialized = false,
		_taskCommentsCol = 1, _createdDateLongCol = 2, _localDateLongCol = 3, _dueDateLongCol = 4, _typeCol = 5, _tagsListStringCol = 6 ,_addedByNameCol = 8,    
		_dueDateStringCol = 10, _timeZoneCol=13, _statusCol = 14,
		_taskCacheMap = {},
		_taskOwnerNamesToFetch = [],
		_allOpenCursor="",
		_allOpenResults = [],
		_isWaitingForTaskTypes =true,
		_funcWaitingForTaskTypes = [];

	//this method adds tasks to the listing and to the Tasks cache object. It can be called just for the latter purpose too.
	var appendRows = function(taskMap) {
		
		/*if(!_isTableInitialized)
			return;*/
		if(sandbox.util.isEmptyObject(taskMap))
			return;
		if(sandbox.util.isEmptyObject(sandbox.cache.get("tasktypes"))){
			_funcWaitingForTaskTypes.push({func:appendRows, args:[taskMap],thisObj:this});
			return;
		}
		
		var task, tasks = [], data = {},
			loggedInUserID = sandbox.cache.get("loggedInUserID"),
			taskTypes = sandbox.cache.get("tasktype"),
			basicTaskTypes = ["Call","Email","To-do","Sms"],
			tags = sandbox.cache.get("tags");
		
		_taskOwnerNamesToFetch = [];
		
		for(var i=0,keys = Object.keys(taskMap),l=keys.length; i<l;i++) {

			task = taskMap[keys[i]];
			
			if(!task.open && basicTaskTypes.indexOf(taskTypes[task.type].type) != -1){
				delete _taskCacheMap[task.id];
				continue;
			}
			
			task = prepareTaskForInsertion(task, taskTypes, tags);
			_taskCacheMap[task.id] = task;
			
			if(!_isTableInitialized || task.assigneeID != loggedInUserID || !task.open)
				continue;

			tasks.push(task);
		}

		sandbox.tables.addRows(_tableID, _template({tasks: tasks}), false);
		
		if(_isTableInitialized && !sandbox.util.isEmptyObject(_taskOwnerNamesToFetch)){
			data["parentDOMID"] = "tasksListOwners";
			data["selectedContactID"] = _taskOwnerNamesToFetch;
			sandbox.publish("users-selected-fetch", data);
			_taskOwnerNamesToFetch = [];
		}
		
		sandbox.cache.update({tasks : _taskCacheMap});
		updateStats();
	},
	
	//Set values in Task objects for the template. The same values will be present in Task objects in cache.
	prepareTaskForInsertion = function(task, taskTypes, tags){
		
		var owner, tagNames=[], linkedTagID = [];
		
		task["createdDateString"] = sandbox.util.formatDate(new Date(task.createdDate), "d NNN y");
		task["dueDateString"] = sandbox.util.formatDate(new Date(task.dueDate), "h:mm a d NNN y");
		task["dueDate"] = new Date(task["dueDate"]).getTime();
		
		//if(!!task["timeZoneID"] && !!task["utcoffset"]){

			localTimeData = sandbox.util.getLocalTime(parseFloat(task["utcoffset"]));
			localTimeString = localTimeData["str"] + " "+ task["timeZoneID"];
			localTime = localTimeData["date"].getTime();
		//}

		task["localTimeString"] = localTimeString;
		task["localTime"] = localTime;
		task["ratingStarCount"] = sandbox.util.getStarCountForRating(task.rating);
		if(!!task.ownerID){
			owner = sandbox.cache.getUser(task.ownerID);
			if(!!owner){
				task["ownerName"] = owner.name;
				task["ownerNameNotFetched"] = "";
			}
			else if(sandbox.cache.get("isAllUsersFetched")){
				task["ownerName"] = "Unknown";
				task["ownerNameNotFetched"] = "";
			}
			else{
				task["ownerName"] = "Loading...";
				task["ownerNameNotFetched"] = "ownerNameNotFetched";
				_taskOwnerNamesToFetch.push(task.ownerID);
			}
		}
		else{
			task["ownerName"] = "";
			task["ownerNameNotFetched"] = "";
		}
		
		if(!sandbox.util.isEmptyObject(task.linkedTags)){
			sandbox.dom.each(task.linkedTags, function(i, tagID){
				if(!tags.hasOwnProperty(tagID))
					return true;
				tagNames.push(tags[tagID].name);
				linkedTagID.push(tagID);
			});
			task["tagNames"] = tagNames;
			task["tagCount"] = tagNames.length;
		}
		else
			task["tagCount"] = 0;
		
		//task["tagNamesString"] = tagNames.join(",");
		task["tagNamesString"] = linkedTagID.join(" ");

		task["taskTypeName"] = taskTypes.hasOwnProperty(task.type) ? taskTypes[task.type].type : "";
		task["page"]= setTaskPageLink(task);
		
		return task;
	}, 
	
	setTaskPageLink = function(task){
		
		var taskType = task.taskTypeName, data = {}, URL,
			isTicketingSystemEnabled = sandbox.util.getFeatureAvailablityStatus("ticketingSystem"),
			basicTaskTypes = ["Call","Email","To-do","Sms"];
		
		if(isTicketingSystemEnabled && basicTaskTypes.indexOf(taskType) == -1) {
			data['type'] = 'task';
			data['ID'] = task.id;
			return data;
		}
		
		if(!!task.linkedAccount) {
			data['type'] = 'account';
			data['ID'] = task.linkedAccount;
		}
		else if(!!task.linkedDeal) {
			data['type'] = 'deal';
			data['ID'] = task.linkedDeal;
		}
		else if(!sandbox.util.isEmptyObject(task.linkedContacts)) {
			data['type'] = 'contact';
			data['ID'] = task.linkedContacts[0];
		}
		else if(isTicketingSystemEnabled) {
			data['type'] = 'task';
			data['ID'] = task.id;
		}
		
		if(basicTaskTypes.indexOf(taskType) != -1 && task.status == "unread")
			data['ID'] = data['ID'] + "?unreadTaskID=" + task.id;
		
		return data;
		
	},
	
	//Removes Tasks from cache and updates the Tasks Listing page stats if necessary.
	removeTasksFromCache = function(tasks){
		
		var loggedInUserID = sandbox.cache.get("loggedInUserID"), isStatsUpdateNeeded=false;

		sandbox.dom.each(tasks, function(index, value){
			
			if(!isStatsUpdateNeeded && loggedInUserID == value.assigneeID && !value.open)
				isStatsUpdateNeeded = true;
			
			delete _taskCacheMap[value.id];
		});
		
		sandbox.cache.update({tasks : _taskCacheMap});
		if(isStatsUpdateNeeded)
			updateStats();
	},
	
	//Get all open Tasks assigned to user. Takes recursive calls based on cursor.
	//This method is called soon after the call to getFirstSetOfTasks
	getAllTasksOfUser = function(resultObject) {
		
		var taskMap={}, tasksCount=0, unreadTaskMap = {}, unreadTasksCount=0, newResult={};
		
		if(!!resultObject) {
			
			_allOpenCursor = resultObject.nextCursor;
			_allOpenResults.push(resultObject);
			
			if(!_allOpenCursor){
				
				sandbox.tables.removeRowsBySelector(_tableID, "", true);
				
				_allOpenResults.map(function(result){
					
					sandbox.dom.each(result.tasks, function(key, task){
						taskMap[key] = task;
					});
					
					tasksCount+=result.tasksCount;
					
					if(result.hasOwnProperty("unreadTasks")){
						
						sandbox.dom.each(result.unreadTasks, function(key, task){
							unreadTaskMap[key] = task;
							taskMap[key] = task;
						});
						
						unreadTasksCount+=result.unreadTasksCount;
					}
					
				});
				
				newResult.tasksCount = tasksCount;
				newResult.tasks = taskMap;
				if(!sandbox.dom.isEmptyObject(unreadTaskMap)){
					newResult.unreadTasksCount=unreadTasksCount;
					newResult.unreadTasks=unreadTaskMap;
				}
				
				//manually triggering the default search filter
				sandbox.dom(".filterdate_list").val("Late And Today").trigger("change");

				appendRows(newResult.tasks);
				sandbox.tables.draw(_tableID, true);
				//!!newResult.unreadTasks?appendRows(newResult.unreadTasks):!0;
				sandbox.alert.hideMessage();
				_allOpenResults = []; _allOpenCursor="";
				sandbox.dom("#tasks .filteredlist").removeClass("hide");
				
				if(sandbox.util.getFeatureAvailablityStatus("ticketingSystem") && sandbox.cache.get("plainTaskEnabled"))
					sandbox.dom("#tasks #addtask").removeClass("hide");
				
				return;
			}
		}
		
		/*var url, status, allStatusFetched = true;
		
		if(!_allOpenCursor)
			return;
		else{
			
			status = _statusList[_statusListFetched.length];
			_statusListFetched.push(status);
			allStatusFetched = false;*/
			
		/*}*/
		
		if(!_allOpenCursor){
			sandbox.dom("#tasks .filteredlist").addClass("hide");
			sandbox.dom("#tasks #addtask").addClass("hide");
		}
		
		var selectedDepartmentID = sandbox.cache.get("selectedDepartmentID"),
        	loggedInUserID = sandbox.cache.get("loggedInUserID"),
        	accountID = sandbox.cache.get("accountID"),url,
        	isTicketingSystemEnabled = sandbox.util.getFeatureAvailablityStatus("ticketingSystem");
        
        url = "/getAllTasksForUser/"+loggedInUserID+"?apikey="+accountID+
        		"&departmentID="+selectedDepartmentID+"&ticketingSystemEnabled="+isTicketingSystemEnabled+"&cursor="+_allOpenCursor;
		
		sandbox.ajax.request({method: "POST", url: url , data: {}, endpoint:"/getAllTasksForUser", callBack: getAllTasksOfUser});
		sandbox.alert.message({text:"Fetching all open tasks..."});

		/*if(!!_allOpenCursor)
			getAllTasksOfUser();*/
		
		//showTasksContent();
	},
	
	getFirstSetOfTasks = function(result) {
		
		if(arguments.length > 0) {
			
			var tasks = result.task,
				id = result.ids, newMap = {};
			
			if(sandbox.util.isEmptyObject(tasks))
				return;
			
			id.map(function(taskID){
				newMap[taskID] = tasks[taskID];
			});
			
			appendRows(newMap);
			sandbox.tables.draw(_tableID, true);
			return;
		}
		
		var data = {};
		data["accountpin"] = sandbox.cache.get("accountID");
		data["departmentID"] = sandbox.cache.get("selectedDepartmentID");
		data["onload"] = true;
		
		sandbox.ajax.request({method: "POST", url: "/getTasksForTaskPage" , endpoint:"/getTasksForTaskPage", data: data, callBack: getFirstSetOfTasks});

		showTasksContent();
	},
	
	updateStats = function(){
		
		if(!_isTableInitialized)
			return;

		var localTime, timeZone, i=0, keys = Object.keys(_taskCacheMap), l = keys.length, task, dueDate,timeZoneSelected, unreadTasks=[],
			
			date = new Date(),
			startOfToday = new Date(parseInt(date.getFullYear(),10),parseInt(date.getMonth(),10),parseInt(date.getDate(),10),0,0,0).getTime(),
	        endOfToday = new Date(parseInt(date.getFullYear(),10),parseInt(date.getMonth(),10),parseInt(date.getDate(),10),23,59,59).getTime(),
	        startOfTomo =  new Date(parseInt(date.getFullYear(),10),parseInt(date.getMonth(),10),parseInt(date.getDate(),10)+1,0,0,0).getTime(),
			endOfTomo =  new Date(parseInt(date.getFullYear(),10),parseInt(date.getMonth(),10),parseInt(date.getDate(),10)+1,23,59,59).getTime(),
			loggedInUserID = sandbox.cache.get("loggedInUserID"),
			departmentID = sandbox.cache.get("selectedDepartmentID");
		
		_unreadTasksCount = _lateCount = _todayCount = _tomorrowCount = 0;
		
		for(;i<l;i++) {
			
			task = _taskCacheMap[keys[i]];
			
			if(loggedInUserID != task.assigneeID || !task.open || departmentID != task.departmentID)
				continue;
			
			if(task.status == "unread"){
				_unreadTasksCount+=1;
				unreadTasks.push(task);
			}

			localTime = task.localTimeString;
			timeZone = localTime.substr(localTime.lastIndexOf(" ")+1);

			_timeZoneMap[task.timeZoneID] = "( GMT "+sandbox.util.parseMillisecondsIntoReadableTime(task.utcoffset)+" ) "+task.timeZone;
			
			dueDate = task.dueDate;
			if(dueDate < startOfToday)
				_lateCount+=1;
			else if(dueDate >=startOfToday && dueDate <= endOfToday)
				_todayCount+=1;
			else if(dueDate >=startOfTomo && dueDate <= endOfTomo)
				_tomorrowCount+=1;
		}

		if(!!_unreadTasksCount)
			sandbox.publish("unreadTasks-add", {count: _unreadTasksCount, tasks: unreadTasks});
		/*if(_unreadTasksCount == 0)
			sandbox.dom(".unreadTasksCount").html("");
		else
			sandbox.dom(".unreadTasksCount").html(_unreadTasksCount);*/
		//timeZoneSelected = sandbox.dom("section#tasks aside select.filtertimezone_list").val();
		//sandbox.dom("section#tasks aside select.filtertimezone_list").html(timeZoneListTemplate({timeZones : timeZoneMap})).val(timeZoneSelected).selectpicker("refresh");
		populateTimeZones(_timeZoneMap);
		sandbox.dom("#taskListLateCount").html(_lateCount);
		sandbox.dom("#taskListTodayCount").html(_todayCount);
		sandbox.dom("#taskListTomorrowCount").html(_tomorrowCount);
	},
	
	populateTimeZones = function(timeZoneMap){
		
		var map = {}, html, selectedValue,
			el = sandbox.dom("#tasks select.filtertimezone_list");
		
		selectedValue = el.val();

		html = dscrm.templates.tasks.timeZonesList({tzMap: timeZoneMap});
		el.html(html);
		
		if(!!selectedValue)
			el.val(selectedValue);
		
		el.selectpicker("refresh");
	},
	
	showTasksContent = function() {
        sandbox.dom("main").children().removeClass("active in");
		sandbox.dom("#tasks").addClass("active");
        setTimeout(function(){ sandbox.dom("#tasks").addClass("in"); }, 100);
    },
	
	setDateFilterValues = function(e){
		
		var className = e.target.className, fromStr, toStr, arr, from, to,
			val = e.target.value;
		
		if(!val)
			return;
		
		if(className.indexOf("filterdate_list") != -1){
			
			sandbox.dom(".fromdatepicker, .todatepicker").val("");
			arr = sandbox.util.getDateObjectFromString(val);
		}
		else{

			fromStr = sandbox.dom(".fromdatepicker").val();
			toStr = sandbox.dom(".todatepicker").val();
			
			if(!fromStr || !toStr)
				return;
			
			sandbox.dom(e.target).parents("aside").find(".filterdate_list").selectpicker("val","");
			arr = sandbox.util.getDateObjectFromString(fromStr, toStr);
		}

		from = arr[0];
		to = arr[1];
		
		if(from > to){
			sandbox.alert.message({text:"The From date must be earlier than the To Date", time:5000});
			sandbox.dom(".fromdatepicker, .todatepicker").val("");
			return;
		}
		else if(from == to && from == 0)
			from = to = "";

		sandbox.dom("#taskListFilterFromDate").val(from);
		sandbox.dom("#taskListFilterToDate").val(to).trigger("change");
	},
	
	setFilterLabels = function(e){
		
		var className, val=null, target;
		
		if(e.target.id == "taskListFilterToDate"){
			
			//target = sandbox.dom("section#tasks aside .filterdate_list")[0];

			//if(!(val = target.value)){
				if(!!sandbox.dom("section#tasks aside .fromdatepicker").val() && !!sandbox.dom("section#tasks aside .todatepicker").val())
					val = sandbox.dom("section#tasks aside .fromdatepicker").val() + " - "+sandbox.dom("section#tasks aside .todatepicker").val();
				else
					val = undefined;				
			//}

			className = "filterdate_list";
		}
		else if(e.target.className.indexOf("filterdate_list") != -1){
			
			val = e.target.value;
			//if(val == "Custom Date Range")
				//return;
			//val = val.substr(3,val.length-5);
			className= "filterdate_list";
		}
		else if(e.target.className.indexOf("filtertimezone_list") != -1){
			
			val = e.target.value;
			val = val.substr(3,val.length-5);
			className= "filtertimezone_list";
		}
		else if(e.target.className.indexOf("filtertype_list") != -1){
			
			val = e.target.value;
			if(!!val)
				val = sandbox.cache.get("tasktype")[val].type;
			className= "filtertype_list";
		}
		else if(e.target.className.indexOf("filtertag_list") != -1){
			
			val = e.target.value;
			if(!!val)
				val = sandbox.cache.get("tags")[val].name;
			className= "filtertag_list";
		}
		else
			className = e.target.className;

		if(val == null)
			val = this.value;

		className = className.substr(className.indexOf("filter"), className.indexOf("_list")+1);
		className +="label";
		
		if(!val)
			sandbox.dom("#"+className).addClass("hide");
		else
			sandbox.dom("#"+className).removeClass("hide").children("span.taskFilterValue").html(val);
	},

	clearAllSearchFilters = function(e){
		
		var taskSection = sandbox.dom("section#tasks"); 
		
		taskSection.find("aside .fromdatepicker").val("");
		taskSection.find("aside .todatepicker").val("");
		taskSection.find("aside select.filterdate_list").val("All").selectpicker("refresh");
		
		taskSection.find("aside select.filterstatus_list").val("").trigger("change");
		taskSection.find("aside select.filtertype_list").val("").trigger("change");
		taskSection.find("aside select.filtertag_list").val("").trigger("change");
		taskSection.find("aside select.filtertimezone_list").val("").trigger("change");
		
		taskSection.find("#taskListFilterFromDate").val("");
		taskSection.find("#taskListFilterToDate").val("").trigger("change");
		
		sandbox.dom("label.taskListFilterLabel").addClass("hide");
	},
	
	clearSearchFilter = function(e){
		
		var id = sandbox.dom(e.target).parents("label").addClass("hide").attr("id"),
			val = "";
		
		id = id.substr(0,id.indexOf("_")+1) + "list";
		if(id == "filterdate_list")
			val = "All";
		
		sandbox.dom("select."+id).val(val).selectpicker("refresh").trigger("change");
	},
	
	getSelectedTasks = function() {
		
		var arr = sandbox.dom(_tableTag+" td.checklist input:checked"), id = [];
		
		sandbox.dom.each(arr, function(index, tag){
			id.push(tag.getAttribute("taskid"));
		});
		if(id.length == 0)
			sandbox.alert.message({text:"Please select tasks.", time:3000});

		return id;
	},
	
	unselectTasks = function() {
		sandbox.dom(_tableTag+" td.checklist input:checked").prop("disabled",false).prop("checked", false);
	},
	disableSelectedTasks = function() {
		sandbox.dom(_tableTag+" td.checklist input:checked").attr("disabled","disabled");
	},
	
	bulkTaskOperations = function(e){
//		console.info(e);
		var op, arr, text, isConfirmed = false, data = {}, isFormEmpty = false;
		
		if(e.hasOwnProperty("settings")){
			isConfirmed = e.settings.isConfirmed;
			op = e.settings.op;
		}
		else if(e.target.tagName == "A")
			op = sandbox.dom(e.target).parent("li").attr("op");
		else if(e.target.tagName == "I")
			op = sandbox.dom(e.target).parent("a").parent("li").attr("op");
		else
			op = e.target.getAttribute("op");

		arr = getSelectedTasks();

		if(arr.length == 0)
			return;
		
		text = "Are you sure you want to "+op+" "+arr.length+" task(s)?";
		
		if(!isConfirmed) {
			data["confirmButton"] = "OK";
			data["publish"] = "confirm-bulktask-operation";
			data["cancel"] = "cancel-bulktask-operation";
			data["form"] = "task"+op+"form"; //taskresolveform, taskreassignform, taskrescheduleform
			data["isConfirmed"] = true;
			data["op"] = op;
		}
		else {
			if(!sandbox.util.isEmptyObject(e.formData) && !!e.formData[0].value)
				data["formData"] = e.formData;
			else
				isFormEmpty = true;
			data["arr"] = arr;
		}
		
		switch(op){
			case "resolve" : {
					if(!isConfirmed){
						data["text"] = arr.length + " tasks marked for completion!";
						sandbox.publish("show-custom-popup", data);
					}
					else{
						if(isFormEmpty){
							sandbox.alert.message({text:"Please enter some comments.", time:3000});
							return;
						}
						sandbox.publish("hide-custom-popup");
						sandbox.alert.dialog({text : text, data: data, confirm: bulkResolveTasks, cancel : unselectTasks});
					}
			} break;
			case "reassign" : {
					if(!isConfirmed){
						data["text"] = "Who would you like to reassign these "+arr.length+" tasks to?";
						data["taskGroupsAsUsers"] = true;
						data["excludeGroups"] = [sandbox.cache.get("salesGroupID")];
						data["openUsersSearch"] = true;
						sandbox.publish("show-custom-popup", data);
					}
					else{
						if(isFormEmpty){
							sandbox.alert.message({text:"Please choose an assignee.", time:3000});
							return;
						}
						sandbox.publish("hide-custom-popup");
						sandbox.alert.dialog({text : text, data: data, confirm: bulkReassignTasks, cancel : unselectTasks});
					}
			} break;
			case "reschedule" : {
					if(!isConfirmed){
						data["text"] = "When would you like to reschedule these "+arr.length+" tasks for?";
						sandbox.publish("show-custom-popup", data);
					}
					else{
						if(isFormEmpty){
							sandbox.alert.message({text:"Please enter Due Date.", time:3000});
							return;
						}
						sandbox.publish("hide-custom-popup");
						sandbox.alert.dialog({text : text, data: data, confirm: bulkRescheduleTasks, cancel : unselectTasks});
					}
			} break;
			case  "delete" : {
					sandbox.alert.dialog({text : text, data: arr, confirm: bulkDeleteTasks});
			} break;
		}
	},
	
	bulkDeleteTasks = function(arr){
		
		sandbox.alert.message({text:"Deleting selected tasks..."});
		
		var url = "/deleteBulkTasks?apikey="+sandbox.cache.get("accountID");
		sandbox.ajax.request({method:"POST", url: url, endpoint:"/deleteBulkTasks", data: arr, callBack: bulkDeleteTasks_Callback});
		disableSelectedTasks();
	},
	
	bulkDeleteTasks_Callback = function(resultObject){
		//removeSelectedTasksFromTableAndCache();
		sandbox.alert.message({text:"Tasks deleted successfully.", time: 3000});
		
		var data = {};

		deleteTasksByID(resultObject.ids, false);
		
		dissociateTasksAfterResolveOrDelete(resultObject.deal, resultObject.tasks);

		data["type"] = "bulkDelete";
		data["tasks"] = resultObject.tasks;
		data["page"] = "Tasks";
		sandbox.publish("bulkTask-operation-complete",data);
		
		sandbox.publish("update-analytics",{category:"Tasks-Bulk",action:"Delete", label: sandbox.cache.get("loggedInUserEmail") + "-" + sandbox.cache.get("accountID")+"-"+resultObject.ids.length });
	},
	
	bulkRescheduleTasks = function(map){
		
		var data = {}, dueDate, dueTime;
		
		dueDate = map.formData[0].value;
		dueDate = dueDate.split(" ");
		dueTime = dueDate[1]+" "+dueDate[2];
		dueDate = dueDate[0];
		
		data["tasks"] = map.arr;
		data["dueDate"] = dueDate;
		data["dueTime"] = dueTime; 
		
		sandbox.alert.message({text:"Rescheduling tasks..."});
		
		url = "/rescheduleBulkTasks?apikey="+sandbox.cache.get("accountID");
		sandbox.ajax.request({method:"PUT", url: url, endpoint:"/rescheduleBulkTasks", data: data, callBack: bulkRescheduleTasks_Callback});
		disableSelectedTasks();
	},
	
	bulkRescheduleTasks_Callback = function(map){
		
		var updatedTask, rowIndex, row, data = {},
			//rowIndicesArray = sandbox.tables.getRowIndices(_tableID),
			tableDOM = sandbox.dom(_tableTag),
			trDOM = tableDOM.find("tbody tr"),
			pageStart = sandbox.tables.getPageInfo(_tableID).start,
			taskTypes = sandbox.cache.get("tasktype"),
			tagsCache = sandbox.cache.get("tags");
		
		unselectTasks();
		
		sandbox.dom.each(map.tasks, function(index, task){
			
			updatedTask = prepareTaskForInsertion(task, taskTypes, tagsCache); 
			_taskCacheMap[updatedTask.id] = updatedTask;
			
			row = tableDOM.find("tr.tasklist_"+updatedTask.id);
			rowIndex = sandbox.tables.getRowIndex(_tableID, row);
			
			sandbox.tables.updateCell(_tableID, {col: _dueDateLongCol, row: rowIndex, value: updatedTask.dueDate});
			sandbox.tables.updateCell(_tableID, {col: _dueDateStringCol, row: rowIndex, value: updatedTask.dueDateString});
		});

		sandbox.tables.draw(_tableID, false);
		
		updateStats();
		sandbox.cache.update({tasks : _taskCacheMap});
		
		data["type"] = "bulkReschedule";
		data["tasks"] = map.tasks;
		data["page"] = "Tasks";
		sandbox.publish("bulkTask-operation-complete",data);

		sandbox.publish("update-analytics",{category:"Tasks-Bulk",action:"Reschedule", label: sandbox.cache.get("loggedInUserEmail") + "-" + sandbox.cache.get("accountID")+"-"+map.tasks.length });
		
		sandbox.alert.message({text:"Tasks rescheduled successfully.", time: 3000});
	},
	
	bulkReassignTasks = function(data){
		
		var assigneeID = data.formData[0].value, arr = [], 
			loggedInUserID = sandbox.cache.get("loggedInUserID");
		
		//checking if tasks are already assigned to the user chosen.
		//Since this method is only called in task listing, all selected tasks will already be assigned to the logged-in user
		if(assigneeID == loggedInUserID){
			sandbox.alert.message({text:"Selected tasks are already assigned to the user chosen.", time:3000});
			return;
		}
		
		arr = data.arr;
		user = sandbox.cache.getUser(assigneeID);
		
		data= {};
		data["departmentID"] = user.defaultDepartmentID;
		data["department"] = user.defaultGroupID;
		data["task"] = arr;
		data["assigneeID"] = !!user.contactID? user.contactID : null;
		sandbox.alert.message({text:"Re-assigning tasks..."});
		
		sandbox.ajax.request({method:"POST", url: "/reassignBulkTasksFromReport", endpoint:"/reassignBulkTasksFromReport", data: data, callBack: bulkReassignTasks_Callback});
		disableSelectedTasks();
	},
	
	bulkReassignTasks_Callback = function(resultObject){
		
		//removeSelectedTasksFromTableAndCache();
		sandbox.alert.message({text:"Tasks re-assigned successfully.", time: 3000});
		sandbox.alert.hideMessage();

		var taskID, mapOfDealInfo = {}, arrOfTaskIds = [], data = {},
			tasks = resultObject["tasks"], oldTasksMap = {},
			_taskCacheMap = sandbox.cache.get("tasks");
		
		for(var i=0, l=tasks.length; i< l; i++){
			
			taskID = tasks[i].id;
			arrOfTaskIds.push(taskID);
			oldTasksMap[taskID] = _taskCacheMap[taskID];
		}
		
		if( sandbox.util.isEmptyObject( arrOfTaskIds ) || arrOfTaskIds.length < 1 ) {
			sandbox.alert.message({text:"Server Error. Please try again.",time:4000});
			return;
		}
		
		deleteTasksByID(arrOfTaskIds, false);
		
		data["type"] = "bulkReassign";
		data["tasks"] = tasks;
		data["page"] = "Tasks";
		data["oldTasksMap"] = oldTasksMap;
		sandbox.publish("bulkTask-operation-complete",data);

		sandbox.publish("update-analytics",{category:"Tasks-Bulk",action:"Reassign", label: sandbox.cache.get("loggedInUserEmail") + "-" + sandbox.cache.get("accountID")+"-"+arrOfTaskIds.length });		
	},
	
	bulkResolveTasks = function(map){

		var data = {};
		
		data["resolutioncomments"] = map.formData[0].value;
		data["tasks"] = map.arr;
		data["userName"] = sandbox.cache.get("loggedInUserName"); 
		data["userid"] = sandbox.cache.get("loggedInUserID");
		
		sandbox.alert.message({text:"Resolving selected tasks..."});
		
		url = "/resolveBulkTasks?apikey="+sandbox.cache.get("accountID");
		sandbox.ajax.request({method:"PUT", url: url, endpoint:"/resolveBulkTasks", data: data, callBack: bulkResolveTasks_Callback});
		disableSelectedTasks();
	},
	
	bulkResolveTasks_Callback = function(map){
		
		//removeSelectedTasksFromTableAndCache();
		sandbox.alert.message({text:"Tasks resolved successfully.", time: 3000});
		
		var deals = map.deal, dealsArray = [], taskIDs = map.ids,
			accountsCache = sandbox.cache.get("accounts"),
			contactsCache = sandbox.cache.get("contacts"),
			leadsCache = sandbox.cache.get("leads"), data = {},
			linkedContacts, accountObj, index, accounts = [], contactObj,
			tasks = map.tasks;
		
		deleteTasksByID(taskIDs, false);
		if(!!map["childtask"])
			deleteTasksByID(map.childtask, false);
		
		dissociateTasksAfterResolveOrDelete(deals, tasks);

		data["type"] = "bulkResolve";
		data["tasks"] = tasks;
		data["page"] = "Tasks";
		data["history"] = map.history;
		sandbox.publish("bulkTask-operation-complete",data);

		sandbox.publish("update-analytics",{category:"Tasks-Bulk",action:"Complete", label: sandbox.cache.get("loggedInUserEmail") + "-" + sandbox.cache.get("accountID")+"-"+taskIDs.length });
	},
	
	dissociateTasksAfterResolveOrDelete = function(mapOfDeals, tasks){
		
		var dealsArray = [],
			accountsCache = sandbox.cache.get("accounts"),
			contactsCache = sandbox.cache.get("contacts"),
			leadsCache = sandbox.cache.get("leads"),
			linkedContacts, accountObj, index, accounts = [], contactObj;

		if(!sandbox.util.isEmptyObject(mapOfDeals)){
			
			sandbox.dom.each(mapOfDeals, function(dealID, deal){
				dealsArray.push(deal);
			});
			sandbox.publish("deals-updated",{deals:dealsArray});
		}
		
		tasks.map(function(task){
			
			if(!!task.linkedAccount && accountsCache.hasOwnProperty(task.linkedAccount)){
				accountObj = accountsCache[task.linkedAccount];
				index = accountObj.linkedTasks.indexOf(task.id);
				if(index != -1)
					accountObj.linkedTasks.splice(index,1);
				accounts.push(accountObj);
			}
			
			linkedContacts = task.linkedContacts;
			
			if(!sandbox.util.isEmptyObject(linkedContacts)){
				
				linkedContacts.map(function(contactID){
					
					if(contactsCache.hasOwnProperty(contactID)){
						contactObj = contactsCache[contactID];
						index = contactObj.linkedTasks.indexOf(task.id);
						if(index != -1)
							contactObj.linkedTasks.splice(index, 1);
						contactsCache[contactID] =contactObj;
					}
					else if(leadsCache.hasOwnProperty(contactID)){
						contactObj = leadsCache[contactID];
						index = contactObj.linkedTasks.indexOf(task.id);
						if(index != -1)
							contactObj.linkedTasks.splice(index, 1);
						leadsCache[contactID] =contactObj;
					}
				});
				
			}
		});
		
		if(!sandbox.util.isEmptyObject(accounts))
			sandbox.publish("accounts-updated",{accounts: accounts});
		
	},
	
	/*removeSelectedTasksFromTableAndCache=function(){
		
		var rows = sandbox.dom(_tableTag+" td.checklist input:checked").parents("tr"),
			className, tasks = [];
	
		sandbox.dom.each(rows, function(index, tag){
			className = tag.className.split(" ")[0];
			className = className.substr(className.indexOf("_")+1);
			tasks.push(_taskCacheMap[className]);
		});
	
		sandbox.tables.removeRows(_tableID, rows);
		removeTasksFromCache(tasks);
	},*/
	
	//list of tags populated in alphabetical order in tag filter SELECT tag
	populateTagsList = function(tagsCache){
		
		var html, arr = sandbox.util.sortObjects(tagsCache,"name");
		
		html='<option value="">None</option>';
		arr.map(function(tag){
			html+='<option value="'+tag.id+'">'+tag.name+'</option>';
		});
		sandbox.dom("#tasks select.filtertag_list").html(html).selectpicker("refresh");
	},
	
	populateTaskTypes = function(typesMap){
		
		var html='<option value="">None</option>', 
			rows, rowIndex, type,
			allTaskTypes = sandbox.cache.get("tasktype");

		sandbox.dom.each(typesMap, function(key, type){
			html+='<option value="'+key+'">'+type.type+'</option>';
		});
		sandbox.dom("#tasks select.filtertype_list").html(html).selectpicker("refresh");
	},
	
	//Updates the names of Task Owners in "Added By" column after fetching them from server.
	populateTaskOwnerNames = function(map){

		var cells = sandbox.tables.getCells(_tableID, ".ownerNameNotFetched"),
			ownerID, row, rowIndex, user, tdTag,
			users = !!map.users?map.users:{};
		
		if(cells.length < 1)
			return;
		
		sandbox.dom.each(cells, function(i, cell){
			
			rowIndex = cell.row;
			row = sandbox.tables.getHTMLRow(_tableID, rowIndex);
			tdTag = sandbox.dom(row).find("td.ownerNameNotFetched");
			ownerID = tdTag.data("ownerid");
			user = !!users[ownerID]? users[ownerID] : sandbox.cache.getUser(ownerID);
			
			if(!user){
				sandbox.tables.updateCell(_tableID, {col: _addedByNameCol, row: rowIndex, value: "<span>Unknown</span>"});
			}
			else{
				sandbox.tables.updateCell(_tableID, {col: _addedByNameCol, row: rowIndex, value: "<span>"+user.name+"</span>"});
				tdTag.removeClass("ownerNameNotFetched");
			}
		});
	},
	
	//Updates tasks in cache with updated Task objects sent to this function. Also adds in Task list if necessary.
	//Tasks are updated by first removing them from cache and Task listing, and then adding the new Task objects in both places.
	//If the objects are supposed to be removed, they will be removed from cache and Task listing as well.
	updateTasksInCache = function(data){
		
		var map = {}, rows = [], row, 
			isRemoveOp = !!data.op && data.op == "remove";
		
		sandbox.dom.each(data.tasks, function(index, task){
			
			if(_isTableInitialized && !!(row = sandbox.tables.getHTMLRow(_tableID, ".tasklist_"+task.id)))
				rows.push(row);
			
			map[task.id] = task;
			if(isRemoveOp)
				delete _taskCacheMap[task.id];
		});
		
		sandbox.tables.removeRows(_tableID, rows, false);
		if(!isRemoveOp)
			appendRows(map);
	},
	
	deleteTasksByID = function(listOfTaskIds, isFullDraw){
		
		if(sandbox.util.isEmptyObject(listOfTaskIds))
			return;
		
		var loggedInUserID = sandbox.cache.get("loggedInUserID"), isStatsUpdateNeeded=false, task, rows=[], row;
		
		sandbox.dom.each(listOfTaskIds, function(index, value){
			
			task = _taskCacheMap[value];
			if(!task)
				return true;

			if(!!(row = sandbox.tables.getHTMLRow(_tableID, ".tasklist_"+value)))
				rows.push(row);
			
			if(!isStatsUpdateNeeded && loggedInUserID == task.assigneeID && task.open)
				isStatsUpdateNeeded = true;
			
			delete _taskCacheMap[value];
		});
		
		if(isFullDraw == undefined)
			isFullDraw = true;
		
		if(rows.length > 0){
			isStatsUpdateNeeded = true;
			sandbox.tables.removeRows(_tableID, rows, isFullDraw);
		}
		
		sandbox.cache.update({tasks : _taskCacheMap});
		if(isStatsUpdateNeeded)
			updateStats();		
	},
	
	pagingButtonsToggle = function(map){
		
		var _prevPageLi = sandbox.dom("section#tasks ul.pagination li:nth-child(1)"),
			_nextPageLi = sandbox.dom("section#tasks ul.pagination li:nth-child(2)");
		
		if(map.start < 2)
			_prevPageLi.addClass("hide");
		else
			_prevPageLi.removeClass("hide");
		
		if(map.end == map.total)
			_nextPageLi.addClass("hide");
		else
			_nextPageLi.removeClass("hide");
	},
	
	updateUnreadTasksInCache = function(map) {
		
		if(sandbox.util.isEmptyObject(map))
			return;
		
		var taskTypes = sandbox.cache.get("tasktype"),
			tagsCache = sandbox.cache.get("tags");
		
		sandbox.dom.each(map, function(key, task){
			_taskCacheMap[key] = prepareTaskForInsertion(task, taskTypes, tagsCache);
		});
		
		//_taskCacheMap = sandbox.dom.extend({}, _taskCacheMap, map);
		sandbox.cache.update({tasks:_taskCacheMap});
	};
	
	return {
		
		init : function() {
			
			_self = this;
			
			if(sandbox.util.isEmptyObject(_taskCacheMap = sandbox.cache.get("tasks"))){
				sandbox.cache.update({"tasks":{}});
				_taskCacheMap = {};
			}
			
            sandbox.subscribe("display-tasks-info", _self.initTable);
			sandbox.subscribe("confirm-bulktask-operation", bulkTaskOperations);
			sandbox.subscribe("cancel-bulktask-operation", unselectTasks);
			sandbox.subscribe("new-task-created", appendRows);
			sandbox.subscribe("tags-cache-updated", populateTagsList);
			sandbox.subscribe("updated-tasktypes", function(typesMap){
				
				var hash,i,l,map;
				
				if(_isWaitingForTaskTypes){
					hash = (!!sandbox.url.entityID()) ? "#"+sandbox.url.page()+"/"+sandbox.url.entityID() : "#"+sandbox.url.page();
					l = _funcWaitingForTaskTypes.length;
					
		        	if(l != 0){
		        		for(i=0;i<l;i++){
		        			map = _funcWaitingForTaskTypes[i];
		        			if(!!map.hash && hash != map.hash)
		        				continue;
		        			map.func.apply(map.thisObj, map.args);
		        			_funcWaitingForTaskTypes.splice(i,1);
		        			i--;l--;
		        		}
		        	}
		        	_isWaitingForTaskTypes = false;
				}

				populateTaskTypes(typesMap);
			});
			sandbox.subscribe("tasksListOwners-users-fetched", populateTaskOwnerNames);
			sandbox.subscribe("task-updated", function(data){

				sandbox.tables.removeRowsBySelector(_tableID, ".tasklist_"+data.id, false);
				removeTasksFromCache([data.obj]);
				if(data.hasOwnProperty("op") && data.op == "remove")
					return;
				var map = {};
				map[data.id] = data.obj;
				appendRows(map);
			});
			
			sandbox.subscribe("tasks-updated", updateTasksInCache);
			sandbox.subscribe("tasks-table-paging-event", pagingButtonsToggle);
			sandbox.subscribe("update-unread-tasks-in-cache", updateUnreadTasksInCache);
			
			sandbox.dom("#tasks .showfilter").on("click",function(e){
				
				var el = sandbox.dom("section#tasks aside");
				el.hasClass("active") ? el.removeClass("active") : el.addClass("active");  
		    });
		    
			sandbox.dom("#tasks").on("click",function(e){
				
				if(!sandbox.dom(e.target).hasClass('showfilter') &&  !sandbox.dom(e.target).hasClass("icon-cog") && sandbox.dom("#tasks").find(".filteraside").hasClass('active') && !(sandbox.dom(e.target).parents('aside.filteraside').length > 0) && !sandbox.dom(e.target).hasClass('filteraside'))
					sandbox.dom('#tasks aside .close').trigger('click');
			});
			sandbox.dom("#tasks aside .close").on("click",function(){
				sandbox.dom("section#tasks aside").removeClass("active");
		    });
		    
		    $('.filteredlist .bootstrap-select input.form-control').addClass('input-sm');
			
			sandbox.subscribe("delete-tasks-from-cache-dataTable", deleteTasksByID);
			
			sandbox.dom("#tasks").find(".filtertimezone_list,.filtertype_list,.filterstatus_list,.filtertag_list,.filterdate_list").selectpicker({dropupAuto:false});
			
			sandbox.dom("#tasks #addtask").on("click", function(e){
				
				var data = {};
				data["text"] = "Add Task";
				data["form"] = "taskform";
				data["publish"] = "new-task-create";
				//data["evaluateTags"] = evaluateNewTaskTags;
				data["selectUser"] = sandbox.cache.get("loggedInUserID");
				data["taskGroupsAsUsers"] = true;
				data["excludeGroups"] = [sandbox.cache.get("salesGroupID")];
				data["popupGroupsList"] = true;
				data["popupContactMethodList"] = false;
				data["confirmButton"] = "Add";
				data["entityType"] = "task";
				data['isNotesNeeded'] = true;
				sandbox.publish("show-custom-popup", data);
			});
            
            sandbox.dom("section#tasks aside").on("change",".fromdatepicker, .todatepicker, select.filterdate_list",  setDateFilterValues);
            
            sandbox.dom("section#tasks aside").on("change","#taskListFilterToDate, select.filtertimezone_list, select.filtertag_list, select.filterstatus_list, select.filtertype_list, select.filterdate_list", setFilterLabels);

            sandbox.dom("#clearAllSearchFilters").on("click",clearAllSearchFilters);
            
            sandbox.dom(_tableTag + " th.checklist div.dropdown span").on("click", function(e){
            		sandbox.dom(e.target).parents("th").find("ul.dropdown-menu").toggleClass("show");
			});
            sandbox.dom(_tableTag + " tbody").on("change", "td.checklist input",function(e){
            	sandbox.publish("ckecked-unckecked-dropdown",{target : e.target,tableBody : _tableTag + " tbody",tableHead: _tableTag});            		
            });
            
			sandbox.dom(_tableTag + " th.checklist div.dropdown input[type=checkbox]").on("change", function(e){				
				sandbox.dom(_tableTag).find("td.checklist input").prop("checked", e.target.checked);
				if(!e.target.checked)
					sandbox.dom(_tableTag).find("th ul.dropdown-menu").removeClass("show");
				else
					sandbox.dom(_tableTag).find("th ul.dropdown-menu").addClass("show");
			});
			
			sandbox.dom("label.taskListFilterLabel span i").on("click", clearSearchFilter);
			
			sandbox.dom(_tableTag+" thead div ul.dropdown-menu li").on("click", bulkTaskOperations);
			
			sandbox.dom(_tableTag).on("click","td.tags_col",function(e){
				
				e.stopPropagation();
				
				target = sandbox.dom(e.currentTarget).find("a.view-detail-tag");
				
				if(target.find("i").hasClass("icon-caret-right")){
		 			target.find("i").removeClass("icon-caret-right");
		 			target.find("i").addClass("icon-caret-down");
		 			target.parent().find(".tasktaglist").removeClass("hide");
		 		}else{
		 			target.find("i").removeClass("icon-caret-down");
		 			target.find("i").addClass("icon-caret-right");
		 			target.parent().find(".tasktaglist").addClass("hide");
		 		}
		 	});
		},
		
		destroy : function() {
            sandbox.unsubscribe();
        },
        
        initTable : function(){
        	
        	sandbox.util.pageTitle(null, "Tasks");
        	
        	if(_isTableInitialized){
        	//if($.fn.DataTable.isDataTable("#tasklisting table")) {
                showTasksContent();
                return;
            }
        	
        	if(!sandbox.util.getFeatureAvailablityStatus("ticketingSystem")){
				sandbox.dom("#tasks #addtask").addClass("hide");
				sandbox.dom("section#tasks aside select.filterstatus_list option[value='onhold']").remove();
				sandbox.dom("section#tasks aside select.filterstatus_list option[value='replied']").remove();
				sandbox.dom("section#tasks aside select.filterstatus_list").selectpicker("refresh");
        	}
        	else if(!sandbox.cache.get("plainTaskEnabled"))
        		sandbox.dom("#tasks #addtask").addClass("hide");
        	
			sandbox.tables.initTable(_tableID,_tableTag,
			{
	       		"paging":   true,
	 	        "info":     false,
	 	        "searching": true,
	 	        "orderClasses":false,
	 	        /*"stateSave":false,
	 	        "autoWidth":false,
	 	       	"ordering":true,
	 	        "lengthChange":false,
	 	        "orderMulti":false,
	 	        "search":{
	 	        	"smart":false
	 	        },
	 	        "stripeClasses":[],*/
	 	        columnDefs: [
	            {
	   	        	targets: "disable_ordering",
	   	        	orderable: false
	   	        },
	            {
	   	        	targets: "disable_searching",
	   	        	searchable: false
	   	        },
	   	        {
	   	        	targets: "invisible_col",
	   	        	visible: false
	   	        },
	 	        {
	 	            targets:   "created_col",
	 	            orderData: [_createdDateLongCol]
	 	        },
	 	        {
	 	            targets:   "localtime_col",
	 	            orderData: [_localDateLongCol]
	 	        },
	 	        {
	 	            targets:   "due_col",
	 	            orderData: [_dueDateLongCol]
	 	        },
	 	        {
	 	            targets:   "taskname_col",
	 	            orderData: [_taskCommentsCol]
	 	        },
	 	        /*{
	 	            targets:   "addedby_col",
	 	            orderData : [_addedByNameCol]
	 	        },*/
	 	        {
	 	            targets:   "status_col",
	 	            type : 	   "string"
	 	        }],
	 	       "dom": _tableID,
	 	       "order": [[ _dueDateLongCol, "asc" ]],
	 	       "pageLength":10,
	 	       "pagingElements":
	 	        {
	 	    	   "previousPageBt":"section#tasks ul.pagination li a.previousPage",
	 	    	   "nextPageBt":"section#tasks ul.pagination li a.nextPage",
	 	    	   "changePageSelect": "section#tasks select.pagination_rowslist",
	 	    	   "startIndex" : "section#tasks .startIndex",
	 	    	   "endIndex" : "section#tasks .endIndex",
	 	    	   "totalRecords" : "section#tasks .totalRecords",
	 	    	   "pagingEventPublish":"tasks-table-paging-event"
	 	        },
	 	        "rowClick":{
	 	        	"func": function(e){
	 	        		var el = sandbox.dom(e.target), hash;
	 	        		
						if (e.target.type == "checkbox" || e.target.tagName == "TH" || e.target.className.indexOf("dataTables_empty") != -1)
							return true;

					if(e.target.tagName != "TR"){
						
						if(sandbox.dom(e.target).parents("th.checklist").length > 0)
							return;
						
						if(sandbox.dom(e.target).parents("td.tags_col").length > 0)
							return;
						
						el = sandbox.dom(e.target).parents("tr.pointer");
					}
					hash = el.children("td.taskname_col").children("a").attr("href").split("/");
					sandbox.url.changeHash(hash[0].substr(1), hash[1]);
	 	        	}
	 	        },
	 	       "searchSettingsInfo": 
	 	        [
	 	         {
	 	        	"watchChange" : "section#tasks aside select.filterstatus_list",
	 	        	"watchEvent": "change",
	 	        	"type": "string",
	 	        	"columnIndex":_statusCol
	 	         },
	 	         {
	 	        	"watchChange" : "section#tasks aside select.filtertype_list",
	 	        	"watchEvent": "change",
	 	        	"type": "string",
	 	        	"columnIndex":_typeCol
		 	     },
		 	     {
		 	        	"watchChange" : "section#tasks aside select.filtertimezone_list",
		 	        	"watchEvent": "change",
		 	        	"type": "regex",
		 	        	"columnIndex":_timeZoneCol
			 	 },
	 	         {
	 	        	"minEl" : "#taskListFilterFromDate",
	 	        	"maxEl": "#taskListFilterToDate",
	 	        	"watchEvent": "change",
	 	        	"type" : "rangeSearch",
		 	        "columnIndex":_dueDateLongCol
		 	     },
		 	     {
		 	    	//"searchInputTag" : "section#tasks aside select.filtertag_list",
		 	    	"watchChange" : "section#tasks aside select.filtertag_list",
	 	        	"watchEvent": "change",
	 	        	//"type" : "searchList",
	 	        	"type":"string",
		 	        "columnIndex":_tagsListStringCol
			 	 }/*,
		 	     {
	 	        	"watchChange" : "#clearAllSearchFilters",
	 	        	"watchEvent": "click",
	 	        	"type" : "clearAllSearchFilters"
		 	     }*/
	 	        ],
	 	        "tableID":_tableID
            });
		
			_isTableInitialized = true;
			getFirstSetOfTasks();
			getAllTasksOfUser();
		}
	};
});

DSCRM.Core.registerModule("tasksSubTab",["ajax","cache","util","alert","url"] ,function(sandbox) {
	
	var _p = {
			
			_entityObj:null, 
			_entityType:null, 
			_currentTaskMap: {},
			_cursor:null,
			_template: dscrm.templates.tasks.taskListSubtab, 
			_typeFilterTemplate: dscrm.templates.tasks.taskSubTabTypeFilter,
			_loadingPlaceholderForTasksSubTabTemplate : dscrm.templates.tasks.loadingPlaceholderForTasksSubTab,
			_mailInformation : null,
	        _subTaskID : null,
	        _isWaitingForTaskTypes: true,
	        _isWaitingForTags: true,
	        _deferredFuncCalls: [],
	        
	showAddTaskPopup: function(e, task, settings){
		
		var data = {}, linkedContacts, contactMethodMap = {}, contact, cmMap, list = [], contactName, cmTypes, index,
			cmTypesGlobal = ["email","phone"], contactMaps = [], tagsCache = {}, tags = [],
			contactsCache;
		
		_p._entityType = sandbox.url.page();
 
		_p._entityObj = sandbox.cache.get(_p._entityType+"s")[sandbox.url.entityID()];
		
		//to prevent enabling add task before the current page entity is in cache
		if(!_p._entityObj || _p._isWaitingForTaskTypes)
			return;
		
		if(_p._entityType == "contact"){
			linkedContacts = [_p._entityObj.id];
			contactsCache = sandbox.cache.get("contacts");
		}
		else if(_p._entityType == "lead"){
			contactsCache = sandbox.cache.get("leads");
			linkedContacts = [_p._entityObj.id];
		}
		else{
			linkedContacts = _p._entityObj.linkedContacts;
			contactsCache = sandbox.cache.get("contacts");
		}
		
		linkedContacts = !!linkedContacts?linkedContacts: [];

		sandbox.dom.each(linkedContacts, function(index, contactID){
			
			contact = contactsCache[contactID];
			
			if(sandbox.util.isEmptyObject(contact))
				return true;

			cmTypes = ["email","phone"];
			
			if(contact.category === 'person') {
				contactName = sandbox.util.getPersonName(contact.firstName, contact.lastName);
			} else {
				contactName = contact.fullName;
			}
						
			contactName = !!contactName? contactName : "";
			
			contactMaps.push({contactID: contactID, name : contactName, cmString : "", cmValue : ""});

			var linkedCM = contact.linkedContactMethods;
			if(!sandbox.util.isEmptyObject(linkedCM)) {
				
				sandbox.dom.each(linkedCM, function(index, cm) {
					
					if(!!cm.value && !!cm.type && cmTypesGlobal.indexOf(cm.type.toLowerCase()) != -1){
						
						list = contactMethodMap[cm.type.toLowerCase()];
						list = !!list? list : [];
						list.push({ contactID: contactID, name : contactName, cmString : contactName+" ("+cm.value+")", cmValue : cm.value});
						contactMethodMap[cm.type.toLowerCase()] = list;
						
						index = cmTypes.indexOf(cm.type.toLowerCase());
						cmTypes.splice(index, 1);
					}
				});
			}
			
			if(cmTypes.length > 0){
				cmTypes.map(function(cmType){
					list = contactMethodMap[cmType];
					list = !!list? list : [];
					list.push({contactID : contactID, name : contactName, cmString: contactName, cmValue : ""});
					contactMethodMap[cmType] = list;
				});
			}
		});
		
		if(!!contactMethodMap["phone"]){
			contactMethodMap["call"] = contactMethodMap["phone"];
			delete contactMethodMap["phone"];
		}
		
		if(!!task && !task.hasOwnProperty("isCreateNewTicketFromDropdown")){

			data["operation"] = "update";
			data["notes"] = !!task.notes? task.notes : "";
			data["comments"] = sandbox.util.removeHTMLTags(task.comments);
			data["taskType"] = task.type;
			data["assigneeID"] = !!task.assigneeID? task.assigneeID : "";
			data["selectUser"] = !!task.assigneeID? task.assigneeID : task.department;
			
			data["dueDateString"] = sandbox.util.formatDate(new Date(task.dueDate), "MM/dd/yyyy hh:mm a");
			data["linkedContacts"] = task.linkedContacts;
			data["taskID"] = task.id;
			data["text"] = "Update the task";
			data["task"] = task;
			data["publish"] = "task-update-popup";
			data["confirmButton"] = "Update";
			data["taskTypesType"] = "basic"; //since update task popup is only for basic types
			data["popupGroupsList"] = false;
			
			if(!sandbox.util.isEmptyObject(task.linkedTags)){
				tagsCache = sandbox.cache.get("tags");
				task.linkedTags.map(function(tagID){
					if(tagsCache.hasOwnProperty(tagID))
						tags.push(tagsCache[tagID].name);
				});
				data["tags"] = tags;
			}
		}
		else{
			
			data["taskTypesType"] = (_p._entityType == "deal" || _p._entityType == "contact" || _p._entityType == "lead")? "basic":"all";
			data["popupGroupsList"] = _p._entityType == "account";
			
			if(!!settings && settings.hasOwnProperty("popupTitle")){
				data["text"] = settings.popupTitle;
				if(settings.popupTitle == "Schedule Followup Task"){
					data["taskTypesType"] = "basic";
					data["popupGroupsList"] = false;
				}
			}
			else
				data["text"] = "Add Task";
			
			data["publish"] = "new-task-create";
			data["selectUser"] = sandbox.cache.get("loggedInUserID");
			data["confirmButton"] = "Add";
			data["entityType"] = "task";
		}
		data["form"] = "taskform";
		//data["evaluateTags"] = evaluateNewTaskTags;
		
		data['isNotesNeeded'] = true;
		
		data["popupContactMethodList"] = true;
		data["contactMethodMap"] = contactMethodMap;
		data["contactMaps"] = contactMaps;
		data["taskGroupsAsUsers"] = true;
		data["excludeGroups"] = [sandbox.cache.get("salesGroupID")];
		
		if(!!task && task.hasOwnProperty("isCreateNewTicketFromDropdown")){
			data["comments"] = sandbox.util.removeHTMLTags(task.comments);
			data["notes"] = !!task.notes? task.notes : "";
			data["isCreateNewTicketFromDropdown"] = true;
			data["type"] = task.type;
			data["popupGroupsList"] = true;
			data["popupContactMethodList"] = true;
			data["contactMethodMap"] = contactMethodMap;
			data["contactMaps"] = contactMaps;
			
			if(task.hasOwnProperty("historyOwnerID"))
				data["historyOwnerID"] = task.historyOwnerID;
			
			if(task.hasOwnProperty("historyOwnerName"))
				data["historyOwnerName"] = task.historyOwnerName;
			
			if(task.hasOwnProperty("linkedDocuments") && !sandbox.util.isEmptyObject(task.linkedDocuments))
				data["linkedDocuments"] = task.linkedDocuments;
		}
		
		data["isDraggableRequired"] = true;
		
		sandbox.publish("show-custom-popup", data);
	},
	
	prepareTasksForInsertion: function(tasks){

		var user, fetchUsers = [], data = {}, taskMap = {}, startIndex, lastIndex,
		mailIDForHighlight, htmlForMailIDHighlight , taskComments, phoneNo, toContactID, notesElement,
			tagsCache = sandbox.cache.get("tags"),
			isTicketingSystemEnabled = sandbox.util.getFeatureAvailablityStatus("ticketingSystem"),
			isAllUsersFetched = sandbox.cache.get("isAllUsersFetched");
		
		for(var i=0,l=tasks.length, task;i<l;i++){
			
			task= tasks[i];

			/*if(task.status == "completed" || task.status == "deleted"){
				
				if(["Call","Email","To-do"].indexOf(task["taskTypeName"]) != -1 || _entityType != "account"){
					tasks.splice(i,1);
					l--;i--;
					continue;
				}
			}*/
			
			if(task.taskTypeName == 'email' || task.taskTypeName == "Email")
			{
				taskComments = task.tooltipComments = task.comments;
		 		startIndex = taskComments.indexOf('(');
				lastIndex = taskComments.lastIndexOf(')');
				mailIDForHighlight = taskComments.substring((startIndex+1),lastIndex);
				mailIDForHighlight = $.trim(mailIDForHighlight);
				htmlForMailIDHighlight = '<span class="link" data-subtask-type="email">'+mailIDForHighlight+'</span>';
				task.comments = taskComments.replace(mailIDForHighlight,htmlForMailIDHighlight);							
			}
			else if((task.taskTypeName === 'call' || task.taskTypeName === 'Call') && sandbox.util.getFeatureAvailablityStatus('dialOut')){
				
				taskComments = task.tooltipComments = task.comments;		
		 		startIndex = taskComments.indexOf('(');
				lastIndex = taskComments.lastIndexOf(')');
				phoneNo = taskComments.substring((startIndex+1),lastIndex);
				phoneNo = $.trim(phoneNo);
				htmlForPhoneNoHighlight = '<span class= "link" data-subtask-type="call">'+phoneNo+'</span>';
				task.comments = taskComments.replace(phoneNo,htmlForPhoneNoHighlight);
				
			}
			else if(task.taskTypeName == 'sms' || task.taskTypeName == "Sms")
			{
				// @shv - to handle old SMS tasks
				if(task["comments"].indexOf("onclick") != -1) {
					toContactID = task["comments"].substring((task["comments"].indexOf("(")+1),task["comments"].indexOf(")"));
					toContactID = toContactID.split(",")[0].replace(/["']/g, "");
					taskComments = task["comments"].substring(0,task["comments"].indexOf("<span"));
					taskComments = taskComments + task["comments"].substring(task["comments"].indexOf(">")+1,task["comments"].indexOf("</span>"));
				}
				// @shv - to handle new SMS tasks
				else if(task["comments"].indexOf("span") != -1){
					taskComments = task["comments"].split('<span class="hide">')[0];
					toContactID = task["comments"].split('<span class="hide">')[1].split("</span>")[0];
				}
				// @shv - for existing staging SMS tasks(as of Dec5 2016 - will not be available in live)
				else {
					taskComments = task["comments"];
					toContactID = "";
				}
				
				task.tooltipComments = taskComments;

		 		startIndex = taskComments.indexOf('(');
				lastIndex = taskComments.lastIndexOf(')');
				mailIDForHighlight = taskComments.substring((startIndex+1),lastIndex);
				mailIDForHighlight = $.trim(mailIDForHighlight);
				htmlForMailIDHighlight = '<span class="link" data-subtask-type="sms" data-contact-id="' + toContactID +'">'+mailIDForHighlight+'</span>';
				task.comments = taskComments.replace(mailIDForHighlight,htmlForMailIDHighlight);				
			}
			else
				task.tooltipComments = task.comments;

			taskMap[task.id] = task;
			
			task["createdDateString"] = sandbox.util.formatDate(new Date(task.createdDate), "d NNN y");
			task["lastUpdatedDateString"] = sandbox.util.formatDate(new Date(task.lastUpdatedDate), "d NNN y");
			task["dueDateString"] = sandbox.util.formatDate(new Date(task.dueDate), "h:mm a d NNN y");
			
			task["userNameNotFetched"] = "";
			
			if(!task.assigneeID && isTicketingSystemEnabled)
				user = sandbox.cache.getUser(task.department);
			else if(!task.assigneeID)
				user = {name : "Unassigned"};
			else{
				user = sandbox.cache.getUser(task.assigneeID);
				if(!user){
					if(!isAllUsersFetched){
						fetchUsers.push(task.assigneeID);
						task["assigneeName"] = "Loading...";
						task["userNameNotFetched"] = "userNameNotFetched";
					}
					else
						user = {name: "Unknown"};
				}
			}
			
			if(!!user)
				task["assigneeName"] = user.name;
			
			if(!!task.linkedTags){
				
				task["tagNames"] = "";
				
				task.linkedTags.map(function(tagID){
					if(tagsCache.hasOwnProperty(tagID))
						task["tagNames"]+=","+tagsCache[tagID].name;
				});
				task["tagNames"] = !!task["tagNames"]? task["tagNames"] : null;
				
			}
			
			task["deletedClass"] = "deleted"==task["status"]? "deleted_task":"";
			
			notesElement = document.createElement('div');
			notesElement.setAttribute("id", "dynamic-task-notes");
			notesElement.style.visibility= "hidden";
			notesElement.setAttribute("class", "dtltask_summary");
			notesElement.innerHTML = task.notes;
			document.body.appendChild(notesElement);
			
			if(document.getElementById('dynamic-task-notes').offsetHeight > 150)
			task.isViewDetailsNeeded = true;
			
			sandbox.dom("#dynamic-task-notes").remove();
			
			_p._currentTaskMap[task.id] = task;
		}
		
		/*if(tasks.length > 0) {
			sandbox.dom("#"+_entityType+"tasks ul.dtltask_list").append(_template({tasks : tasks, entityType : _entityType}));
			sandbox.publish("new-task-created", _currentTaskMap);
		}*/
		
		if(fetchUsers.length > 0){
			data["parentDOMID"] = "tasksSubTab";
			data["selectedContactID"] = fetchUsers;
			data["currentObjID"] = _p._entityObj.id;
			sandbox.publish("users-selected-fetch", data);
		}
		
		return {tasks : tasks, taskMap : taskMap};
	},
	
	filterTasksForView : function(tasks){

		if(_p._entityType != "account")
			return tasks;
		
		var isAddTask, taskType, newList = [],
			taskTypes = sandbox.cache.get("tasktype"),
			typeSelected = sandbox.dom("select.taskSubTabTypeFilter").val(),
			statusSelected = sandbox.dom("select.taskSubTabStatusFilter").val(),
			isAllStatus = !statusSelected? true:false,
			isOpenOnly = statusSelected == "open"? true : false;

		tasks.map(function(task){

			taskType = taskTypes[task.type].type;
			isAddTask = true;
			
			if(!isAllStatus && isOpenOnly != task.open)
				isAddTask = false;
			if(!!typeSelected && typeSelected != taskType)
				isAddTask = false;
			
			if(isAddTask)
				newList.push(task);
		});

		return newList;
	},
	
	addTasks: function(data){
		
		var tasksListEl = sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list");
		
		sandbox.dom("li.dtltask_list_placeholder").remove();
		tasksListEl.append(_p._loadingPlaceholderForTasksSubTabTemplate);
		
		if(_p._isWaitingForTaskTypes || _p._isWaitingForTags ){
			var hashUrl = (!!sandbox.url.entityID()) ? "#"+sandbox.url.page()+"/"+sandbox.url.entityID() : "#"+sandbox.url.page();
			_p._deferredFuncCalls.push({func:_p.addTasks, args:[data],thisObj:this, hash: hashUrl});
			return;
		}
		
		var tasks = _p.sortTasksBeforeInsertion(data.tasks),
			map = _p.prepareTasksForInsertion(tasks),
			taskMap = map.taskMap, tasksToInsert;
		
		tasks = map.tasks;

		if(tasks.length > 0) {
			
			sandbox.dom("li.dtltask_list_placeholder").remove();
			
			if(data.isMakeEmpty)
				tasksListEl.empty();

			tasksToInsert = tasks;
			if(data.isNew)//for now, the below function is only useful when new task added in account page
				tasksToInsert = _p.filterTasksForView(tasks);
			
			
			if(data.isAppend) 
				tasksListEl.append(_p._template({tasks : tasksToInsert, entityType : _p._entityType}));
			else
				tasksListEl.prepend(_p._template({tasks : tasksToInsert, entityType : _p._entityType}));
			
			if(data.isNew){
				sandbox.publish("new-task-created", taskMap);
				if(tasks.length == 1 && ["Call","Email","To-do","Sms"].indexOf(tasks[0].taskTypeName) == -1)
					sandbox.url.changeHash("task", tasks[0].id);
			}
		}
		else
			sandbox.dom("li.dtltask_list_placeholder").remove();
		
		if(!_p._cursor)
			sandbox.dom("#tasksSubTabLoadMore").addClass("hide");
		else
			sandbox.dom("#tasksSubTabLoadMore").removeClass("hide");
		
		sandbox.dom('.dtltask_taghold').tokenfield();
		sandbox.dom('.dtltask_taghold').tokenfield('disable');
		sandbox.dom('[data-tooltip="tooltip"]').tooltip();
	},
	
	updateTask: function(task){
		
		task["taskTypeName"] = sandbox.cache.get("tasktype")[task.type].type;
		
		var tasks = _p.prepareTasksForInsertion([task]).tasks;
		
		if(tasks.length > 0) {
			sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list li.tasksubtab_"+task.id).replaceWith(_p._template({tasks : tasks, entityType : _p._entityType}));
			sandbox.dom(".dtltask_taghold").tokenfield();
			sandbox.dom('.dtltask_taghold').tokenfield('disable');
			sandbox.publish("task-updated", {id: task.id, obj: task});
		}
		else
			sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list li.tasksubtab_"+task.id).remove();

		sandbox.dom('[data-tooltip="tooltip"]').tooltip();
	},
	
	getTasks: function(data){
			
		var departmentID = sandbox.cache.get("selectedDepartmentID"),
			typesCache={};

		if(data.hasOwnProperty("success")){
			
			//sandbox.alert.spinner(false);
			sandbox.alert.hideMessage();
			
			if(data.entityID != _p._entityObj.id)
				return;
			
			_p.addTasks({tasks : data.task, isNew : false, isMakeEmpty: true});
			sandbox.publish("tasks-updated",{tasks: data.task});
			return;
		}
		
		_p._entityObj = data.obj; _p._entityType = data.type; _p._currentTaskMap = {}; _p._cursor = null;
		
		sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list").empty();
		sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list").append(_p._loadingPlaceholderForTasksSubTabTemplate);
		/*if(_entityType != "account" && _entityType != "contact")
			sandbox.dom("#"+_entityType+"tasks select.taskSubTabTypeFilter").addClass("hide").selectpicker("refresh");
		else{

			sandbox.dom.each(sandbox.cache.get("tasktype"), function(key, value){
				if(value.deleted || !value.linkedDepartments || value.linkedDepartments.indexOf(departmentID) == -1)
					return true;
				typesCache[key] = value;
			});
			
			sandbox.dom("#"+_entityType+"tasks select.taskSubTabTypeFilter").html(_typeFilterTemplate({taskTypes : typesCache}));
			sandbox.dom("#"+_entityType+"tasks select.taskSubTabTypeFilter").removeClass("hide").selectpicker("refresh");
		}*/

		if(sandbox.util.isEmptyObject(_p._entityObj.linkedTasks)) {
			sandbox.dom("li.dtltask_list_placeholder").remove();
			return;
		}
		if(!!data.tasks){
			_p.addTasks({tasks: data.tasks, isNew : false, isMakeEmpty: true});
			sandbox.publish("tasks-updated",{tasks: data.tasks});
			return;
		}
		
		var map = {};
	//	map["entityType"] = "linkedDeal";
		map["entityType"] = "linked" + _p._entityType.charAt(0).toUpperCase() + _p._entityType.slice(1);
		map["entityID"] = ""+_p._entityObj.id;
		
		sandbox.ajax.request({method :"POST", url:"/getTasksForEntity", endpoint:"/getTasksForEntity", data : map, callBack : _p.getTasks});
		//sandbox.alert.spinner(true);
		sandbox.alert.message({text : "Loading..."});
	},
	
	sortTasksBeforeInsertion: function(tasks){
		
		if(sandbox.util.isEmptyObject(tasks))
			return tasks;
		
		var listPendingTasks = [], listRepliedTasks=[],listOnholdTasks=[],listDoneTasks=[],listDeletedTasks=[], lists, allTasks=[],
			taskTypes = sandbox.cache.get("tasktype"),
			basicTypes = ["Call", "Email","To-do","Sms"],
			isAccountPage = sandbox.url.page() == "account";
		
		tasks.map(function(taskObj){
			
			taskObj["taskTypeName"] = taskTypes[taskObj.type].type;
			
			if("pending"==taskObj["status"] || "unread"==taskObj["status"])
				listPendingTasks.push(taskObj);
			else if("replied"==taskObj["status"])
				listRepliedTasks.push(taskObj);
			else if("onhold"==taskObj["status"])
				listOnholdTasks.push(taskObj);
			else if(basicTypes.indexOf(taskObj["taskTypeName"]) == -1 && isAccountPage){
				if("completed"==taskObj["status"])
					listDoneTasks.push(taskObj);
				else if("deleted"==taskObj["status"])
					listDeletedTasks.push(taskObj);
			}
		});
		
		lists = [listPendingTasks,listRepliedTasks,listOnholdTasks,listDoneTasks,listDeletedTasks];
		lists.map(function(list){
			allTasks = allTasks.concat(list);
		});
		return allTasks;
	},
	
	setAssigneeNames: function(data){
		
		if(data.currentObjID != _p._entityObj.id)
			return;

		var el, taskID, elList;
		
		sandbox.dom.each(data.users, function(id, contact){
			
			el = sandbox.dom(".taskSubTabAssignee_"+id);
			
			if(el.length == 0)
				return true;
			
			el = sandbox.dom(".taskSubTabAssignee_"+id).html(contact.name).removeClass("userNameNotFetched");
			taskID = el.parents("li").attr("taskid");
			_p._currentTaskMap[taskID].assigneeName = contact.name;
		});
		
		elList = sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list li span.userNameNotFetched");
		
		sandbox.dom.each(elList, function(index, tag){
			sandbox.dom(tag).html("Unknown").removeClass("userNameNotFetched");
		});
	},
	
	openTask: function(e){
		
		//e.stopPropagation();
		if(sandbox.dom(e.target).hasClass('dtltask_moreBtn') || sandbox.dom(e.target).hasClass('dtltask_list_placeholder') || sandbox.dom(e.target).hasClass('loadingPlaceholder'))
			return;

		var taskid = sandbox.dom(e.currentTarget).attr("taskid");
		var task = _p._currentTaskMap[taskid];
		
		if(task.taskTypeName.toLowerCase() == "sms")
			return;
		else if(["Call","Email","To-do"].indexOf(task.taskTypeName) != -1)
			_p.showAddTaskPopup(null,task,null);
		else if(e.metaKey || e.ctrlKey){
			sandbox.url.openHashInNewTab("task", task.id);
		}else
			sandbox.url.changeHash("task",task.id);
	},
	
	openTaskPopup : function(e){
		
		e.stopPropagation();
		
		if(sandbox.dom(e.target).hasClass('dtltask_moreBtn') || sandbox.dom(e.target).hasClass('dtltask_list_placeholder'))
			return;
		
		var taskid = sandbox.dom(e.currentTarget).parents("li").attr("taskid");
		var task = _p._currentTaskMap[taskid];
		
		if(task.taskTypeName.toLowerCase() == "sms")
			return;
		else if(["Call","Email","To-do"].indexOf(task.taskTypeName) != -1)
			_p.showAddTaskPopup(null,task,null);
		else if(e.metaKey || e.ctrlKey)
			sandbox.url.openHashInNewTab("task", task.id);
		else
			sandbox.url.changeHash("task",task.id);
		
	},
	
	showResolveTaskPopup: function(e){
		
		e.stopPropagation();
		e.preventDefault();
		
		var data = {};
		
		var taskid = sandbox.dom(e.currentTarget).parents("li").attr("taskid"),
			task = _p._currentTaskMap[taskid];
	
		if(["Call","Email","To-do","Sms"].indexOf(task.taskTypeName) == -1){
			if(e.metaKey || e.ctrlKey)
				sandbox.url.openHashInNewTab("task", task.id);
			else
				sandbox.url.changeHash("task",task.id);
			
			return;
		}
		
		var actionTypeMap = {"Call" : ["Contacted", "Not Contacted"], "Email":["Sent"], "To-do":["Completed"]}; 
		
		data["actionSelectOptions"] =actionTypeMap[task.taskTypeName];
		data["form"] = "taskresolveform";
		data["publish"] = "task-subtab-resolve";
		//data["cancel"] = "task-subtab-resolve-cancel";
		data["text"] = "1 task marked for completion";
		data["confirmButton"] = "Resolve";
		data["task"] = task;		
		data["isDraggableRequired"] = true;
		sandbox.publish("show-custom-popup", data);
	},
	
	resolveTask: function(map){

		var data = {}, history = {}, formData = map.formData,
			action, resolutionComments, historyID, accountID,
			task = map.settings.task, metaDataForJS = {};
			
		formData.map(function(field){
			action = (field.name == "action")? field.value.toLowerCase():action;
			resolutionComments = (field.name == "resolutionComments")? field.value:resolutionComments;
		});
		
		history["AccountPIN"] = accountID = sandbox.cache.get("accountID");
		history["departmentID"] = sandbox.cache.get("selectedDepartmentID");
		data["entityType"] = history["entityType"] = _p._entityType;
		history["taskID"] = task.id;
		history["ownerID"] = history["peopleId"] = sandbox.cache.get("loggedInUserID");
		history["ownerName"] = sandbox.cache.get("loggedInUserName");
		
		if(!!task.linkedAccount)
			history["linkedAccounts"] = [task.linkedAccount];
		if(!!task.linkedContacts)
			history["linkedContacts"] = task.linkedContacts;
		if(!!task.linkedDeal)
			history["linkedDeals"] = [task.linkedDeal];
		
		switch(action){
		
			case "contacted" 	: historyID = "0af0f84d-676d-4b12-85a6-0a4178dde089"; break;
			
			case "not contacted": historyID = "9cad2b25-2fd2-41ab-aef2-dafb8c85894f"; break;
			
			case "completed"	: { 
									historyID = "76229b91-2197-4f76-b10c-47ca1b6e8e44";
									action = "complete";
							  	  } break;
							  	  
			case "sent"			: historyID = "03cecc49-b91f-4b12-945a-3023f70d3e0d"; break;
		}
		
		history["type"] = action;
		history["typeID"] = historyID;
		history["taskComments"] = task.comments;
		if(!!resolutionComments)
			history["resolutionComments"] = resolutionComments;

		data["history"] = history;
		
		metaDataForJS["entityType"] = _p._entityType;
		metaDataForJS["entityObj"] = _p._entityObj;
		
		sandbox.ajax.request({url:"/resolveTask/"+task.id+"?apikey="+accountID, endpoint:"/resolveTask", method: "PUT", callBack: _p.resolveTask_Callback, data : data, metaDataForJS: metaDataForJS});
		sandbox.alert.message({text:"Resolving task..."});
		sandbox.publish("hide-custom-popup");
	},
	
	resolveTask_Callback : function(map){
		
		var taskType = sandbox.cache.get("tasktype")[map.task.type].type.toLowerCase(),
			entityType = map.metaDataForJS["entityType"],
			entityID = map.metaDataForJS["entityObj"].id;
		
		sandbox.alert.hideMessage();
		
		map.history['createdDate'] = new Date();
		
		sandbox.publish("task-updated", {id: map.task.id, obj: map.task});
		sandbox.publish("add-history",{ entityID : map.task.id , entityType : "task", history : map.history});
		//sandbox.publish("hide-custom-popup");
		_p.generateActivityLogForResolveOrDelete(map.task, "Resolved", entityType, entityID);
		
		if(sandbox.window.location.hash.indexOf(entityID) != -1){
			
			if(["call","email","to-do","sms"].indexOf(taskType) != -1)
				_p.showAddTaskPopup(null,null,{popupTitle:"Schedule Followup Task"});
			
			sandbox.dom("#"+entityType+"tasks ul.dtltask_list li.tasksubtab_"+map.task.id).remove();
			delete _p._currentTaskMap[map.task.id];
		}
	},
	
	resolveTaskForSentMail: function(data) {
		
		
		if(sandbox.util.isEmptyObject(data))
			return;
			
		_p._mailInformation = data.mailInformation;
		var taskID = _p._mailInformation.taskID;
		
		var taskInfoToServer = {}; 
		taskInfoToServer.entityType = _p._entityType;
		
		sandbox.ajax.request({url:"/resolveTask/"+_p._subTaskID+"?apikey="+sandbox.cache.get("accountID"), 
											method: "PUT", endpoint:"/resolveTask", callBack: _p.resolveTaskForSentMailCallBack, data : taskInfoToServer, metaDataForJS : data.mailInformation});
		sandbox.alert.message({text:"Resolving task..."});
	},

	getToCcAndBccDetailForHistory : function(data){	
		
		var mapData = data.mapData;
		var historyComments = data.historyComments;
		
		var historyData = '';
		var to = '', cc = '', bcc = '', from = '', subject = '';
		
		if(!!mapData['from']) {
			from = mapData['from'];
			from = from.replace(/</g,'(');
			from = from.replace(/>/g,')');		
			historyData = '<div><b>From : </b><span class="history_from">'+from+'</span></div>';
		}
		
		if(!!mapData['subject']) {
			subject = mapData['subject'];
			historyData = historyData+'<div><b>Subject : </b><span class="history_subject">'+subject+'</span></div>';
		}
		
		if(!!mapData['to']) {
			to = mapData['to'];
			to = to.replace(/</g,'(');
			to = to.replace(/>/g,')');		
			historyData = historyData+'<div><b>To : </b><span class="history_to">'+to+'</span></div>';
		}
		
		if(!!mapData['cc']) {
			cc = mapData['cc'];
			cc = cc.replace(/</g,'(');
			cc = cc.replace(/>/g,')');
			historyData = historyData+'<div><b>Cc : </b><span class="history_cc">'+cc+'</span></div>';
		}
		
		if(!!mapData['bcc']) {
			bcc = mapData['bcc'];
			bcc = bcc.replace(/</g,'(');
			bcc = bcc.replace(/>/g,')');
			historyData = historyData+'<div><b>Bcc : </b><span class="history_bcc">'+bcc+'</span></div>';
		}
		
		if(!!historyData)
			historyComments = historyData + historyComments;

		return historyComments;
		
	},
	
	resolveTaskForSentMailCallBack: function(response) {
		
		sandbox.alert.hideMessage();
		sandbox.alert.message({text :" Updating Comments for task..please wait...", type:"success"});

		var taskID = response.task.id;
		
		var scheduledDatInMillis, date, taskComments ;
		
		sandbox.publish("task-updated", {id: _p._subTaskID, obj: response.task});
		sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list li.tasksubtab_"+ taskID).remove();
		delete _p._currentTaskMap[taskID];
		
		var accountID = sandbox.cache.get("accountID");
		var historyComments  = "<b> Message : </b><br><br>" + _p._mailInformation.mailContents;
		var resolutionComments = _p._mailInformation.subject;
		
		var mapHistoryData = {}, emailAttachment = '',history={};
		
		mapHistoryData['subject'] = _p._mailInformation.subject;
		mapHistoryData['from'] = _p._mailInformation.from;
		mapHistoryData['to'] = _p._mailInformation.to;
		mapHistoryData['cc'] = _p._mailInformation.cc;
		mapHistoryData['bcc'] = _p._mailInformation.bcc;

		historyComments = _p.getToCcAndBccDetailForHistory({ mapData : mapHistoryData, historyComments :historyComments});			
		historyComments = "<div class='mailContents'>" + historyComments + "</div>";
		
		var listOfUploadedDocumentID = (!!_p._mailInformation.listOfUploadedDocumentID)?_p._mailInformation.listOfUploadedDocumentID:[];
				
		
		if(listOfUploadedDocumentID.length)
		{
		     for(var i = 0 ; i< listOfUploadedDocumentID.length; i++)
		    	 {
		    	 	var documentID = listOfUploadedDocumentID[i];
		    	 	var document = _p._mailInformation.documents[documentID];
		    	 	if(!!document)
						emailAttachment = emailAttachment + "<li data-document-id='"+documentID+"'  data-document-size='"+ document.size+"'  data-document-name='"+ document.name+"'> <label class=\"attachmentName\" style=\"text-decoration:underline; cursor: pointer\" onclick=\"downloadLinkedFile('"+ documentID + "')\"><strong style=\"color:#15c;\">"+document.name+"</strong><strong style=\"color:#777;\"> ("+Math.ceil((document.size)/1024)+"K) </strong></label></li>";
		    	 
		    	 }
		}
		
		if(emailAttachment != '')
		{
			emailAttachment = "<div class=\"outboundemail_attachment\"><p><b>" + listOfUploadedDocumentID.length + " Attachments</b></p><ul class=\"emailAttachment\">" + emailAttachment+"</ul></div>";
			historyComments = historyComments + emailAttachment;
		}
			
		    history.departmentID = sandbox.cache.get("selectedDepartmentID");
			history.historyComments = historyComments;
			history.type = 'sent';
			history.ownerID = sandbox.cache.get("loggedInUserID");
			history.ownerName = sandbox.cache.get("loggedInUserName");
			history.entityType = _p._mailInformation.entityType;
			
			if(_p._mailInformation.entityType == 'account')
			 history.linkedAccounts = [_p._mailInformation.entityID];
			else if(_p._mailInformation.entityType == 'deal')
				history.linkedDeals = [_p._mailInformation.entityID];
			else if(_p._mailInformation.entityType == 'contact' || _p._mailInformation.entityType == 'lead')
				history.linkedContacts = [_p._mailInformation.entityID];
			
			history.taskID  = _p._subTaskID;
			
			scheduledDatInMillis = response["task"]['dueDate'];
			
			taskComments = response["task"]["comments"];

			if(!!scheduledDatInMillis){
				date = new Date(scheduledDatInMillis);
				taskComments = taskComments.concat('').concat('Scheduled For ').concat(sandbox.util.formatDate(date,'d NNN y')).concat(' ');
			}
			
			history.taskComments =taskComments ;
			history.resolutionComments = _p._mailInformation.subject;
			
 		    sandbox.ajax.requestDCM({url:"/services/data/v2.0/objects/History/insertHistory?apikey="+accountID, endpoint: "/insertHistory", method:"POST", data:history , callBack : _p.historyForMailOperation});
 
	},
	
	historyForMailOperation : function(response){
			
		sandbox.publish("add-history",{ entityType : _p._mailInformation.entityType, entityID : _p._mailInformation.entityID, history : response.history});
		
	},
	
	deleteTask: function(map){
		
		var taskID;
		
		if(!map.hasOwnProperty("isConfirmed")){
			map.stopPropagation();
			taskID = sandbox.dom(map.currentTarget).parents("li").attr("taskid");
			sandbox.alert.dialog({text:"Are you sure that you'd like to delete this task?", confirm: _p.deleteTask, data:{isConfirmed: true, taskID: taskID}});
			return;
		}
		
		taskID = map.taskID;
		
		var connid, calltype, data = {}, url, metaDataForJS = {},
			accountID = sandbox.cache.get("accountID");
		
		calltype = sandbox.util.getARURLParameter("calltype");
		connid = sandbox.util.getARURLParameter("connectionid");

		data["taskID"] = taskID;
		data["entityType"] = _p._entityType;
		
		metaDataForJS["entityType"] = _p._entityType;
		metaDataForJS["entityObj"] = _p._entityObj;
		
		url = "/deleteATask/"+taskID+"?apikey="+accountID+"&isLoggedIn="+true+"&calltype="+calltype+"&connectionID="+connid; 

		sandbox.alert.message({text:"Deleting task..."});
		sandbox.ajax.request({url:url, data:data, endpoint:"/deleteATask", callBack: _p.deleteTask_CallBack, method:"POST", metaDataForJS:metaDataForJS});
	},
	
	deleteTask_CallBack: function(resultObject){
		
		var taskObj = resultObject["task"],
			taskID = taskObj["id"],
			entityType= resultObject.metaDataForJS["entityType"],
			entityID = resultObject.metaDataForJS["entityObj"].id;
		
		sandbox.alert.hideMessage();
	 	
		//this method should be called before deleting the task object from the cache
		sandbox.publish("mail-task-operations",{taskObj: taskObj, activity:"deleted the task."});

		sandbox.publish("task-updated",{id: taskID, obj: taskObj});
		
		if(sandbox.window.location.hash.indexOf(entityID) != -1){
			delete _p._currentTaskMap[taskID];
			sandbox.dom("#"+entityType+"tasks ul.dtltask_list li.tasksubtab_"+taskID).remove();
		}
		
		sandbox.alert.message({text:"Task has been deleted successfully", type: "success", time : 3000});
		
		_p.generateActivityLogForResolveOrDelete(taskObj, "Deleted", entityType, entityID);
		
		entityType = entityType.charAt(0).toUpperCase() + entityType.substr(1);
		sandbox.publish("update-analytics", { category: "Delete", action: entityType+"-Task"});
	},
	
	generateActivityLogForResolveOrDelete: function(taskObj, operation, entityType, entityID){
		
		var taskID = taskObj["id"],
			historyComments, assignee, count=0,
			tagsCache = sandbox.cache.get("tags");
		
		historyComments=sandbox.cache.get("loggedInUserName")+' '+operation+' a task<br/></br><b style="color:#0084b0;">TaskID :</b> '+taskID+'<br/><br/>'+operation+' Task Details :<br/>';
		historyComments+='<br/><b style="color:#0084b0;">Summary :</b> '+taskObj.comments+'<br/>';
		historyComments+='<br/><b style="color:#0084b0;">Due Date :</b> '+sandbox.util.formatDate(new Date(taskObj.dueDate), "h: mm a d NNN y");
		
		assignee = !!taskObj.assigneeID? taskObj.assigneeID:taskObj.department;
		assignee = sandbox.cache.getUser(assignee);
		if(!!assignee)
			assignee = assignee.name;
		else if(!!task.assigneeID)
			assignee = "Unknown (ID: "+task.assigneeID+")";

		historyComments+='<br/><b style="color:#0084b0;">Assignee :</b> '+assignee;
		
		if(!!sandbox.cache.getUser(taskObj.ownerID))
			historyComments+='<br/><b style="color:#0084b0;">Added By :</b> '+sandbox.cache.getUser(taskObj.ownerID).name;
		
		if(!sandbox.util.isEmptyObject(taskObj.linkedTags)){
			
			historyComments+='<br/><b style="color:#0084b0;">Tags :</b>';
			
			sandbox.dom.each(taskObj.linkedTags, function(i, tagID){
				if(!tagsCache.hasOwnProperty(tagID))
					return true;
				if(count == 0)
					historyComments+=tagsCache[tagID].name;
				else
					historyComments+=", "+tagsCache[tagID].name;
				count++;
			});
		}
		
		if(!!taskObj.notes)
			historyComments+='<br/><b style="color:#0084b0;">Notes :</b> '+taskObj.notes;
		
		sandbox.publish("insert-activity-log", { entityType : entityType, entityID : entityID, historyComments : historyComments, taskID: taskID});
	},
	
	fetchTasksForAccount: function(map){
		
		sandbox.dom("#accounttasks select.taskSubTabTypeFilter").prop("disabled",true).selectpicker("refresh");
		sandbox.dom("#accounttasks select.taskSubTabStatusFilter").prop("disabled",true).selectpicker("refresh");
		sandbox.dom("li.dtltask_list_placeholder").remove();
		sandbox.dom("#accounttasks ul.dtltask_list").append(_p._loadingPlaceholderForTasksSubTabTemplate);
		//sandbox.dom("#tasksSubTabLoadMore").removeClass("hide").addClass("m-progress");
		
		var typesCache={}, departmentID;
		
		if(map.clearSection){
			_p._cursor=null; _p._currentTaskMap = {};
			sandbox.dom("#accounttasks ul.dtltask_list").empty();
			sandbox.dom("#accounttasks ul.dtltask_list").append(_p._loadingPlaceholderForTasksSubTabTemplate);
		}
		
		//if(_entityObj != map.account){
		if(map.isNewPageLoad){
		
			_p._entityObj = map.account; _p._entityType = "account"; _p._currentTaskMap = {}; _p._cursor = null;
			departmentID = sandbox.cache.get("selectedDepartmentID");
			
			sandbox.dom("#accounttasks ul.dtltask_list").empty();
			sandbox.dom("#accounttasks ul.dtltask_list").append(_p._loadingPlaceholderForTasksSubTabTemplate);
			
			sandbox.dom.each(sandbox.cache.get("tasktype"), function(key, value){
				if(value.deleted || !value.linkedDepartments || value.linkedDepartments.indexOf(departmentID) == -1)
					return true;
				typesCache[key] = value;
			});
			
			sandbox.dom("#accounttasks select.taskSubTabTypeFilter").html(_p._typeFilterTemplate({taskTypes : typesCache}));
			sandbox.dom("#accounttasks select.taskSubTabTypeFilter").removeClass("hide").selectpicker("refresh");
			sandbox.dom("#accounttasks select.taskSubTabStatusFilter").removeClass("hide").val("open").selectpicker("refresh");
		}
		
		if(!sandbox.util.getFeatureAvailablityStatus("ticketingSystem"))
			sandbox.dom("#accounttasks span.tabfilteropt").css("display","none");
		
		var type = sandbox.dom("#accounttasks select.taskSubTabTypeFilter").val(),
			status = sandbox.dom("#accounttasks select.taskSubTabStatusFilter").val(),
			url = "/getTasksUnderAccount?linkedAccount="+_p._entityObj.id;
		
		if(!!type)
			url = url + "&taskTypeID="+type;
		if(!!status)
			url = url + "&taskStatus="+status;
		if(!!_p._cursor)
			url = url + "&cursor="+_p._cursor;
		
		//sandbox.alert.spinner(true);
		sandbox.ajax.request({method:"GET", url:url, endpoint:"/getTasksUnderAccount", callBack: _p.fetchTasksForAccount_Callback});
	},
	
	fetchTasksForAccount_Callback: function(result){
	
		//sandbox.alert.spinner(false);
		//sandbox.dom("#tasksSubTabLoadMore").removeClass("m-progress");
		sandbox.dom("li.dtltask_list_placeholder").remove();

		sandbox.dom("#accounttasks select.taskSubTabTypeFilter").prop("disabled",false).selectpicker("refresh");
		sandbox.dom("#accounttasks select.taskSubTabStatusFilter").prop("disabled",false).selectpicker("refresh");
		
		if(sandbox.window.location.hash.indexOf(result.linkedAccount) == -1)
			return;
		
		if(!_p._cursor)
			sandbox.dom("#accounttasks ul.dtltask_list").empty();
		
		_p._cursor = result.nextCursor;
		
		_p.addTasks({tasks: result.task, isNew : false, isAppend: true});
		sandbox.publish("tasks-updated",{tasks: result.task});
	},
	
	showEmailPopup : function(e){
		
		var dataForEmailPopup = {}, emailSubject = "";
		
		var toAddress = sandbox.dom(e).html();
		    toAddress = sandbox.dom.trim(toAddress);
        
		    emailSubject = sandbox.dom(e).parent().html();
		    emailSubject = sandbox.util.removeHTMLTags(emailSubject);
		    		
		_p._subTaskID = sandbox.dom(e).closest(".dtltask_desc").parent().attr('taskid');

		dataForEmailPopup.moduleName = sandbox.moduleName;
		
		dataForEmailPopup.entityType = _p._entityType;
		dataForEmailPopup.entityID = sandbox.url.entityID();
		dataForEmailPopup.to = toAddress;
		
		dataForEmailPopup.subject = "Re : "+ emailSubject;
		
		if(_p._entityType == "contact" || _p._entityType == "lead")
			dataForEmailPopup.contactID = sandbox.url.entityID();
		else if(_p._entityType == "task")
			dataForEmailPopup.taskID = sandbox.url.entityID();
		else if(_p._entityType == "deal" || _p._entityType == 'account')		
			dataForEmailPopup.contactID  = _p._currentTaskMap[_p._subTaskID]['linkedContacts'][0];
		
		sandbox.publish("show-email-popup",dataForEmailPopup);
	},
	
	executeDeferredJobs : function(){
		
		var hash,i,l,map;
		
		hash = (!!sandbox.url.entityID()) ? "#"+sandbox.url.page()+"/"+sandbox.url.entityID() : "#"+sandbox.url.page();
		l = _p._deferredFuncCalls.length;
		if(l != 0){
    		for(i=0;i<l;i++){
    			map = _p._deferredFuncCalls[i];
    			if(!!map.hash && hash != map.hash)
    				continue;
    			
    			map.func.apply(map.thisObj, map.args);
    			_p._deferredFuncCalls.splice(i,1);
    			i--;l--;
    		}
    	}
	}
	
	
	};
	var api = {
		
		init : function() {
			
			sandbox.dom("#dealtasks,#accounttasks,#contacttasks,#leadtasks").on('click','.dtltask_list li .dtltask_desc .dtltask_moreBtn',function(e){
				
				sandbox.dom('#allpopups').find('.closeCustomPopup').trigger('click');
				
				sandbox.dom(this).parent().parent().toggleClass("dtltask_more");
				if( sandbox.dom(this).parent().parent().hasClass("dtltask_more")){
					sandbox.dom(this).text("...hide details");
				}else
					sandbox.dom(this).text("...view details");

			});
			
			sandbox.dom("#dealtasks,#accounttasks,#contacttasks,#leadtasks").on("click",".dtltask_list li .dtltask_desc .dtltask_content .link",function(e){
				
				sandbox.dom('#allpopups').find('.closeCustomPopup').trigger('click');
				if(sandbox.dom(e.target).attr('data-subtask-type') == 'email')
				_p.showEmailPopup(e.target);			
				else if(sandbox.dom(e.target).attr('data-subtask-type') == 'call'){
					
					var phoneNo = sandbox.dom(e.target).html();
						  phoneNo = sandbox.dom.trim(phoneNo);
						  
						  sandbox.publish("dial-phoneNo",{ entityType : sandbox.url.page(), entityID : sandbox.url.entityID(), phoneNo : phoneNo});
				}
				else if(sandbox.dom(e.target).attr('data-subtask-type') == 'sms') {
					var contactID = sandbox.dom(e.target).attr('data-contact-id');
					var to = sandbox.dom.trim(sandbox.dom(e.target).html());
					
					sandbox.publish('send-sms',{ entityType : sandbox.url.page(), entityID : sandbox.url.entityID(), contactID : contactID,to : to});
				}
				
				});

			sandbox.dom(".addTaskInDetailPage").on("click", _p.showAddTaskPopup);
			sandbox.dom(".dtltask_list").on("click","li", _p.openTask);
			sandbox.dom(".dtltask_list").on("li div.commonedit a.icon-pencil5" , _p.openTaskPopup);
			sandbox.dom(".dtltask_list").on("click","li div.commonedit a.icon-trash-o", _p.deleteTask);
			sandbox.dom(".dtltask_list").on("click","div.dtltask_check, div.dtltask_type", _p.showResolveTaskPopup);
			sandbox.dom("select.taskSubTabTypeFilter, select.taskSubTabStatusFilter").on("change", function(e){
				_p.fetchTasksForAccount({account: _p._entityObj, clearSection:true, isNewPageLoad:false});
			});
			sandbox.dom("#tasksSubTabLoadMore").on("click", function(e){
				sandbox.dom("#tasksSubTabLoadMore").addClass("hide");
				_p.fetchTasksForAccount({account: _p._entityObj, clearSection:false, isNewPageLoad: false});
			});
			
			sandbox.subscribe("new-task-created-detailpage", function(data){
				_p.addTasks({tasks: [data.task], isNew : true});
			});
			sandbox.subscribe("new-task-updated-detailpage", function(data){
				_p.updateTask(data.task);
			});
			sandbox.subscribe("deal-detail-display", function(data){
				_p.getTasks({type :"deal", obj : data.deal, tasks : data.tasks});
			});
			sandbox.subscribe("contact-otherinfo-fetched", function(data){
				_p.getTasks({type :"contact", obj : data.obj, tasks : data.tasks});
			});
			sandbox.subscribe("lead-otherinfo-fetched", function(map){
				var tasks = [];
				if(!sandbox.util.isEmptyObject(map.data.task)){
					sandbox.dom.each(map.data.task, function(id, task){
						tasks.push(task);
					});
				}
				_p.getTasks({type :"lead", obj : map.obj, tasks : tasks});
			});
			sandbox.subscribe("display-lead-info", function(map){
				if(sandbox.cache.get("selectedDepartmentID") == sandbox.cache.get("businessServiceDeptID"))
					sandbox.dom("#leadTasksSelect").addClass("hide");
				else
					sandbox.dom("#leadTasksSelect").removeClass("hide");
			});
			/*sandbox.subscribe("contact-otherinfo-fetched", function(data){
				getTasks({type :"contact", obj : data.obj, tasks : data.data.task});
			});
			sandbox.subscribe("account-otherinfo-fetched", function(data){
				getTasks({type :"account", obj : data.obj, tasks : data.data.task});
			});*/
			sandbox.subscribe("account-detail-display", function(map){
				_p.fetchTasksForAccount({account:map.account, clearSection:true, isNewPageLoad: true});
			});
			sandbox.subscribe("tasksSubTab-users-fetched", _p.setAssigneeNames);
			sandbox.subscribe("task-subtab-resolve", _p.resolveTask);
			/*sandbox.subscribe("task-subtab-resolve-cancel", function(data){
				var li = sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list li.tasksubtab_"+data.settings.task.id);
				li.find("div.dtltask_check input").prop("checked", false);
			});*/
			sandbox.subscribe("task-subtab-clear", function(map){
				_entityObj = {}; _p._entityType = map.type; _p._currentTaskMap = {}; _p._cursor = null;
				sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list").empty();
				sandbox.dom("#"+_p._entityType+"tasks ul.dtltask_list").append(_p._loadingPlaceholderForTasksSubTabTemplate);
			});

			sandbox.subscribe( sandbox.moduleName + "-email-sent", _p.resolveTaskForSentMail);//tasksSubTab-email-sent
			
			sandbox.subscribe("show-addTask-popup", function(task){
				_p.showAddTaskPopup(null,task,null);
			});
			
			sandbox.subscribe("tags-cache-updated", function(){
				_p._isWaitingForTags = false;
				_p.executeDeferredJobs();
			});
			
			sandbox.subscribe("updated-tasktypes", function(typesMap){
				_p._isWaitingForTaskTypes = false;
				_p.executeDeferredJobs();
			});
		},
		destroy: function(){
			sandbox.unsubscribe();
		}
	};
	
	/* For testing purpose only  - starts*/
	api._private = _p;
	/* For testing purpose only - ends*/
	
	return api;
});

DSCRM.Core.registerModule("taskDetailHeader",["url","cache","alert","util","ajax"] ,function(sandbox) {
	
	var _self = null;
	
	var _private = {
			
		 _ID : null, _taskObj : null, _page : sandbox.dom("#taskDetail"), _account : null, _deal : null,
		_lastUpdatedProperty : null , _allTagNames : [], _tagToBeCreated : null,
		_tagsTokenField : sandbox.dom("#taskDetailTags"), _mailInformation : null,
		_waitingForTaskTypes : {},
		_isWaitingForTaskTypes : true,
		_isWaitingForTags : true,
		_connID : null,
		_userPIN : null,
		_calltype : null,
		_arHistoryLoadedURL : null,
		_windowARURL : null,

		//_existingContactsTemplate = dscrm.templates.search.searchResultsForExistingContacts;
		//_elPage = sandbox.dom("#accountDetail");
	
	 setTaskPage : function(map){
		 
		 if(_private._isWaitingForTaskTypes || _private._isWaitingForTags ) {
			  setTimeout(function(){ _private.setTaskPage(map) }, 100);
			  return;
		 }
		 
		//var loggedInUserID;
		var isTaskAvailable = false,
			departmentID = sandbox.cache.get("selectedDepartmentID");
		

		if(map.hasOwnProperty("status")){
			
			//sandbox.alert.spinner(false);
			sandbox.alert.hideMessage();
			
			if(!map.task){
				
				sandbox.dom("#taskDetail").removeClass("active in");
				sandbox.alert.message({text:"Task not found", time:8000});
				return;
			}
			else if(map.hasOwnProperty("switchDepartment")){
				sandbox.publish("switch-department-tab",{"departmentID" : map.switchDepartment});
				return;
			}
			else if(map.hasOwnProperty("errorMessage")){
				if(!!map.task && departmentID != map.task.departmentID){
					sandbox.alert.message({text:"You don't have access to view other departments' tasks.", time:8000});
					sandbox.dom("#taskDetail").removeClass("active in");
				}
				return;
			}
			
			sandbox.publish("update-interaction-status", { entityType : "task", entityID : _private._ID, status : 2 , connID : _private._connID , userPIN : _private._userPIN, arHistoryLoadedURL : _private._arHistoryLoadedURL , windowARURL : _private._windowARURL , calltype : _private._calltype});

			_private._taskObj = map.task;
			//loggedInUserID = sandbox.cache.get("loggedInUserID");
			
			//if(_taskObj.assigneeID == loggedInUserID && _taskObj.status != "deleted" && _taskObj.status != "completed")
			
			sandbox.publish("task-updated", {id : _private._ID, obj: _private._taskObj});
			
		/*	var taskTypes = sandbox.cache.get("tasktype"), taskType;
			
			if(sandbox.util.isEmptyObject(taskTypes) && map.hasOwnProperty("taskTypeName"))
				taskType = map.taskTypeName.toLowerCase();
			else
				taskType = taskTypes[_private._taskObj.type].type.toLowerCase();
		
			if("call" == taskType || "email" == taskType || "to-do" == taskType || "sms" == taskType)
				return;  */
			
			sandbox.publish("task-detail-display",{task : _private._taskObj});
			_private.displayTask();

			return;
		}
		
		
		sandbox.dom('.taskheader').removeClass('childtask');
		sandbox.dom('.taskheader .ellipsis').html("");
		sandbox.dom('.taskheader .ellipsis').css("display","none");
		sandbox.dom("main").children().removeClass("active in");
		sandbox.dom("#taskDetail").removeClass("active in").addClass("active");
        setTimeout(function(){ sandbox.dom("#taskDetail").addClass("in"); }, 100);
        sandbox.alert.message({text : "Loading..."});
       // sandbox.alert.spinner(true);
        
        if(!map.selectDisplay){
        
	        sandbox.publish("customfields-subtab-clear", {type :"task"})
	        	.publish("document-subtab-clear", {type : "task"})
	        	.publish("taskAccountNumbers-clear",{id: map.id})
	        	.publish("otherTasksSection-clear",{id: map.id});
        }
        

		
		_private._ID = map.id;

		if(!!map.taskObj){
			isTaskAvailable = true; _private._taskObj = map.taskObj;
		}
		else if(sandbox.cache.get("tasks").hasOwnProperty(_private._ID)){
			isTaskAvailable = true; _private._taskObj = sandbox.cache.get("tasks")[_private._ID];
		}
		
		if(isTaskAvailable){

			if(_private._taskObj.departmentID != departmentID){
				sandbox.publish("switch-department-tab",{"departmentID" : _private._taskObj.departmentID});
				return;
			}
			
			//sandbox.alert.spinner(false);
			sandbox.alert.hideMessage();
			
		/*	var taskType = _private._taskObj.type, taskTypes = sandbox.cache.get("tasktype");
			taskType = taskTypes[taskType].type.toLowerCase();
		
			if("call" == taskType || "email" == taskType || "to-do" == taskType || "sms" == taskType)
				return;*/
			
			sandbox.publish("task-detail-display",{task : _private._taskObj});
			_private.displayTask(map.selectDisplay);
					
			return;
		}
		
		_private._connID = sandbox.util.getQueryString({key : "connid", defaultValue : null});
		_private._userPIN = sandbox.util.getQueryString({key : "userpin",defaultValue : null});
		_private._calltype = sandbox.util.getQueryString({key : "calltype", defaultValue : null});
		_private._windowARURL = window.location.href;
		_private._arHistoryLoadedURL = sandbox.util.getQueryString({key : "arHistoryLoaded", defaultValue : null});
		
		sandbox.cache.update({'arInteractionDetail' : {connectionId : _private._connID, userPIN : _private._userPIN,
													   entity : "task", entityID : _private._ID, calltype : _private._calltype, 
													   windowARURL : _private._windowARURL, 
													   arHistoryLoadedURL : _private._arHistoryLoadedURL}});

		var data = {},url = null;
		
		data["departmentID"] = departmentID;
		data["accessibleDepartments"] = sandbox.cache.get("accessibleDepartments");

		if(!!_private._connID && !_private._arHistoryLoadedURL ) {
			
			sessionStorage['connectionid'] = _private._connID;
			sessionStorage['userPIN'] = _private._userPIN;
			sessionStorage['ID'] = _private._ID;
			sessionStorage['entity'] = "task";
			sessionStorage['arHistoryLoadedURL'] = _private._arHistoryLoadedURL;
			sessionStorage['calltype'] =  _private._calltype;
			sessionStorage['windowARURL'] = _private._windowARURL;
			sessionStorage['isArHistoryNeeded'] = true;
			
			url = "/updateATask/"+_private._ID+"?apikey="+sandbox.cache.get("accountID")+"&connID="+_private._connID+"&userPIN="+_private._userPIN+"&isLoggedIn="+true
				+"&taskid="+_private._ID;
			
			data['assigneeID']  = sandbox.cache.get("loggedInUserID");
			sandbox.ajax.request({method: "PUT", url: url , endpoint: "/updateATask", data: data, callBack: _private.setTaskPage});
		}
		
		else{
			
				url = "/getATask_v2?apikey="+sandbox.cache.get("accountID")+"&taskid="+_private._ID+"&isLoggedIn=true";
				/*	if(sandbox.util.isEmptyObject(sandbox.cache.get("tasktype")))
				data["isTaskTypeNeeded"] = true;  */
		
				sandbox.ajax.request({url:url, method:"POST", endpoint:"/getATask_v2", callBack: _private.setTaskPage, data: data});
		}
	},
	
	displayTaskHeader : function() {
		
		var user, data = {}, tags = [], taskType = "",
			rating = [1,2,3,4,6].indexOf(parseInt(_private._taskObj.rating)) != -1? _private._taskObj.rating : 6;
			comments = sandbox.util.removeHTMLTags(_private._taskObj.comments),
			isTicketingSystemEnabled = sandbox.util.getFeatureAvailablityStatus("ticketingSystem")
			userID = sandbox.cache.get("loggedInUserID"),
			//tagsCache = sandbox.cache.get("tags"),
			isAllUsersFetched = sandbox.cache.get("isAllUsersFetched");
			
		if(!sandbox.cache.get("tasktype").hasOwnProperty(_private._taskObj.type)){
			var hashUrl = (!!sandbox.url.entityID()) ? "#"+sandbox.url.page()+"/"+sandbox.url.entityID() : "#"+sandbox.url.page();
			_private._waitingForTaskTypes[hashUrl] = {func: function(){
				_private._page.find("#taskDetailType").html(" "+taskType);
			}, args:[],thisObj:{}};
		}
		else
			taskType = sandbox.cache.get("tasktype")[_private._taskObj.type].type;
	
		sandbox.util.pageTitle(comments, "Task");
		
		_private._page.find(".dtl_headerhold_placeholder").remove();
		_private._page.find(".dtl_headerhold_content").removeClass("hide");
		
		user = sandbox.cache.getUser(_private._taskObj.ownerID);
		if(!user){
			if(!!_private._taskObj.ownerID && !isAllUsersFetched){
				data["parentDOMID"] = "taskowner";
				data["selectedContactID"] = [_private._taskObj.ownerID];
				data["type"] = "taskDetailCreated";
				sandbox.publish("users-selected-fetch", data);
			}
			_private._page.find("#taskDetailCreated").html("Added : "+sandbox.util.formatDate(new Date(_private._taskObj.createdDate), "d NNN y"));
		}
		else
			_private._page.find("#taskDetailCreated").html("Added by "+user.name+" on "+sandbox.util.formatDate(new Date(_private._taskObj.createdDate), "d NNN y"));
		
		_private._page.find("#taskDetailName").val(comments).removeAttr("data-original-title");
		_private._page.find("#taskDetailModifiedDate").html("Modified : "+sandbox.util.formatDate(new Date(_private._taskObj.lastUpdatedDate), "d NNN y"));
		_private._page.find("#taskDetalStatus").html(" "+_private._taskObj.status);
		_private._page.find("#taskDetailDueDate").html("Due : "+sandbox.util.formatDate(new Date(_private._taskObj.dueDate), "hh:mm a d NNN y"));
		_private._page.find("#taskDetailProduct").html(" "+sandbox.cache.getProductName(_private._taskObj.productID));
		_private._page.find("#taskDetailType").html(" "+taskType);
		_private._page.find("#task_rating").val(rating).selectpicker("refresh");
		_private._page.find("#tasknotes div.notes").summernote('code', _private._taskObj.notes);
		
		_private._page.find("#idMoveTaskTypeDetail").addClass("hide");
		_private._page.find(".alert-warning").addClass("hide");
		_private._page.find("#idMoveTaskDetail").addClass("hide");
		_private._page.find("#idAddSubscriberInMenuTaskDetail").addClass("hide");
		
		if(comments.length>45){
			_private._page.find("#taskDetailName").attr("data-original-title",comments).on('click',function(){this.blur()});
		}

		if(!!_private._taskObj.linkedAccount)
			_private._page.find("#idMoveTaskDetail").removeClass("hide");
		
		/*if(!sandbox.util.isEmptyObject(_taskObj.linkedTags)){
			_taskObj.linkedTags.map(function(tagID){
				if(tagsCache.hasOwnProperty(tagID))
					tags.push(tagsCache[tagID].name);
			});
			_tagsTokenField.off().tokenfield("setTokens",tags);
		}
		else
			_tagsTokenField.off().tokenfield("setTokens","").val("");*/
		_private.initTokenField();
		
		if(_private._taskObj.status == "completed" || _private._taskObj.status == "deleted"){
			_private._page.find("#taskDetail_HeaderIcon").attr("src","../images/default-image/defaulttask_img.png");
			_private._page.find("#taskDetailName").addClass("strike_through");
			_private._page.find("#idEditTaskDetail, #idDeleteTaskDetail").addClass("hide");
		}
		else{
			_private._page.find("#taskDetail_HeaderIcon").attr("src","../images/default-image/pendingtask_img.png");
			_private._page.find("#taskDetailName").removeClass("strike_through");
			_private._page.find("#idEditTaskDetail, #idDeleteTaskDetail").removeClass("hide");
			if(isTicketingSystemEnabled && userID == _private._taskObj.assigneeID)
				_private._page.find("#idMoveTaskTypeDetail").removeClass("hide");
		}
		
		if(sandbox.util.isEmptyObject(_private._taskObj.linkedSubscribers))
			_private._page.find("#idAddSubscriberInMenuTaskDetail").removeClass("hide");

		if(_private._taskObj.status == "deleted")
			_private._page.find(".alert-warning").removeClass("hide");
		else if(_private._taskObj.status == "unread" && userID == _private._taskObj.assigneeID)
			sandbox.publish("unreadTasks-opened",{id:_private._taskObj.id});
	},
	
	displayTask : function(selectDisplay){
		
		if(!selectDisplay || selectDisplay.subtabs)
			_private.getOtherInfo();
		
		if(!selectDisplay || !selectDisplay.hasOwnProperty("headerAndButtons") || selectDisplay.headerAndButtons == true)
			_private.displayTaskHeader();
		
		if(!selectDisplay || !selectDisplay.hasOwnProperty("fetchAccount") || selectDisplay.fetchAccount == true)
			_private.getAccount();
	
		if(!selectDisplay || !selectDisplay.hasOwnProperty("fetchContacts") || selectDisplay.fetchContacts == true)
			sandbox.publish("display-involved-contacts", { entityType : "task", entityID : _private._taskObj.id, linkedContacts : _private._taskObj.linkedContacts})
				   .publish("bind-events-for-contact-actions", { entityType : "task", entityID : _private._taskObj.id, linkedAccount : _private._taskObj.linkedAccount , linkedContacts : _private._taskObj.linkedContacts  })
				   .publish("display-history", { entityType : "task", entityID : _private._taskObj.id});
		
		if(!selectDisplay || !selectDisplay.hasOwnProperty("fetchOtherTasks") || selectDisplay.fetchOtherTasks == true)
			sandbox.publish("otherTasks-display",{task: _private._taskObj});
		
		if(!selectDisplay)
			sandbox.publish("update-recent-item",{entity:'task',entityID:_private._taskObj.id,entityTitle:sandbox.util.removeHTMLTags(_private._taskObj.comments),category:''});
		
		//Removing default selected tab
		sandbox.dom("#taskDetail").find(".dtltabs li").removeClass("active");
		sandbox.dom("#taskDetail").find(".tab-content > div").removeClass("active");
		
	},
	
	getOtherInfo : function(map){
		
		var data = {};
		data["departmentID"] = sandbox.cache.get("selectedDepartmentID");
		data["id"] = _private._ID;
		data["linkedDocuments"] = _private._taskObj.linkedDocuments;
		data["linkedCustomFields"] = _private._taskObj.linkedCustomFields;
		data["linkedTags"] = _private._taskObj.linkedTags;
		data['linkedTasks'] = _private._taskObj.linkedTasks;
		data["utcOffsetString"] = sandbox.cache.get("timeZoneAndOffset")["offset"];
		
		sandbox.ajax.request({url:"/getOtherReqInfoForTask", data : data, endpoint:"/getOtherReqInfoForTask", callBack : _private.getOtherInfo_Callback, method : "POST"});
		sandbox.alert.message({text:"Loading..."});
	},
	
	getOtherInfo_Callback : function(map){
		
		if(!map || !map.success)
			return;
		else if(map.id != _private._taskObj.id)
			return;
		
		sandbox.alert.hideMessage();
		sandbox.publish("task-otherinfo-fetched",{obj : _private._taskObj, data: map});
		
		var tags = map.tasktags, 
			isOtherDept = false,
			departmentID = sandbox.cache.get("selectedDepartmentID");
		
		if(!sandbox.util.isEmptyObject(tags)){
			sandbox.dom.each(tags,function(index, tag){
				if(tag.departmentID != departmentID){
					isOtherDept = true;
					return false;
				}
			});
		}
		
		if(isOtherDept){
			sandbox.publish("update-tags-in-cache",{tags: tags, taginfo:[]});
			_private.initTokenField();
		}
	},
	
	getTaskDetails : function(map) {
		
		var taskObj = map.obj,
			tagsCache = sandbox.cache.get("tags"),
			user, assigneeID = '', ownerID = '', assigneeName = '', 
			assigneeEmail = '', ownerName = '', ownerEmail = '', mapOfData = {},
			linkedTags = [], linkedSubscribers = [], listTagNames = [], listSubscriberEmails = [];
		
		if(sandbox.util.isEmptyObject(taskObj)){
			map["entityInfo"] = mapOfData;
			sandbox.publish(map.publish, map);
			return;
		}
		
		assigneeID = taskObj["assigneeID"];
		ownerID = taskObj["ownerID"];
		linkedTags = taskObj["linkedTags"];
		linkedSubscribers = taskObj["linkedSubscribers"];		
		
		user = sandbox.cache.getUser(assigneeID);
		if(!!user){
			assigneeName = user.name;
			assigneeEmail = user.email;
		}
		user = sandbox.cache.getUser(ownerID);
		if(!!user){
			ownerName = user.name;
			ownerEmail = user.email;
		}
		
		if(!!linkedTags){
			
			sandbox.dom.each(linkedTags, function(index, tagID){
				
				if(!!tagsCache[tagID])
					listTagNames.push(tagsCache[tagID].name);
				
			});
		}
		if(!!linkedSubscribers){
			sandbox.dom.each(linkedSubscribers, function(index, userID){
				user = sandbox.cache.getUser(userID);
				if(!!user)
					listSubscriberEmails.push(user.email);
			});
		}		
		
		mapOfData["assigneeName"] = assigneeName;
		mapOfData["assigneeEmail"] = assigneeEmail;
		mapOfData["ownerName"] = ownerName;
		mapOfData["ownerEmail"] = ownerEmail;
		mapOfData["assigneeID"] = assigneeID;
		mapOfData["ownerID"] = ownerID;
		mapOfData["tags"] = listTagNames;
		mapOfData["subscribers"] = listSubscriberEmails;
		mapOfData["comments"] = taskObj["comments"];
		mapOfData["dueDate"] = taskObj["dueDate"];
		mapOfData["userName"] = sandbox.cache.get("loggedInUserName");
		mapOfData["userEmail"] = sandbox.cache.get("loggedInUserEmail");
		mapOfData["operation"] = "update";
		mapOfData["taskID"] = taskObj["id"];
		mapOfData["appUrl"] = sandbox.cache.get("appURL");
		mapOfData["createdDate"] = "";
		 
		map["entityInfo"] = mapOfData;
		sandbox.publish(map.publish, map);
	},
	
	setUserNames : function(map){
		
		if(sandbox.util.isEmptyObject(map.users))
			return;
		
		var type= map.type, str, name, ownerID = _private._taskObj.ownerID;
		
		if(type == "taskDetailCreated" && !!map.users[ownerID]){
			
			name = map.users[ownerID].name;
			
			str = "Added by "+name+" on "+sandbox.util.formatDate(new Date(_private._taskObj.createdDate), "d NNN y"),
			
			_private._page.find("#taskDetailCreated").html(str);
		}
	},
	
	refreshHeader : function(data) {
		if(sandbox.util.isEmptyObject(data))
			return;
		
		_private._taskObj = data.task;
		sandbox.publish("task-updated", {id : _private._ID, obj: _private._taskObj});
		_private.displayTaskHeader();
	},
	
	getAccount : function() {
		
		var linkedAccount = _private._taskObj.linkedAccount,
	        data = {}, account;
		
		if(!linkedAccount){
			sandbox.publish("display-involved-account",{id : _private._ID, obj : _private._taskObj});
			return;
		}else if(!!sandbox.cache.get("accounts")[linkedAccount]){
			account = sandbox.cache.get("accounts")[linkedAccount];
			_private.getAccountCallBack({success: true, account: account});
			sandbox.publish("taskAccountNumbers-fetch", {task: _private._taskObj, account: account});
		}
		
		_private._account = sandbox.cache.get("accounts")[linkedAccount];		
		if(!sandbox.util.isEmptyObject(_private._account)){
			sandbox.publish("contact-actions-update-account",{account:_private._account , task: _private._taskObj});
			_private.setLinkedHeaderInDom({account:_private._account});
			return;
		}
        
		data['accessibleDepartments'] = sandbox.cache.get('accessibleDepartments');
		data['entity'] = 'task';
		
		sandbox.ajax.request({method:"POST", url: "/" +linkedAccount+"/getAccount", endpoint:"/getAccount", data: data, callBack: _private.getAccountCallBack});
		
	},
	
	getAccountCallBack : function(response) {
		
		if(sandbox.util.isEmptyObject(response) || !response.success)
			return;

		_private._account = response.account;
		
		var listCustomField = response.hasOwnProperty("mapOfCustomFieldInfo")?response.mapOfCustomFieldInfo.customField:null;
		
		sandbox.cache.get("accounts")[_private._account.id] = JSON.parse(JSON.stringify(_private._account));
		
		sandbox.publish("task-detail-linkedAccount-fetched", {account: _private._account, task: _private._taskObj, customField: listCustomField});
		
		_private.setLinkedHeaderInDom({account:_private._account});
		
		sandbox.publish("hide-involved-account",{});
		
	},

	getDeal : function() {
		
		var linkedDeal = _private._taskObj.linkedDeal,
			data = {};
		
		if(!linkedDeal)
			return;
		
		_private._deal = sandbox.cache.get("deals")[linkedDeal];		
		if(!sandbox.util.isEmptyObject(_private._deal))
			return;
		
		data["dealid"] = parseFloat(_private._taskObj.linkedDeal);
		sandbox.ajax.request({method:"POST", url: "/getADeal_v2", endpoint:"/getADeal_v2", data: data, callBack: _private.getDealCallBack});
		
	},
	
	getDealCallBack : function(response) {
		
		_private._deal = response.deal;
		_private.setLinkedHeaderInDom({deal:_private._deal});
		
	},
	
	updateTaskProperty : function(prop, value){
		
		if(sandbox.util.isEmptyObject(_private._taskObj) || _private._taskObj[prop] == value)
			return;
		
		if( prop == "notes")
			sandbox.publish("createOrUpdate-note-analytics",{obj:_private._taskObj,type:"Task"});
		
		var map = {operation: "update"}, accountID = sandbox.cache.get("accountID");
		map[prop] =value;
		_private._lastUpdatedProperty = prop;
		
		sandbox.alert.message({text:"Updating task..."});
		sandbox.ajax.request({url:"/updateATask/"+_private._taskObj.id+"?apikey="+accountID+"&isLoggedIn=true", endpoint:"/updateATask", method:"PUT", data:map, callBack: _private.updateTaskProperty_Callback });
	},
	
	updateTaskProperty_Callback : function(result){

		_private.refreshHeader(result);
		sandbox.alert.hideMessage();
		
		_private.createActivityLogAfterUpdate();		
	},
	
	createActivityLogAfterUpdate : function(){
		
		var historyComments, 
			userName = sandbox.cache.get("loggedInUserName"), arr = [];
		
		historyComments = userName+' Edited a task<br/></br><b style="color:#0084b0;">TaskID :</b> '+_private._taskObj.id+'<br/><br/>Edited Task Details :<br/><br/>';
		
		arr = (_private._lastUpdatedProperty instanceof Array)? _private._lastUpdatedProperty:[_private._lastUpdatedProperty];
		
		arr.map(function(prop){
			
			switch(prop){
			
				case "notes":{
					historyComments+='<b style="color:#0084b0;">Notes :</b> '+_private._taskObj.notes+'<br/>';
				}break;
				case "rating":{
					historyComments+='<b style="color:#0084b0;">Status :</b> '+sandbox.dom("#task_rating option:selected").data("content")+'<br/>';
				}break;
				case "comments":{
					historyComments+='<b style="color:#0084b0;">Summary :</b> '+_private._taskObj.comments+'<br/>';
				}break;
				case "dueDate":{
					historyComments+='<b style="color:#0084b0;">Due Date :</b> '+sandbox.util.formatDate(new Date(_private._taskObj.dueDate), "MM/dd/yyyy hh:mm a")+'<br/>';
				}break;
			};
		});

		if(!!historyComments)
			sandbox.publish("insert-activity-log", { entityType : "task", entityID : _private._taskObj.id, historyComments : historyComments});
	},
	
	editTaskFormSubmit : function(map){
		
		var comments, dueDate, count=0, data = {}, oldDueDate, accountID = sandbox.cache.get("accountID");
		
		sandbox.dom.each(map.formData, function(index, value){
			if(value.name == "comments"){
				comments = value.value;
				count++;
			}
			else if(value.name == "dueDate"){
				dueDate = value.value;
				count++;
			}
			if(count == 2)
				return false;
		});
		
		if(!comments){
			sandbox.alert.message({text:"Task summary cannot be empty", time:4000});
			return;
		}
		else if(!dueDate){
			sandbox.alert.message({text:"Due date cannot be empty", time:4000});
			return;
		}
		
		oldDueDate = sandbox.util.formatDate(new Date(_private._taskObj.dueDate), "MM/dd/yyyy hh:mm a");
		
		if(comments == _private._taskObj.comments && dueDate == oldDueDate)
			return;
		else {
			if(comments == _private._taskObj.comments && oldDueDate != dueDate)
				_private._lastUpdatedProperty = "dueDate";
			else if(comments != _private._taskObj.comments && oldDueDate == dueDate)
				_private._lastUpdatedProperty = "comments";
			else
				_private._lastUpdatedProperty= ["comments","dueDate"];
		}
		
		data = {comments: comments, dueDate: dueDate, taskID: _private._taskObj.id, operation:"update"};
		sandbox.ajax.request({url:"/updateATask/"+_private._taskObj.id+"?apikey="+accountID+"&isLoggedIn=true", endpoint:"/updateATask", method:"PUT", data:data, callBack: _private.editTaskFormSubmit_Callback});
		sandbox.alert.message({text:"Updating task..."});
	},
	
	editTaskFormSubmit_Callback : function(result){

		_private.refreshHeader(result);
		sandbox.alert.hideMessage();
		sandbox.publish("hide-custom-popup");
		_private.createActivityLogAfterUpdate();
		sandbox.publish("mail-task-operations",{taskObj: result.task, activity:"updated a task."});
		sandbox.publish("update-analytics", {category: "Edit", action: "Task"});
	},
	
	moveTaskType : function(map){

		var	accountID = sandbox.cache.get("accountID"),
			data = {taskID: _private._taskObj.id};
		
		if(!sandbox.util.isEmptyObject(map.formData)){
			map.formData.map(function(pair){
				if(pair.name == "type")
					data["type"] = pair.value;
			});
		}
		
		if(_private._taskObj.type == data["type"]){
			sandbox.alert.message({text:"Cannot move to the same Task Type", time: 3000});
			return;
		}

		data["utcOffsetString"] = sandbox.cache.get("timeZoneAndOffset")["offset"];
		if(!sandbox.util.isEmptyObject(map.customField))
			data["customField"] = map.customField;
		
		sandbox.alert.message({text:"Updating task..."});
		sandbox.ajax.request({url:"/moveTicketType/"+_private._taskObj.id+"?apikey="+accountID+"&isLoggedIn="+true, endpoint:"/moveTicketType", data:data, callBack: _private.moveTaskType_Callback, method:"PUT"});
	},
	
	moveTaskType_Callback : function(resultObject){

		sandbox.publish("update-analytics", { category: "Edit", action: "Task"});
		
		var oldTaskType = _private._taskObj.type,
			userName = sandbox.cache.get("loggedInUserName"),
			activityData = {};
		
		if(!sandbox.util.isEmptyObject(_private._taskObj.linkedCustomFields)){
			
			if(resultObject.hasOwnProperty("customField") && resultObject.hasOwnProperty("result")){
				activityData["oldCustomFieldValues"] = resultObject["customField"];
				resultObject = resultObject.result;
			}
			else{
				sandbox.publish("customfields-getCurrentPageValues",{result:resultObject, publish:"moveTaskType-oldCustomFields-fetched"});
				return;
			}
		}
		
		oldTaskType = sandbox.cache.get("tasktype")[oldTaskType].type;

		_private._taskObj = resultObject.task;
		
		sandbox.publish("task-updated",{obj: _private._taskObj, id: _private._taskObj.id});
		sandbox.publish("display-task-info",{id:_private._taskObj.id, taskObj: _private._taskObj, selectDisplay:{headerAndButtons : true, subtabs : true, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});

		activityData["oldTaskType"] = oldTaskType;
		activityData["customField"] = resultObject["customField"];
		_private.generateActivityLogForMoveType(activityData);

		sandbox.publish("mail-task-operations",{taskObj: _private._taskObj, activity:"moved task type."});
		
		sandbox.alert.hideMessage();
		sandbox.publish("hide-custom-popup");
	},
	
	generateActivityLogForMoveType : function(map){
		
		var historyComments, userName = sandbox.cache.get("loggedInUserName"),
			oldCustomFieldValues = map["oldCustomFieldValues"],
			cfMap = {}, newCustomFieldValues, oldTaskType,
			newTaskType = sandbox.cache.get("tasktype")[_private._taskObj.type].type,
			fieldInfoCache = sandbox.cache.get("fieldInfo");
		
		if(!sandbox.util.isEmptyObject(oldCustomFieldValues)){
			oldCustomFieldValues.map(function(cf){
				cfMap[cf.id] = cf;
			});
		}
		if(!sandbox.util.isEmptyObject(map.customField)){
			map.customField.map(function(cf){
				cfMap[cf.id] = cf;
			});
		}
		
		if(!map.hasOwnProperty("customFieldPrintValues")){
			
			sandbox.publish("customfields-get-printableValues",{customFieldMap: cfMap, publish:"moveTaskType-customField-printableValues-fetched", data: map});
			return;
		}
		else
			cfMap = map.customFieldPrintValues;
		
		oldCustomFieldValues = map.data.oldCustomFieldValues;
		newCustomFieldValues = map.data.customField;
		oldTaskType = map.data.oldTaskType;
		
		historyComments = userName+' Updated Ticket Type<br/><br/><b style="color:#0084b0;">Old Ticket Type:</b> '+oldTaskType+'<br/><b style="color:#0084b0;">Task ID:</b> '+_private._taskObj.id;
		
		if(!sandbox.util.isEmptyObject(oldCustomFieldValues)){

			historyComments+="<br/><br/>Custom Fields</br>";
			
			oldCustomFieldValues.map(function(cf){
				historyComments+= '</br><b style="color:#0084b0;">'+fieldInfoCache[cf.fieldInfoID]["name"]+'</b> '+cfMap[cf.id];
			});
		}
		
		historyComments+= '</br><br/><b style="color:#0084b0;">New Ticket Type:</b> '+newTaskType+'<br/><b style="color:#0084b0;">Task ID:</b> '+_private._taskObj.id;
		
		if(!sandbox.util.isEmptyObject(newCustomFieldValues)){

			historyComments+="<br/><br/>Custom Fields</br>";
			
			newCustomFieldValues.map(function(cf){
				historyComments+= '</br><b style="color:#0084b0;">'+fieldInfoCache[cf.fieldInfoID]["name"]+'</b> '+cfMap[cf.id];
			});
		}
		
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _private._taskObj.id, historyComments : historyComments});
	},
	
	deleteTask : function(map){
		
		if(!_private._taskObj.assigneeID){
			sandbox.alert.dialog({text:"The task should be assigned to yourself before deleting.", type:"ok"});
			return;
		}
		else if(!map.hasOwnProperty("isConfirmed")){
			sandbox.alert.dialog({text:"Are you sure that you'd like to delete this task?", confirm: _private.deleteTask, data:{isConfirmed: true}});
			return;
		}

		var connid, calltype, data = {}, user, subscriberEmails = [], 
			tagsCache, listTagNames = [], url,
			accountID = sandbox.cache.get("accountID");
		
		calltype = sandbox.util.getARURLParameter("calltype");
		connid = sandbox.util.getARURLParameter("connectionid");
		
		user = sandbox.cache.getUser(_private._taskObj.assigneeID);
		if(!!user){
			data["assigneeName"] = user.name;
			data["assigneeEmail"] = user.email;
		}
		if(!!_private._taskObj.ownerID && !!(owner = sandbox.cache.getUser(_private._taskObj.ownerID))){
			data["ownerName"] = user.name;
			data["ownerEmail"] = user.email;
		}
		
		if(!sandbox.util.isEmptyObject(_private._taskObj.linkedSubscribers)){
			_private._taskObj.linkedSubscribers.map(function(userID){
				user = sandbox.cache.getUser(userID);
				if(!!user)
					subscriberEmails.push(user.email);
			});
		}

		if(!sandbox.util.isEmptyObject(_private._taskObj.linkedTags)){
			
			tagsCache = sandbox.cache.get("tags");
			_private._taskObj.linkedTags.map(function(tagID){
				if(tagsCache.hasOwnProperty(tagID))
					listTagNames.push(tagsCache[tagID].name);
			});
			
			data["tags"] = listTagNames;
		}
		
		data["comments"] = _private._taskObj.comments;
		data["delete"] = _private._taskObj.id;
		data["operation"] = "delete";
		data["userName"] = sandbox.cache.get("loggedInUserID");
		data["userEmail"] = sandbox.cache.get("loggedInUserEmail");
		url = "/deleteATask/"+_private._taskObj.id+"?apikey="+accountID+"&isLoggedIn="+true+"&calltype="+calltype+"&connectionID="+connid; 
		
		
		sandbox.alert.message({text:"Deleting task..."});
		sandbox.ajax.request({url:url, data:data, endpoint:"/deleteATask", callBack: _private.deleteTask_CallBack, method:"POST"});
	},
	
	deleteTask_CallBack : function(resultObject){
		
		sandbox.alert.hideMessage();
		
		_private._taskObj = resultObject.task;
		sandbox.publish("task-updated", {id:_private._taskObj.id, obj: _private._taskObj});
		sandbox.publish("display-task-info",{id:_private._taskObj.id, taskObj: _private._taskObj, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
		sandbox.publish("mail-task-operations",{taskObj: _private._taskObj, activity:"deleted the task."});
		
		var historyComments=sandbox.cache.get("loggedInUserName")+' Deleted a task<br/></br><b style="color:#0084b0;">Task ID :</b> '+_private._taskObj.id+'<br/>';
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _private._taskObj.id, historyComments : historyComments});
		
		
		sandbox.alert.message({text:"Task has been deleted successfully", type: "success", time : 3000});
		sandbox.publish("update-analytics", { category: "Delete", action: "Task"});
	},
	
	getToCcAndBccDetailForHistory : function(data){	
				
		var mapData = data.mapData;
		var historyComments = data.historyComments;
		
		var historyData = '';
		var to = '', cc = '', bcc = '', from = '', subject = '';
		
		if(!!mapData['from']) {
			from = mapData['from'];
			from = from.replace(/</g,'(');
			from = from.replace(/>/g,')');		
			historyData = '<div><b>From : </b><span class="history_from">'+from+'</span></div>';
		}
		
		if(!!mapData['subject']) {
			subject = mapData['subject'];
			historyData = historyData+'<div><b>Subject : </b><span class="history_subject">'+subject+'</span></div>';
		}
		
		if(!!mapData['to']) {
			to = mapData['to'];
			to = to.replace(/</g,'(');
			to = to.replace(/>/g,')');		
			historyData = historyData+'<div><b>To : </b><span class="history_to">'+to+'</span></div>';
		}
		
		if(!!mapData['cc']) {
			cc = mapData['cc'];
			cc = cc.replace(/</g,'(');
			cc = cc.replace(/>/g,')');
			historyData = historyData+'<div><b>Cc : </b><span class="history_cc">'+cc+'</span></div>';
		}
		
		if(!!mapData['bcc']) {
			bcc = mapData['bcc'];
			bcc = bcc.replace(/</g,'(');
			bcc = bcc.replace(/>/g,')');
			historyData = historyData+'<div><b>Bcc : </b><span class="history_bcc">'+bcc+'</span></div>';
		}
		
		if(!!historyData)
			historyComments = historyData + historyComments;

		return historyComments;
		
	},
	
	changeStatusAfterSendMail : function(data) {
				
		var accountID = sandbox.cache.get("accountID");

		if(sandbox.util.isEmptyObject(data))
			return;
			
		 _private._mailInformation = data.mailInformation;
		 		 
		var taskInfoForServer = {};
		taskInfoForServer["status"] = "replied";
		taskInfoForServer["operation"] = "update";

		sandbox.alert.message({text:"Updating Task..."});

		sandbox.ajax.request({url: "/updateATask/"+_private._taskObj.id+"?apikey="+sandbox.cache.get("accountID")+"&isLoggedIn="+true, endpoint:"/updateATask", data:taskInfoForServer, callBack: _private.changeStatusAfterSendMailCallBack,method:"PUT"});
	},
	
	changeStatusAfterSendMailCallBack : function(response){
		
		if(!response.status) {
			return;
		}
		
		_private.refreshHeader(response);
		sandbox.alert.hideMessage();
		
		sandbox.alert.message({text :" Updating Comments for task..please wait...", type:"success", time: 5000});
		
		var accountID = sandbox.cache.get("accountID");
		var historyComments  = "<b> Message : </b><br><br>" + _private._mailInformation.mailContents;
		var resolutionComments = _private._mailInformation.subject;
		
		var mapHistoryData = {}, emailAttachment = '',history = {};
		
		mapHistoryData['subject'] = _private._mailInformation.subject;
		mapHistoryData['from'] = _private._mailInformation.from;
		mapHistoryData['to'] = _private._mailInformation.to;
		mapHistoryData['cc'] = _private._mailInformation.cc;
		mapHistoryData['bcc'] = _private._mailInformation.bcc;

		historyComments = _private.getToCcAndBccDetailForHistory({ mapData : mapHistoryData, historyComments :historyComments});			
		historyComments = "<div class='mailContents'>" + historyComments + "</div>";

		sandbox.dom.each(_private._mailInformation.attachments,function(id,document){	

			sandbox.dom.each(_private._mailInformation.documents,function(documentID , fileInfo){
				
				if(document.name == fileInfo.name)
					emailAttachment = emailAttachment + "<li data-document-id='"+documentID+"'  data-document-size='"+ document.size+"'  data-document-name='"+ document.name+"'> <label class=\"attachmentName\" style=\"text-decoration:underline; cursor: pointer\" onclick=\"downloadLinkedFile('"+ documentID + "')\"><strong style=\"color:#15c;\">"+document.name+"</strong><strong style=\"color:#777;\"> ("+Math.ceil((document.size)/1024)+"K) </strong></label></li>";
			});
			
		});
		
		if(emailAttachment != '')
		{
			emailAttachment = "<div class=\"outboundemail_attachment\"><p><b>" + Object.keys(_private._mailInformation.attachments).length + " Attachments</b></p><ul class=\"emailAttachment\">" + emailAttachment+"</ul></div>";
			historyComments = historyComments + emailAttachment;
		}
		    history.departmentID = sandbox.cache.get("selectedDepartmentID");
			history.historyComments = historyComments;
			history.type = 'outboundemail';
			history.ownerID = sandbox.cache.get("loggedInUserID");
			history.ownerName = sandbox.cache.get("loggedInUserName");
			history.entityType = _private._mailInformation.entityType;
			history.taskID = _private._mailInformation.entityID;
			history.taskComments = _private._taskObj.comments;
			history.resolutionComments = _private._mailInformation.subject;
			
			sandbox.ajax.requestDCM({url:"/services/data/v2.0/objects/History/insertHistory?apikey="+accountID, method:"POST", endpoint: "/insertHistory", data:history , callBack : _private.historyForMailOperation});
	},
	
	historyForMailOperation : function(response){
		sandbox.publish("add-history",{ entityType : _private._mailInformation.entityType, entityID : _private._mailInformation.entityID, history : response.history});
	},
	
	moveTask : function(map){
		
		var accountID = (!!map.formData && !!map.formData[0])? map.formData[0].value:null, data = {};
		
		if(!accountID){
			sandbox.alert.message({text:"Please choose an account", time: 3000});
			return;
		}
		else if(_private._taskObj.linkedAccount == accountID){
			sandbox.alert.message({text:"Cannot move to the same account it's already linked to.", time: 3000});
			return;
		}

		data["taskID"] = _private._taskObj.id;		
		data["accountsID"] = accountID;

		sandbox.alert.message({text:"Moving task..."});
		sandbox.ajax.request({url:"/moveTaskToExistingAccount", data:data, endpoint:"/moveTaskToExistingAccount", callBack: _private.moveTask_Callback, method:"POST"});
		
	},
	
	moveTask_Callback : function(result){
		
		var oldLinkedAccount = _private._taskObj.linkedAccount,
			oldLinkedDeal = _private._taskObj.linkedDeal,
			accountsCache = sandbox.cache.get("accounts"),
			dealsCache = sandbox.cache.get("deals"),
			contactsCache = sandbox.cache.get("contacts"),
			account,deal,contact,index,oldAccountURL, newAccountURL, historyComments,
			userName = sandbox.cache.get("loggedInUserName"),
			staticContentURL = sandbox.cache.get("staticContentURL");

		sandbox.publish("otherTasks-display",{task: result.task});
		_private.refreshHeader(result);
		sandbox.alert.hideMessage();
		sandbox.publish("hide-custom-popup");
		sandbox.publish("task-updated",{id:_private._taskObj.id, obj:result.task});
		
		_private.getAccountCallBack(result);
		
		sandbox.publish("taskAccountNumbers-fetch",{account: result.account, task: result.task});

		sandbox.publish("account-updated",{id: result.account.id, obj: result.account});
		
		if(accountsCache.hasOwnProperty(oldLinkedAccount)){
			account = accountsCache[oldLinkedAccount];
			index = account.linkedTasks.indexOf(_private._taskObj.id);
			if(index != -1){
				account.linkedTasks.splice(index,1);
				sandbox.publish("account-updated",{id: oldLinkedAccount, obj: account});
			}
		}
		if(dealsCache.hasOwnProperty(oldLinkedDeal)){
			deal = dealsCache[oldLinkedDeal];
			index = deal.linkedTasks.indexOf(_private._taskObj.id);
			if(index != -1){
				deal.linkedTasks.splice(index,1);
				sandbox.publish("deal-updated",{id: oldLinkedDeal, obj: deal});
			}
		}
		if(!sandbox.util.isEmptyObject(result.contact)){
			sandbox.dom.each(result.contact, function(contactID, value){
				if(contactsCache.hasOwnProperty(contactID)){
					contact = contactsCache[contactID];
					index = contact.linkedTasks.indexOf(_private._taskObj.id);
					if(index != -1){
						contact.linkedTasks.splice(index,1);
						contactsCache[contactID] = contact;
					}
				}
			});
		}
		
		//Update linked header
		_private.setLinkedHeaderInDom({account:result.account});
		
		oldAccountURL = staticContentURL+"/crm#account/"+oldLinkedAccount;
		newAccountURL = staticContentURL+"/crm#account/"+result.account.id;
		
		historyComments = userName+' Moved The Task To New Account<br/><br/><b style="color:#0084b0;">Old Account :</b> <a href="'+oldAccountURL
							+'" target="_blank">'+oldAccountURL+'</a> <br/><b style="color:#0084b0;">New Account :</b> <a href="'+newAccountURL+'" target="_blank">'+newAccountURL+'</a> <br/>';
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _private._taskObj.id, historyComments : historyComments});
	},
	
	initTokenField : function(){
		
		var tagsMap = sandbox.cache.get("tags"), linkedTagNames=[];

		if(!!_private._taskObj && !sandbox.util.isEmptyObject(_private._taskObj.linkedTags)){
			_private._taskObj.linkedTags.map(function(tagID){
				if(tagsMap.hasOwnProperty(tagID))
					linkedTagNames.push(tagsMap[tagID].name);
			});
		}

		_private._tagsTokenField.off().tokenfield("destroy").on("tokenfield:createtoken", function(e){
			
			var existingTokens = $(this).tokenfield('getTokens');
			
			
			if(sandbox.util.containsSpecialChars(e.attrs.value)){
				e.preventDefault();
				sandbox.alert.message({text:"Tag name contains invalid character", type: "warning", time : 3000});
				return;
			}
			
		    sandbox.dom.each(existingTokens, function(index, token) {
		        if (token.value === e.attrs.value)
		            e.preventDefault();
		    });
		    
	    	return _private.updateTags("create", e.attrs.value);
	    }).on("tokenfield:removetoken", function(e){
	    	return _private.updateTags("remove",e.attrs.value);
	    }).tokenfield({
	    	allowEditing: false,  
	    	autocomplete: {source:_private._allTagNames, delay: 100}
	    }).tokenfield("setTokens",linkedTagNames);
		
	},
	
	updateTags : function(operation, value){
		
		//tokenfield:createtoken event is fired on page load sometimes
		if(sandbox.util.isEmptyObject(_private._taskObj))
			return false;
		
		var tagsCache = sandbox.cache.get("tags"),
			linkedTags = _private._taskObj.linkedTags,
			isTagFound = false, data = {}, removedTagID,
			accountID = sandbox.cache.get("accountID"),
			tagsInView = _private._tagsTokenField.tokenfield("getTokensList");
		
		try{
			tagsInView = tagsInView.split(", ");
		}catch(e){
				//TODO: this isn't an actual script error check later.
				//	e.moduleName = sandbox.moduleName;
				//	e.methodName = arguments.callee.toString();
				//	sandbox.publish("send-scripterror-email", e);
		}
		
		if(!(tagsInView instanceof Array))
			return true;

		if(!(value = sandbox.dom.trim(value)))
			return false;
		
		if(!sandbox.util.isEmptyObject(linkedTags)){
			sandbox.dom.each(linkedTags, function(i, tagID){
				if(tagsCache.hasOwnProperty(tagID) && tagsCache[tagID].name == value){
					removedTagID = tagID;
					isTagFound = true;
					 return false;	
				}
			});
		}
		
		if(operation == "create"){
			
			if(isTagFound){
				if(tagsInView.indexOf(value) == -1)//ignoring because this event is triggered while loading values on page
					return true;
				sandbox.alert.message({text:"Tag already present", time:3000});
				return false;
			}

			if(_private._tagToBeCreated == value)//to prevent duplicates
				return false;
			else{
				_private._tagToBeCreated = value;
				setTimeout(function(){_private._tagToBeCreated=null;}, 5000);
				data["tags"] = [value];
			}
		}
		else if(operation == "remove"){
			if(!removedTagID)
				return false;
			data["removetags"] = [removedTagID];
		}
		
		data["operation"] = "update";

		sandbox.alert.message({text:"Updating task..."});
		sandbox.ajax.request({url:"/updateATask/"+_private._taskObj.id+"?apikey="+accountID+"&isLoggedIn=true",data:data, endpoint:"/updateATask", callBack: _private.updateTags_Callback,method:"PUT"});
		return true;
	},
	
	updateTags_Callback : function(resultObject){
		
		var userName = sandbox.cache.get("loggedInUserName"),
			historyComments, tagName, operation = "Removed",
			oldLinkedTags = _private._taskObj.linkedTags,
			tagsCache = sandbox.cache.get("tags");
		
		_private._taskObj = resultObject["task"];
		sandbox.publish("task-updated",{id:_private._taskObj.id, obj:_private._taskObj});
		sandbox.alert.hideMessage();
		_private.displayTaskHeader();
		_private._tagToBeCreated = null;

		if(resultObject.hasOwnProperty("tag")){
			
			sandbox.publish("tags-created", resultObject.tag);
			operation ="Added";
			sandbox.dom.each(Object.keys(resultObject.tag),function(i, tagID){
				tagName = resultObject.tag[tagID].name;
				return false;
			});
		}
		else{
			sandbox.dom.each(oldLinkedTags, function(i,tagID){
				if(_private._taskObj.linkedTags.indexOf(tagID) == -1){
					tagName = tagsCache[tagID].name;
					return false;
				}
			});
		}

		historyComments = userName+' '+operation+' a Tag<br/><br/><b style="color:#0084b0;">Name :</b> '+tagName+'<br/><b style="color:#0084b0;">Task ID:</b> '+_private._taskObj.id+'<br/>';
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _private._taskObj.id, historyComments : historyComments});
	},
	
	updateAllTagNames : function(tagsCache){
		_private._allTagNames=[];
		tagsCache = sandbox.util.filterByDepartmentID(tagsCache);
		sandbox.dom.each(tagsCache, function(tagID, tag){
			_private._allTagNames.push(tag.name);
		});
		_private.initTokenField();
	},
	
	setLinkedHeaderInDom : function(data){
		
		var entity = Object.keys(data)[0]; 
		
		sandbox.dom('.taskheader').addClass('childtask');
		sandbox.dom('.taskheader .ellipsis').html(data[entity]['name']).attr("href", "#"+entity+"/"+data[entity]['id']);
		sandbox.dom('.taskheader .ellipsis').css("display","block");
	}
	
};

		
		var api = {
		
		init : function() {
			
			_self = this;
			sandbox.subscribe("display-task-info", _private.setTaskPage);
			sandbox.subscribe("taskinfo-fetch", _private.getTaskDetails);
			sandbox.subscribe("taskowner-users-fetched", _private.setUserNames);
			
			sandbox.subscribe("refresh-task-detail-header", _self.refreshHeader);
			sandbox.subscribe("taskHeader-editTask-formSubmit", _private.editTaskFormSubmit);
			sandbox.subscribe("taskHeader-moveType-formSubmit", _private.moveTaskType);
			sandbox.subscribe("moveTaskType-oldCustomFields-fetched", _private.moveTaskType_Callback);
			sandbox.subscribe("moveTaskType-customField-printableValues-fetched", _private.generateActivityLogForMoveType);
			sandbox.subscribe("taskHeader-moveTask-formSubmit", _private.moveTask);
		//	sandbox.subscribe("tags-cache-updated", _private.updateAllTagNames);
			sandbox.subscribe("task-updated", function(map){
				if(!!_private._taskObj && _private._taskObj.id == map.id)
					_private._taskObj = map.obj;
			});
			
			sandbox.subscribe("tags-cache-updated", function(data){
				_private._isWaitingForTags = false;
				_private.updateAllTagNames(data);
			});
			
			sandbox.subscribe("updated-tasktypes", function(data){
				
				_private._isWaitingForTaskTypes = false;
				
				if(sandbox.util.isEmptyObject(_private._waitingForTaskTypes))
					return;
				var currentHash = (!!sandbox.url.entityID()) ? "#"+sandbox.url.page()+"/"+sandbox.url.entityID() : "#"+sandbox.url.page();
				sandbox.dom.each(_private._waitingForTaskTypes, function(hash, map){
					if(currentHash == hash)
						map.func.apply(map.thisObj, map.args);
				});
				_private._waitingForTaskTypes = {};
			});
			
			sandbox.dom("#tasknotes .notes").summernote({
				callbacks:{
					onBlur : function(e)
						{
							if(sandbox.dom(e.relatedTarget).parents('.note-toolbar').length == 0)
								_private.updateTaskProperty("notes", sandbox.util.linkify(e.target.innerHTML));
						}	
				},
		    	height: 200,  
		    	toolbar: [
		    	            ['style', ['bold', 'italic', 'underline','ul', 'ol']]
		    	          ]
		    });
			
			_private.initTokenField();
			
			sandbox.dom("#task_rating").on("change", function(e){
				_private.updateTaskProperty("rating", e.target.value);
			});
			sandbox.dom("#idShareTaskDetail").on("click", function(e){
				sandbox.publish("show-custom-popup", {form : "shareurlform", text : "Share URL", isDraggableRequired: false});
			});
			sandbox.dom("#idEditTaskDetail").on("click",function(e){
				
				var data = {};
				data["text"] = "Edit task";
				data["form"] = "taskform";
				data["publish"] = "taskHeader-editTask-formSubmit";
				data["isTaskDetailEdit"] = true;
				data["confirmButton"] = "Update";
				data["operation"] = "update";
				data["entityType"] = "task";
				data["comments"] = _private._taskObj.comments;
				data["dueDateString"] = sandbox.util.formatDate(new Date(_private._taskObj.dueDate), "MM/dd/yyyy hh:mm a");
				data["isFromEditTaskDetail"] = true;
				sandbox.publish("show-custom-popup", data);
			});
			sandbox.dom("#idMoveTaskTypeDetail").on("click", function(e){
				
				var data = {};
				data["text"] = "Move Task Type";
				data["form"] = "movetasktypeform";
				data["popupGroupsList"] = true;
				data["publish"] = "taskHeader-moveType-formSubmit";
				data["confirmButton"] = "Move Type";
				data["entityType"] = "task";
				data["task"] = JSON.parse(JSON.stringify(_private._taskObj));
				data['isDraggableRequired'] = true;
				sandbox.publish("show-custom-popup", data);
				sandbox.dom(".popupGroupsList button.dropdown-toggle").focus();
			});
			sandbox.dom("#idDeleteTaskDetail").on("click", _private.deleteTask);

			sandbox.dom("#idSendMailTaskDetail").on("click", function(event){
				sandbox.publish("show-email-popup", { 
						entityType : "task", 
						entityID : _private._taskObj.id, 
						"email-type" : "reply",
						//taskGroupsAsUsers : true,
						moduleName : sandbox.moduleName,
						subject : "Re: " + _private._taskObj.comments
			  });
			});
			
			sandbox.subscribe( sandbox.moduleName + "-email-sent", _private.changeStatusAfterSendMail);//taskDetailHeader-email-sent
			
			sandbox.dom("#idMoveTaskDetail").on("click", function(e){
				var data = {};
				data["form"] = "movetaskform";
				data["text"] = "Move Task";
				data["confirmButton"] = "Move Task";
				data["publish"] = "taskHeader-moveTask-formSubmit";
				data["openAccountSearch"] = true;
				data["linkedAccountID"] = _private._taskObj.linkedAccount;
				sandbox.publish("show-custom-popup", data);
			});
			sandbox.dom("#idAddTaskTaskDetail").on("click", function(e){
				
				var data = {};
				data["text"] = "Add Task";
				data["form"] = "taskform";
				data["publish"] = "new-task-create";
				//data["evaluateTags"] = evaluateNewTaskTags;
				data["selectUser"] = sandbox.cache.get("loggedInUserID");
				data["popupGroupsList"] = true;
				data["popupContactMethodList"] = false;
				data["confirmButton"] = "Add";
				data["entityType"] = "task";
				data["taskGroupsAsUsers"] = true;
				data["excludeGroups"] = [sandbox.cache.get("salesGroupID")];
				data['isNotesNeeded'] = true;
				sandbox.publish("show-custom-popup", data);
			});
			
			sandbox.dom("#idAddSubscriberInMenuTaskDetail").on("click", function(e){
				var data = {};
				data["form"] = "subscriberform";
				data["text"] = "Add Subscriber";
				data["publish"] = "taskActions-addSubscriber-formSubmit";
				data["confirmButton"] = "Add";
				data["taskGroupsAsUsers"] = true;
				data["excludeGroups"] = [sandbox.cache.get("salesGroupID")];
				data["openUsersSearch"] = true;  
				sandbox.publish("show-custom-popup", data);
			});
		},
		
		destroy : function() {
			sandbox.unsubscribe();
		},
		
		refreshHeader : function(data) {			
			_private.refreshHeader(data);			
		}
	};
		
	    /* Exposing private methods for test suites - START */

	    api._private = _private;

	    /* Exposing private methods for test suites - END */

	    return  api; 
	
});

DSCRM.Core.registerModule("taskAssignee",["url","cache","alert","util","ajax"] ,function(sandbox) {
	
	var _taskObj, _taskInfo;

	var changeTaskAssignee = function(data){
		
		var task, isTicketingSystemEnabled = sandbox.util.getFeatureAvailablityStatus("ticketingSystem"),
			oldAssignee, historyComments, oldDepartment, newAssignee, tempTaskObj, oldDepartmentID, removeSubscriberStr="";

		if(data.hasOwnProperty("status")){
			
			oldAssignee= _taskObj.assigneeID;
			oldDepartment = _taskObj.department;
			oldDepartmentID = _taskObj.departmentID;
			
			if(!!data.task.assigneeID && !!_taskObj.linkedSubscribers && _taskObj.linkedSubscribers.indexOf(data.task.assigneeID) != -1){
				newAssignee = sandbox.cache.getUser(data.task.assigneeID).name;
				removeSubscriberStr = '</br><b style="color:#0084b0;">Removed Subscriber :</b> '+newAssignee;	
			}

			_taskObj = task = data.task;
			
			if(oldDepartmentID != task.departmentID) //to change department if needed
				sandbox.publish("display-task-info",{id:task.id, taskObj: task, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: false, fetchContacts:false,fetchOtherTasks:false}});
			else
				sandbox.publish("refresh-task-detail-header", {task: task});//this will publish task-updated

			sandbox.alert.hideMessage();

			if(!!oldAssignee){
				oldAssignee= sandbox.cache.getUser(oldAssignee);
				if(!!oldAssignee)
					oldAssignee = oldAssignee.name;
				else
					oldAssignee = "Unknown";
			}
			else if(!oldAssignee && !!oldDepartment)
				oldAssignee = sandbox.cache.getUser(oldDepartment).name;
			else
				oldAssignee = "Unknown";
			
			if(!!task.assigneeID)
				newAssignee= sandbox.cache.getUser(task.assigneeID).name;
			else if(!task.assigneeID)
				newAssignee = sandbox.cache.getUser(task.department).name;

			historyComments=sandbox.cache.get("loggedInUserName")+' Reassigned the task<br/><br/><b style="color:#0084b0;">Old Assignee :</b> '+
							oldAssignee+'</br><b style="color:#0084b0;">New Assignee :</b> '+newAssignee+ removeSubscriberStr;
			sandbox.publish("insert-activity-log", { entityType : "task", entityID : task.id, historyComments : historyComments});

			if(!!removeSubscriberStr)
				sandbox.publish("taskActions-display-subscribers",{});

			sandbox.publish("update-analytics",{category:"Update",action:"Task-Reassign"});
			
			return;
		}

		var assigneeID = data.formData[0].value, updateMap ={}, map={},
			assignee= sandbox.cache.getUser(assigneeID), obj={},
			userDefaultGroupID = sandbox.cache.get("userDefaultGroupID"),
			loggedInUserID = sandbox.cache.get("loggedInUserID");

		if(!_taskObj.assigneeID && isTicketingSystemEnabled && _taskObj.department == assigneeID){
			sandbox.alert.message({text : "Cannot re-assign to current assignee again.", time: 3000});
			return;
		}
		else if(!!_taskObj.assigneeID && _taskObj.assigneeID == assigneeID){
			sandbox.alert.message({text : "Cannot re-assign to current assignee again.", time: 3000});
			return;
		}
		else if(!assigneeID){
			sandbox.alert.message({text : "Please choose an assignee.", time: 3000});
			return;
		}
		
		if(assignee.isGroup)
			assigneeID = null;
		
		obj = JSON.parse(JSON.stringify(_taskObj));
		
		obj["assigneeID"] = map["assigneeID"] = assigneeID;
		map["department"] = assignee.defaultGroupID;
		map["departmentID"] = assignee.defaultDepartmentID;
		map["operation"] = "reassign";
		map["userDepartment"] = userDefaultGroupID;

		if(!_taskInfo && assigneeID != loggedInUserID){
			
			data["obj"] = obj;
			data["publish"] = "task-assignee-entityInfo-fetched";
			sandbox.publish("taskinfo-fetch", data);
			return;
		}
		else if(!sandbox.util.isEmptyObject(_taskInfo)){
		
			_taskInfo['operation'] = 'reassign';
			_taskInfo['taskassigneemail'] = true;
			map["taskinfo"] = _taskInfo;
		}
		/*linkedSubscribers = taskFrmCache['linkedSubscribers'];
		var mapOfData = {};		
		mapOfData['reassigneeID'] =  reassigneeID;
		mapOfData['oldAssigneeID'] = assigneeID;
		
		
		 if(!$.isEmptyObject(linkedSubscribers)) {
			if(linkedSubscribers.indexOf(reassigneeID) > -1)
				mapOfData['removeSubscriber'] = reassigneeID;
		}
		
		activityLog = pullActivityLogForReassign(mapOfData);
		
		tempCacheObj = DSCRM.GlobalObjectCache.getInstance().tempCacheObj;
		tempCacheObj['activityLog'] = activityLog;*/
		
		sandbox.publish("hide-custom-popup");

		sandbox.ajax.request({method: "PUT", url:"/updateATask/"+_taskObj.id+"?apikey="+sandbox.cache.get("accountID")+"&isLoggedIn=true", endpoint:"/updateATask", data: map, callBack: changeTaskAssignee});
		sandbox.alert.message({text: "Re-assigning task..."});
		
		tempTaskObj = JSON.parse(JSON.stringify(_taskObj));
		tempTaskObj["assigneeID"] = assigneeID;
		tempTaskObj["department"] =  assignee.defaultGroupID;
		/*tempTaskObj["departmentID"] = assignee.defaultDepartmentID;
		tempTaskObj["lastUpdatedDate"] = new Date().getTime();
		sandbox.publish("display-task-info",{id:tempTaskObj.id, taskObj: tempTaskObj, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});*/
		displayAssignee({task: tempTaskObj});
	},
	
	displayAssignee = function(data){
		
		var user, isTicketingSystemEnabled = sandbox.util.getFeatureAvailablityStatus("ticketingSystem"),
			loggedInUserID = sandbox.cache.get("loggedInUserID"), assigneeID,
			task = data.task;
		
		//_taskObj = data.task; _taskInfo = null;
		assigneeID = task.assigneeID;

		if(!task.assigneeID && (!isTicketingSystemEnabled || !task.department)){
			data.users = {}; assigneeID = null;
			data.users[null] = {"name" : "Unassigned"};
		}
		else if(!task.assigneeID && isTicketingSystemEnabled){
			data.users = {}; assigneeID = null;
			data.users[null] = {"name" : sandbox.cache.get("groups")[task.department].name, photoID: "../images/groupuser_frame.png"};
		}
		else if(!!assigneeID){
			user = sandbox.cache.getUser(assigneeID);
			if(!user && sandbox.cache.get("isAllUsersFetched")){
				data.users = {};
				data.users[assigneeID] = {"name" : "No Assignee"};
			}
			else if(!!user){
				data.users = {};
				data.users[assigneeID] = user;
			}
		}
			
		if(!data.hasOwnProperty("users")){
			//_dealObj = data.deal;
			data["parentDOMID"] = "taskassignee";
			data["selectedContactID"] = [task.assigneeID];
			sandbox.publish("users-selected-fetch", data);
			return;
		}

		if(data.users.hasOwnProperty(assigneeID))
			user = data.users[assigneeID];
		
		if(!user)
			user = {name :"No Assignee"};
		
		sandbox.dom(".owner_dtl_placeholder").remove();
		sandbox.dom(".owner_dtl").removeClass("hide");
		
		sandbox.dom(".taskAssigneeLabel").html(user.name);
		if(!!user.photoID)
			sandbox.dom(".taskAssigneePhoto").attr("src", user.photoID);
		else
			sandbox.dom(".taskAssigneePhoto").attr("src", "../images/person_frame.png");
		
		if(loggedInUserID == task.assigneeID)
			sandbox.dom("#taskDetail .icon-1change-user").addClass("hide");
		else
			sandbox.dom("#taskDetail .icon-1change-user").removeClass("hide");
	};

	return {
		
		init : function() {

			sandbox.dom(".taskAssigneeA").on("click", function(e){
				var assigneeID=_taskObj.assigneeID,
					isTicketingSystemEnabled = sandbox.util.getFeatureAvailablityStatus("ticketingSystem");
				if(!assigneeID && isTicketingSystemEnabled)
					assigneeID = _taskObj.department;
				sandbox.publish("show-custom-popup",
						{
							text : "Choose Assignee", 
							form : "taskreassignform", 
							publish:"task-assignee-change", 
							selectUser : assigneeID, 
							confirmButton:"Assign" , 
							taskGroupsAsUsers : true ,
							excludeGroups : [sandbox.cache.get("salesGroupID")],
							openUsersSearch : true
						});
			});
			
			sandbox.dom("#taskDetail").on("click",".icon-1change-user", function(e){
				changeTaskAssignee({formData: [{"name":"assigneeID","value":sandbox.cache.get("loggedInUserID")}]});
			});
			
			sandbox.subscribe("task-assignee-change", changeTaskAssignee);
			sandbox.subscribe("task-detail-display", function(data){
				_taskObj = data.task; _taskInfo = null;
				displayAssignee(data);
			});
			sandbox.subscribe("taskassignee-users-fetched", function(data){
				_taskObj = data.task; _taskInfo = null;
				displayAssignee(data);
			});
			sandbox.subscribe("task-assignee-entityInfo-fetched", function(data){
				_taskInfo = data.entityInfo;
				changeTaskAssignee(data);
			});
			sandbox.subscribe("task-updated", function(map){
				if(!!_taskObj && _taskObj.id == map.id)
					_taskObj = map.obj;
			});
		}
	};
});

DSCRM.Core.registerModule("taskActionsDetail",["url","cache","alert","util","ajax"] ,function(sandbox) {
	
	var _self = null, _taskObj, _account = null, _currentSubscriberBeingUpdated,
		_searchExistingContactBtn, _existingContactsListEl,
		_releaseOnHoldBtn = ".conCtaList .taskDetailUnholdBt", 
		_putOnHoldBtn = "#taskDetailOnholdBt", 
		_addSubsBtn = "#taskDetailAddSubscriberBt", 
		_resolvReopenBtn = "#taskDetailResolveReopenBt",
		_subscriberListID = "#idTaskDetailSubscriberList"; 

	var resetTaskActions = function(map){
		
		if(map.hasOwnProperty("id") && !!_taskObj && map.id == _taskObj.id)
			return;
		
		sandbox.dom(_resolvReopenBtn).addClass("hide").tooltip("hide");
		sandbox.dom(_putOnHoldBtn).addClass("hide").tooltip("hide");
		sandbox.dom(_releaseOnHoldBtn).addClass("hide").tooltip("hide");
		sandbox.dom(_addSubsBtn).parent().addClass("hide");
		_searchExistingContactBtn.addClass("hide");
	},
	
	displayActions = function(map){
		
		_taskObj = map.task;
		
		var isSubscriberButtonNeeded = (!!_taskObj.linkedSubscribers && _taskObj.linkedSubscribers.length > 0) 
										&& ["completed","deleted"].indexOf(_taskObj.status) == -1;
		
		if(isSubscriberButtonNeeded)
			sandbox.dom(_addSubsBtn).parent().removeClass("hide");
		else
			sandbox.dom(_addSubsBtn).parent().addClass("hide");
		
		sandbox.dom(_putOnHoldBtn).addClass("hide");
		sandbox.dom(_releaseOnHoldBtn).addClass("hide");
		_searchExistingContactBtn.addClass("hide");
			
		switch(_taskObj.status){
			case "pending": case "replied": case "unread":{
				sandbox.dom(_resolvReopenBtn).attr("data-original-title","Resolve").html("<i class='icon-checkmark4'></i>").removeClass("hide").tooltip("hide");
				sandbox.dom(_putOnHoldBtn).removeClass("hide");
				_searchExistingContactBtn.removeClass("hide");
			}break;
			case "completed":{
				sandbox.dom(_resolvReopenBtn).attr("data-original-title","Reopen").html("<i class='glyphicon glyphicon-folder-open''></i>").removeClass("hide").tooltip("hide");
			}break;
			case "deleted":{
				sandbox.dom(_resolvReopenBtn).attr("data-original-title","Restore").html("<i class='glyphicon glyphicon-folder-open''></i>").removeClass("hide").tooltip("hide");
			}break;
			case "onhold":{
				sandbox.dom(_resolvReopenBtn).attr("data-original-title","Resolve").html("<i class='icon-checkmark4'></i>").removeClass("hide").tooltip("hide");
				sandbox.dom(_releaseOnHoldBtn).removeClass("hide");
				_searchExistingContactBtn.removeClass("hide");
			}break;
		}
		
		displaySubscribers();
	},
	
	showResolveTaskPopup = function(e){
		
		var groups = ["0abcfb41-d89d-496f-b397-df31eee51c0d", "abe1d2ae-6834-49b6-a017-84233249f4c1", "53ad3901-03dc-4e68-a9ec-d8f8d2b8e6e4",
		              "21245faf-d3cd-4167-9f89-549406e214fd", "681fa431-115a-46c2-809c-73b318932475"],
		    groupID = _taskObj["department"],
		    data = {},
		    lexReceptionProductID = "b80d69bd-c236-4aff-82d8-1675f087c8d7";

		if(!_taskObj["assigneeID"]) {
			sandbox.alert.dialog({text:"The task should be assigned to yourself before resolving.", type:"ok"});
			return;
		}
		
		if( !_taskObj["linkedAccount"] && !_taskObj["linkedDeal"] && groups.indexOf(groupID) != -1 && lexReceptionProductID != _taskObj["productID"]) {

			sandbox.alert.dialog({text:"Please attach the task to the client\'s account before resolving. Thank you!", type:"ok"});
			return;
		}
		
		//var actionTypeMap = {"Call" : ["Contacted", "Not Contacted"], "Email":["Sent"], "To-do":["Completed"]}; 
		//data["actionSelectOptions"] =actionTypeMap[task.taskTypeName];
		data["form"] = "taskresolveform";
		data["publish"] = "task-detail-resolve";
		//data["cancel"] = "task-detail-resolve-cancel";
		data["text"] = "1 task marked for completion";
		data["confirmButton"] = "Resolve";
		data["task"] = _taskObj;
		sandbox.publish("show-custom-popup", data);
	},
	
	resolveTask = function(map){

		var resolutionComments = map.formData[0].value, userId, userName,
			ownerID, ownerName, taskObj = {}, mapArDetail = {},
			assigneeDetails, ownerDetails, linkedSubscribers = [], subscriberDetails, 
			listSubscriberEmail = [], historyObj={}, linkedTags = [], listTagNames = [], 
			tagsCache, historyComments, historyObj, calltype = '', connid = '',
			accountID = sandbox.cache.get("accountID");
		
		taskObj["comments"] = _taskObj["comments"];
		userId = taskObj["userID"] = sandbox.cache.get("loggedInUserID");
		userName = taskObj["userName"] = sandbox.cache.get("loggedInUserName");
		taskObj["userEmail"] = sandbox.cache.get("loggedInUserEmail");
		
		assigneeDetails = sandbox.cache.getUser(_taskObj["assigneeID"]);
		taskObj["assigneeName"] = assigneeDetails.name;
		taskObj["assigneeEmail"] = assigneeDetails.email;
		
		ownerID = _taskObj["ownerID"];
		ownerDetails = sandbox.cache.getUser(ownerID);
		
		if(!!ownerDetails){
			if(!!ownerDetails.name)
				taskObj["ownerName"] = ownerDetails.name;
			if(!!ownerDetails.email)
				taskObj["ownerEmail"] = ownerDetails.email;		
		}
		
		//mapArDetail = DSCRM.GlobalObjectCache.getInstance().arDetailMap;

		if(!!resolutionComments) {
			
			resolutionComments = sandbox.util.linkify(resolutionComments);
			taskObj["resolutionComments"] = resolutionComments;

		 	if(!sandbox.util.isEmptyObject(_taskObj["linkedContacts"]))
		 		historyObj['linkedContacts'] = [_taskObj["linkedContacts"][0]];

		 	if( !!_taskObj["linkedAccount"] )
		 		historyObj["linkedAccounts"] = [_taskObj["linkedAccount"]];
		 	else if( !!_taskObj["linkedDeal"] )
		 		historyObj["linkedDeals"] = [_taskObj["linkedDeal"]];
		 	
		 	historyObj["historyComments"] = "";
		 	historyObj["resolutionComments"] = resolutionComments;
		 	historyObj["ownerName"] = userName;
		 	historyObj["taskID"] = _taskObj.id;
		 	historyObj["typeID"] = "76229b91-2197-4f76-b10c-47ca1b6e8e44";
		 	historyObj["departmentID"] = sandbox.cache.get("selectedDepartmentID");
		 	historyObj["taskComments"] = _taskObj.comments; 	
		 	
		 	//historyObj = constructHistoryForCORSRequest( historyObj );
		 	historyObj["entityType"] ="task";
		 	historyObj["type"] = "complete";
		 	historyObj["ownerID"] = userId;
		 	
		 	historyObj["AccountPIN"] = accountID;
		 	historyObj["peopleId"] = userId;
			
			taskObj["history"] = historyObj;
		}

		linkedSubscribers = _taskObj["linkedSubscribers"];
		
		if(!sandbox.util.isEmptyObject(linkedSubscribers)) {			
			sandbox.dom.each(linkedSubscribers,function(index,value){
				subscriberDetails = sandbox.cache.getUser(value);
			
				if(!sandbox.util.isEmptyObject(subscriberDetails))
					listSubscriberEmail.push(subscriberDetails[1]);
				
				taskObj["subscribers"] = listSubscriberEmail;
			});
		}

		linkedTags = _taskObj["linkedTags"];
		//TODO: check for hasOwnProp to check for deleted tags
		if(!sandbox.util.isEmptyObject(linkedTags)){
			tagsCache = sandbox.cache.get("tags");
			linkedTags.map(function(tagID){
				listTagNames.push(tagsCache[tagID].name);
			});
			taskObj["tags"] = listTagNames;
		}

		taskObj["operation"] = "resolve";
		taskObj["resolve"] = _taskObj.id;
					
		calltype = sandbox.util.getARURLParameter("calltype");
		connid = sandbox.util.getARURLParameter("connectionid");

		sandbox.alert.message({text:"Resolving Task..."});
			
		sandbox.ajax.request({url: "/resolveTask/"+_taskObj.id+"?apikey="+accountID+"&calltype="+calltype+"&connectionID="+connid, endpoint:"/resolveTask", data:taskObj, callBack:resolveTaskCallBack, method:"PUT"});
		sandbox.publish("hide-custom-popup");
	},
	
	resolveTaskCallBack = function(resultObject){
		
		var taskId, taskObjFrmDb = {}, mapOfHistory = {}, historyComments,
			groupID = sandbox.cache.get("userDefaultGroupID"),
			selectedDepartmentID = sandbox.cache.get("selectedDepartmentID"),
			mapGroups = sandbox.cache.get("groups"),
			userName = sandbox.cache.get("loggedInUserName"),
			itGroupID = sandbox.cache.get("itGroupID"),
			salesGroupID = sandbox.cache.get("salesGroupID");

		 taskObjFrmDb = _taskObj = resultObject["task"];
		mapOfHistory = resultObject["history"];
		
		if(!!mapOfHistory)
		mapOfHistory['createdDate'] = new Date();
		
		if(resultObject.success)	
			sandbox.publish("add-history",{ entityID : resultObject.task.id , entityType : "task", history : mapOfHistory});
			

		
		taskId = taskObjFrmDb.id;
		sandbox.publish("task-updated",{id: taskId, obj:taskObjFrmDb});

		sandbox.publish("display-task-info",{id:taskId, taskObj: taskObjFrmDb, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
		
		historyComments = userName+' Resolved a task<br/><br/><b style="color:#0084b0;">TaskID :</b> '+taskId+'<br/>';
		if(!!mapOfHistory && !!mapOfHistory.resolutionComments)
			historyComments+='<br/><b style="color:#0084b0;">ResolutionComments :</b> '+mapOfHistory.resolutionComments+'<br/>';
		
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : taskId, historyComments : historyComments});
		sandbox.alert.hideMessage();
		sandbox.publish("mail-task-operations",{taskObj: taskObjFrmDb, activity:"resolved the task."});
		sandbox.publish("update-analytics", {category: "Other Task Events", action: "Task"});
		
	},
	
	reopenTask = function(map){
		
		var placeholder = sandbox.dom(_resolvReopenBtn).attr("data-original-title");
			placeholder = placeholder.substr(0, 1).toLowerCase() + placeholder.substr(1);
		
		if(!map.hasOwnProperty("isConfirmed")){
			sandbox.alert.dialog({text:"Are you sure you'd like to "+placeholder+" this task?", confirm: reopenTask, data:{isConfirmed:true}});
			return;
		}
		if(!map.hasOwnProperty("entityInfo")){
			sandbox.publish("taskinfo-fetch",{obj: _taskObj, publish:"taskActions-taskinfo-fetched", isConfirmed:true});
			return;
		}
		
		var data = {};
		data["taskinfo"] = map.entityInfo;
		data["operation"] = "reopen";

		sandbox.ajax.request({url: "/restoreTask?taskID="+_taskObj.id, endpoint:"/restoreTask", data: data, callBack: reopenTaskCallBack, method:"POST"});
		sandbox.alert.message({text:"Updating..."});
	},
	
	reopenTaskCallBack = function(resultObject){
		
		sandbox.alert.hideMessage();
		
		var userName = sandbox.cache.get("loggedInUserName"),
			historyComments;
		
		_taskObj = resultObject.task;
		
		sandbox.publish("task-updated",{id: _taskObj.id, obj:_taskObj});
		sandbox.publish("display-task-info",{id:_taskObj.id, taskObj: _taskObj, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
		
		historyComments = userName+' Reopened the task<br/><b style="color:#0084b0;">Task ID:</b> '+_taskObj.id+'<br/>';
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _taskObj.id, historyComments : historyComments});
		sandbox.publish("mail-task-operations",{taskObj: _taskObj, activity:"reopened the task."});
	},
	
	putTaskOnHold = function(e){
		sandbox.dom(_putOnHoldBtn).tooltip("hide");
		var loginPersonId = sandbox.cache.get("loggedInUserID"),
			accountID = sandbox.cache.get("accountID"),
			data = {}, metaDataForJS = {status: "onhold"};

		if(loginPersonId != _taskObj.assigneeID) {
			sandbox.alert.dialog({text:"Please reassign the task to yourself before putting On Hold", type:"ok"});
			return;
		}
		
		data["status"] = "onhold";
		data["operation"] = "update";

		sandbox.alert.message({text:"Updating Task..."});
		sandbox.ajax.request({url: "/updateATask/"+_taskObj.id+"?apikey="+accountID+"&isLoggedIn="+true, endpoint:"/updateATask", data:data, callBack: updateTaskStatusCallback,method:"PUT", metaDataForJS:metaDataForJS});
	},
	
	updateTaskStatusCallback = function(resultObject){
		
		var userName = sandbox.cache.get("loggedInUserName"), historyComments,
			metaDataForJS = resultObject.metaDataForJS;
		
		_taskObj = resultObject.task;

		sandbox.publish("task-updated",{id: _taskObj.id, obj:_taskObj});
		sandbox.publish("display-task-info",{id:_taskObj.id, taskObj: _taskObj, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
		sandbox.alert.hideMessage();
		
		historyComments = userName+' Edited a task<br/></br><b style="color:#0084b0;">TaskID :</b> '+_taskObj.id+'<br/><br/>Edited Task Details :<br/><br/><b style="color:#0084b0;">Status :</b> '+metaDataForJS.status+'<br/>';
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _taskObj.id, historyComments : historyComments});

		sandbox.publish("update-analytics", { category: "Edit", action: "Task"});
	},
	
	releaseOnHoldTask = function(e){
		sandbox.dom(_releaseOnHoldBtn).tooltip("hide");
		var data = {}, metaDataForJS = {status: "pending"},
			accountID = sandbox.cache.get("accountID");
		
		data["status"] = "pending";
		data["operation"] = "update";

		sandbox.alert.message({text:"Updating Task..."});
		sandbox.ajax.request({url: "/updateATask/"+_taskObj.id+"?apikey="+accountID+"&isLoggedIn="+true, endpoint:"/updateATask", data:data, callBack: updateTaskStatusCallback, method:"PUT", metaDataForJS:metaDataForJS});
	},
	
	displaySubscribers = function(){
	
		sandbox.dom(_subscriberListID).addClass("hide").find(".subscribedUserDiv").remove();
		var listID = _taskObj.linkedSubscribers, data = {},
			user, userList = [], usersToFetch = [], userTemplate,
			isAllUsersFetched = sandbox.cache.get("isAllUsersFetched");
		
		if(sandbox.util.isEmptyObject(listID))
			return;

		listID.map(function(userID){
			user = sandbox.cache.getUser(userID);
			if(!!user)
				userList.push(user);
			else if(!user && isAllUsersFetched){
				userTemplate = {name: "Unknown", contactID: userID}
				userList.push(userTemplate);
			}
			else{
				usersToFetch.push(userID);
				userTemplate = {name: "Loading...", userNameNotFetched: true, contactID: userID}
				userList.push(userTemplate);
			}
		});
		
		sandbox.dom(_subscriberListID).append(dscrm.templates.tasks.subscriberList({list: userList}));
		sandbox.dom(_subscriberListID).removeClass("hide");
		
		if(usersToFetch.length > 0) {
			data["parentDOMID"] = "taskSubscribers";
			data["selectedContactID"] = usersToFetch;
			sandbox.publish("users-selected-fetch",data);
		}
	},
	
	updateSusbcriberNames = function(map){
		
		var users = !!map.users ? map.users: {}, 
			userID, user,
			usersEl = sandbox.dom(_subscriberListID).find(".userNameNotFetched");
		
		
		sandbox.dom.each(usersEl, function(index, el){
			
			userID = sandbox.dom(el).data("userid");
			user = users[userID];
			if(!!user)
				sandbox.dom(el).replaceWith(dscrm.templates.tasks.subscriberList({list: [user]}));
			else
				sandbox.dom(el).find("h6").html("Unknown");
		});
	},
	
	addSubscriber = function(map){
		var userID = (!!map.formData && !!map.formData[0])? map.formData[0].value : null,
			data = {};
		
		_currentSubscriberBeingUpdated = userID;
		
		if(!userID){
			sandbox.alert.message({text:"Please choose a subscriber.", time:3000});
			return;
		}
		else if(_taskObj.ownerID == userID || _taskObj.assigneeID == userID){
			sandbox.alert.message({text:"Owner or Assignee cannot be added as a subscriber.", time:3000});
			return;
		}
		
		data = getSubscriberUpdateMap("add");
		if(!data)
			return;

		sandbox.alert.message({text:"Adding subscriber..."});
		sandbox.ajax.request({url:"/addOrRemoveSubscriberForTask", endpoint:"/addOrRemoveSubscriberForTask", data: data, method:"POST", callBack: addSubscriber_Callback});
	},
	
	addSubscriber_Callback = function(resultObject){
		
		var historyComments, user, 
			userName = sandbox.cache.get("loggedInUserName"),
			user = sandbox.cache.getUser(_currentSubscriberBeingUpdated);
		
		_taskObj = resultObject.task;

		sandbox.publish("task-updated",{id: _taskObj.id, obj:_taskObj});
		displaySubscribers();
		//sandbox.publish("display-task-info",{id:_taskObj.id, taskObj: _taskObj, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
		sandbox.alert.hideMessage();
		sandbox.publish("hide-custom-popup");
		
		//user = sandbox.cache.getUser(_currentSubscriberBeingUpdated);
		//sandbox.dom("#idTaskDetailSubscriberList").append(dscrm.templates.tasks.subscriberList({list: [user]}));
		
		historyComments = userName+' Edited a task <br/></br>Edited task details<br/><b style="color:#0084b0;">Added Subscriber :</b> '+user.name+'<br/><b style="color:#0084b0;">Task ID:</b> '+_taskObj.id+'<br/>';
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _taskObj.id, historyComments : historyComments});

		sandbox.publish("update-analytics",{category:"Create",action:"Task-Subscribers"});
		
		_currentSubscriberBeingUpdated = null;
	},
	
	removeSubscriber = function(e){
		
		var linkedSubscribers = !!_taskObj.linkedSubscribers? _taskObj.linkedSubscribers: [],
			subscriberEmails = [], user, data = {},
			subscriberID = sandbox.dom(e.target).parents(".subscribedUserDiv").data("userid");
		
		_currentSubscriberBeingUpdated = subscriberID;
		data = getSubscriberUpdateMap("remove");
		
		sandbox.alert.message({text:"Removing subscriber..."});
		sandbox.ajax.request({url:"/addOrRemoveSubscriberForTask", endpoint:"/addOrRemoveSubscriberForTask", data: data, method:"POST", callBack: removeSubscriber_Callback})
	},
	
	removeSubscriber_Callback = function(resultObject){
		
		var historyComments, 
			userName = sandbox.cache.get("loggedInUserName"),
			user = sandbox.cache.getUser(_currentSubscriberBeingUpdated);
		
		if(!user)
			user = {name:"Unknown (ID- "+_currentSubscriberBeingUpdated+")"};
		
		_taskObj = resultObject.task;
	
		sandbox.publish("task-updated",{id: _taskObj.id, obj:_taskObj});
		//sandbox.publish("display-task-info",{id:_taskObj.id, taskObj: _taskObj, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
		displaySubscribers();
		sandbox.alert.hideMessage();

		//sandbox.dom("#idTaskDetailSubscriberList .subscriber_"+_currentSubscriberBeingUpdated).remove();
		
		historyComments = userName+' Edited a task <br/></br>Edited task details<br/><b style="color:#0084b0;">Removed Subscriber :</b> '+user.name+'<br/><b style="color:#0084b0;">Task ID:</b> '+_taskObj.id+'<br/>';
		sandbox.publish("insert-activity-log", { entityType : "task", entityID : _taskObj.id, historyComments : historyComments});
		
		sandbox.publish("update-analytics",{category:"Delete",action:"Task-Subscribers"});
		
		_currentSubscriberBeingUpdated = null;
	},
	
	getSubscriberUpdateMap = function(operation){
		
		var data = {}, user, subscriberEmails = [], tagsCache, tags = [], isAlreadySubscribed = false;
		
		data["comments"] = _taskObj.comments;
		data["taskID"] = _taskObj.id;
		
		if(!!_taskObj.assigneeID && !!(user = sandbox.cache.getUser(_taskObj.assigneeID))){
			data["assigneeName"] = user.name;
			data["assigneeEmail"] = user.email;
		}
		
		data["userName"] = sandbox.cache.get("loggedInUserName");
		data["userEmail"] = sandbox.cache.get("loggedInUserEmail");
		data["subscriberID"] = _currentSubscriberBeingUpdated;
		
		if(!!_taskObj.ownerID && !!(user = sandbox.cache.getUser(_taskObj.ownerID))){
			data["ownerName"] = user.name;
			data["ownerEmail"] = user.email;
		}
		
		if(!sandbox.util.isEmptyObject(_taskObj.linkedTags)){
			tagsCache = sandbox.cache.get("tags");
			_taskObj.linkedTags.map(function(tagID){
				tags.push(tagsCache[tagID].name);
			});
			data["tags"] = tags;
		}

		if(!!_taskObj.linkedSubscribers){
			_taskObj.linkedSubscribers.map(function(subscriberID){
				if(subscriberID == _currentSubscriberBeingUpdated) 
					isAlreadySubscribed = true;
				else {
					user = sandbox.cache.getUser(subscriberID);
					if(!!user)
						subscriberEmails.push(user.email);
				}
			});
		}
		if(subscriberEmails.length > 0)
			data["subscribers"] = subscriberEmails;
		
		switch(operation){
			case "add":{
				data["updatesubscribers"] = [sandbox.cache.getUser(_currentSubscriberBeingUpdated).email];
				data["operation"] = "add";
				if(isAlreadySubscribed){
					sandbox.alert.message({text:"User has already subscribed to this task."});
					return null;
				}
			}break;
			case "remove":{
				user = sandbox.cache.getUser(_currentSubscriberBeingUpdated);
				if(!!user)
					data["removesubscribers"] = [user.email];
				data["operation"] = "remove";
			}
		};
		
		return data;
	};

	return {
		
		init : function() {
			
			sandbox.subscribe("display-task-info", resetTaskActions);
			sandbox.subscribe("task-detail-display", displayActions);
			sandbox.subscribe("task-detail-linkedAccount-fetched", function(map){
				_account = map.account;
			});
			sandbox.subscribe("task-detail-resolve", resolveTask);
			sandbox.subscribe("taskActions-taskinfo-fetched", reopenTask);
			sandbox.subscribe("taskSubscribers-users-fetched", updateSusbcriberNames);
			sandbox.subscribe("taskActions-addSubscriber-formSubmit", addSubscriber);
			sandbox.subscribe("taskActions-display-subscribers", displaySubscribers);
			sandbox.subscribe("task-updated", function(map){
				
				if(!!_taskObj && _taskObj.id == map.id){
					
					if(map.obj.status != _taskObj.status)
						displayActions({task: map.obj});
					
					_taskObj = map.obj;
				}
			});
			
			_searchExistingContactBtn = sandbox.dom("#search-existing-contact-under-account");
			_existingContactsListEl = sandbox.dom("#existing-contacts-under-account");
			
//			_searchExistingContactBtn.on("click", function(e) {
//
//				if(sandbox.dom(e.target).parent().hasClass("open")) {
//					sandbox.dom(e.target).parent().removeClass("open");
//					_existingContactsListEl.empty()
//					return;
//				}
//				
//				sandbox.dom(e.target).parent().removeClass("open").addClass("open");
//				_existingContactsListEl.empty().append("<li> <span> Loading... </span> </li>");
//				getExistingContactsUnderAccount();
//			});
			
			sandbox.dom(_resolvReopenBtn).on("click", function(e){
				sandbox.dom(this).tooltip('hide');
				if(_taskObj.status != "completed" && _taskObj.status != "deleted")
					showResolveTaskPopup(e);
				else
					reopenTask(e);
			});
			
			sandbox.dom(_putOnHoldBtn).on("click", putTaskOnHold);
			sandbox.dom(_releaseOnHoldBtn).on("click", releaseOnHoldTask);
			sandbox.dom(_addSubsBtn).on("click", function(e){
				var data = {};
				data["form"] = "subscriberform";
				data["text"] = "Add Subscriber";
				data["publish"] = "taskActions-addSubscriber-formSubmit";
				data["confirmButton"] = "Add";
				data["openUsersSearch"] = true;
				sandbox.publish("show-custom-popup", data);
			});
			sandbox.dom(_subscriberListID).on("click", ".subscribedUserDiv .commonedit", removeSubscriber);			
		}
	};
});

DSCRM.Core.registerModule("otherTasksSection",["url","cache","alert","util","ajax"] ,function(sandbox) {
	
	var _p = {
			
	_taskObj: null,
	//_mergeTaskIDs:null,
	_currentTaskObjects:[],
	_cursor:null,
	_listEl: null,
	_loadingPlaceholderForOtherTasksTemplate : dscrm.templates.tasks.loadingPlaceholderForOtherTasks,
		
	displayTasks: function(map){
		
		if(!map.isLoadMoreCall){
			_p._listEl.empty();
			_p._cursor=null;
			_p._currentTaskObjects=[];
		}
		
		//var data = {};
		
		_p._taskObj = map.task;
		
		if(!_p._taskObj.linkedAccount)
			return;
		
		_p._listEl.parents(".otherTaskFieldSet").removeClass("hide");

		/*//data["limit"] = "50";//limit is not used in server side at all
		data["entityType"] = "linkedAccount";
		data["entityID"] = _taskObj.linkedAccount;*/
		
		var url = "/getTasksUnderAccount?linkedAccount="+_p._taskObj.linkedAccount;
		
		if(!!_p._cursor)
			url = url + "&cursor="+_p._cursor;

		sandbox.dom("ul.othertasklist").append(_p._loadingPlaceholderForOtherTasksTemplate);
		
		//sandbox.dom("#otherTasksLoadMore").removeClass("hide").addClass("m-progress");
		//_listEl.parent().removeClass("hide").find(".spinner_loading").removeClass("hide");
		//sandbox.ajax.request({url:"/getTasksForEntity", data:data, callBack:displayTasks_Callback, method:"POST"});
		sandbox.ajax.request({method:"GET", url:url, endpoint:"/getTasksUnderAccount", callBack: _p.displayTasks_Callback});
	},
	
	displayTasks_Callback: function(result){

		sandbox.dom("ul .otherTaskLiPlaceholder").remove();

		if(!_p._taskObj || (result.linkedAccount != _p._taskObj.linkedAccount))
			return;

		var tasks = result.task, 
			list = [], labelClass, listOnholdTasks = [], listPendingTasks = [], listRepliedTasks = [],
			taskTypeName, listDoneTasks = [], listDeletedTasks = [], listAllTasks =[], mergeDisabledForAllTasks,
			cacheUpdateList = [], data = {}, taskStatus,
			taskTypes = sandbox.cache.get("tasktype");

		_p._cursor = result.nextCursor;
		
		if(!_p._cursor)
			sandbox.dom("#otherTasksLoadMore").addClass("hide");
		else
			sandbox.dom("#otherTasksLoadMore").removeClass("hide");
		
		if(sandbox.util.isEmptyObject(tasks)){
			//_listEl.empty().parent().addClass("hide").find(".spinner_loading").addClass("hide");
			return;
		}
		
		_p._currentTaskObjects = _p._currentTaskObjects.concat(tasks);
		
		mergeDisabledForAllTasks = _p._taskObj.status == "deleted"?true:false;
		
		sandbox.dom.each(tasks,function(index,taskObj){
			
			taskTypeName = taskTypes.hasOwnProperty(taskObj.type) ? taskTypes[taskObj.type].type:"";

			taskObj["taskTypeName"]= taskTypeName; 
			
			
			
			if(_p._taskObj.id == taskObj["id"])
				return true;
			
			//sandbox.publish("task-updated",{id: taskObj.id, obj: taskObj});
			cacheUpdateList.push(taskObj);
			data = JSON.parse(JSON.stringify(taskObj));
			taskStatus = data.status;
			
			data["doneTask"] = data["deletedTask"] = "";
			data["mergeEnabled"] = mergeDisabledForAllTasks?"hide":"";
			if(!!data["notes"])
				data["notes"] = sandbox.util.removeHTMLTags(data["notes"]);
			
			if (taskStatus == "completed" || taskStatus == "deleted"){
				data["labelClass"] = "done_bac";
				data["doneTask"] = "strike-through";
				if(taskStatus == "deleted"){
					data["deletedTask"] = "deleted_task";
					data["mergeEnabled"] = "hide";
				}
			}
			else if(taskStatus == "onhold")
				data["labelClass"] = "label-warning";
			else if(taskTypeName == "Call")
				data["labelClass"] = "call_bac";
			else if(taskTypeName == "Email")
				data["labelClass"] = "email_bac";
			else
				data["labelClass"] = "label-success";
			
			if(["Call","Email","To-do","Sms"].indexOf(taskTypeName) != -1)
				data["hash"] = "#account/"+data.linkedAccount;
			else
				data["hash"] = "#task/"+data.id;
			
			if(taskTypeName.toLowerCase() == "sms")
				data["comments"] = data.comments.replace(/(<([^>]+)>)/ig,"");

			if("pending" == taskStatus || "unread"== taskStatus)
				listPendingTasks.push(data);
			else if("replied"== taskStatus)
				listRepliedTasks.push(data);
			else if("onhold"== taskStatus)
				listOnholdTasks.push(data);
			else if(["Call","Email","To-do","Sms"].indexOf(taskTypeName) == -1){
				
				if("completed" == taskStatus)
					listDoneTasks.push(data);
				else if("deleted" == taskStatus)
					listDeletedTasks.push(data);	
			}

		});
					
		listAllTasks = [listPendingTasks,listRepliedTasks,listOnholdTasks,listDoneTasks,listDeletedTasks];
		_p._listEl.append(dscrm.templates.tasks.otherTasksList({taskLists:listAllTasks}));
		//_listEl.html(dscrm.templates.tasks.otherTasksList({taskLists:listAllTasks}));
		//_listEl.parent().find(".spinner_loading").addClass("hide");
		if(_p._listEl.children().length < 1)
			_p._listEl.parents(".otherTaskFieldSet").addClass("hide");

		sandbox.publish("tasks-updated", {tasks: cacheUpdateList});
		sandbox.dom('[data-tooltip="tooltip"]').tooltip({
		    trigger : 'hover'
		}); 
	},
	
	/*resetSection = function(map){
		
		if(map.hasOwnProperty("id") && !!_taskObj && map.id == _taskObj.id)
			return;
		
		_listEl.empty().parent().addClass("hide");
	},*/
	
	mergeTask: function(e){
		
		var text, taskID, data, metaDataForJS = {};
		
		if(!e.hasOwnProperty("isConfirmed")){
			text = "Merging tasks will move the activity and documents of the task in the Other tasks section to this task that you are viewing. This task will be retained while the other task will be deleted. Are you sure you want to merge the task?";
			sandbox.alert.dialog({text:text, confirm: _p.mergeTask, data:{isConfirmed: true, e: e}});
			return;
		}
		
		e = e.e; data = {};
		
		taskID = sandbox.dom(e.target).data("taskid")+"";//convert sms taskid to string
		//_p._mergeTaskIDs = [taskID, _p._taskObj.id];
		metaDataForJS["id"] = [taskID, _p._taskObj.id];
		metaDataForJS["oldTasksMap"] = {};
		metaDataForJS["oldTasksMap"][taskID] = sandbox.cache.get("tasks")[taskID];
		metaDataForJS["oldTasksMap"][_p._taskObj.id] = _p._taskObj;
		
		data["oldTaskID"] = taskID;		
		data["newTaskID"]=  _p._taskObj.id;
		data["accountID"] = sandbox.cache.get("accountID");
		data["userName"] = sandbox.cache.get("loggedInUserName");
		
		sandbox.dom(e.target).parent("li").remove();
		
		sandbox.alert.message({text:"Merging tasks..."});
		sandbox.ajax.request({url:"/processMergeTask", data:data, endpoint:"/processMergeTask", callBack:_p.mergeTask_Callback,method:"POST", metaDataForJS:metaDataForJS});
	},
	
	mergeTask_Callback: function(resultObject){
		
		sandbox.alert.message({text:"The task got merged successfully and the changes will reflect soon.",time:5000});
		var data = {},
			userID = sandbox.cache.get("loggedInUserID"),
			user = sandbox.cache.getUser(userID);
		
		data["departmentID"] = user.defaultDepartmentID;
		data["department"] = user.defaultGroupID;
		data["assigneeID"]= userID;
		//data["task"] = _p._mergeTaskIDs;
		data["task"] = resultObject.metaDataForJS["id"];
		
		sandbox.ajax.request({url:"/reassignBulkTasksFromReport", data:data, endpoint:"/reassignBulkTasksFromReport", callBack:_p.reassignBulkTasksForMerge_Callback,method:"POST", metaDataForJS:resultObject.metaDataForJS});
	},
	
	reassignBulkTasksForMerge_Callback: function(resultObject){
		
		var data = {}, oldTasksMap = {},index, taskIDs, oldTask, currentUpdatedTask,
			mergedTaskIDs = resultObject.metaDataForJS["id"];
		
		sandbox.dom.each(resultObject.tasks, function(index, task){
			//if(task.id == _p._taskObj.id)
			if(task.id == mergedTaskIDs[1])
				currentUpdatedTask = task;
		});
		
		sandbox.publish("tasks-updated", resultObject);

		/*taskIDs =resultObject.task; 
		index = taskIDs.indexOf(_p._taskObj.id);
		taskIDs.splice(index,1);//to get the task ID of the task that was marked deleted in the merge
		
		//to get the task object that was deleted, but with old values (prior to the merge)
		sandbox.dom.each(_p._currentTaskObjects, function(index, task){
			if(task.id == taskIDs[0]){
				oldTask = task;
				return false;
			}
		});
		
		if(!!oldTask){
			oldTasksMap[oldTask.id] = oldTask;
			oldTasksMap[_p._taskObj.id] = _p._taskObj; //old task object of current task in view (the one that wasnt deleted in the merge)
			data["oldTasksMap"]=JSON.parse(JSON.stringify(oldTasksMap));
		}*/
		
		oldTasksMap = resultObject.metaDataForJS["oldTasksMap"];
		if(!sandbox.util.isEmptyObject(oldTasksMap[mergedTaskIDs[0]]) && !sandbox.util.isEmptyObject(oldTasksMap[mergedTaskIDs[1]]))
			data["oldTasksMap"]=JSON.parse(JSON.stringify(oldTasksMap));

 		data["type"] = "bulkMergeReassign";
		data["tasks"] = resultObject.tasks;
		
		sandbox.publish("bulkTask-operation-complete",data);
		
		if(!!_p._taskObj && _p._taskObj.id == mergedTaskIDs[1]){
			_p._taskObj = currentUpdatedTask;
			sandbox.publish("display-task-info",{id:_p._taskObj.id, taskObj: _p._taskObj, selectDisplay:{headerAndButtons : true, subtabs : true, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
		}
		
		sandbox.publish("update-analytics", { category: "Update", action: "Task-Reassign-for-Merge"});
	}
	};
	var api= {
		
		init : function() {
			
			_p._listEl= sandbox.dom("#taskDetail fieldset ul.othertasklist");
			
			//sandbox.subscribe("display-task-info", resetSection);
			sandbox.subscribe("otherTasks-display", _p.displayTasks);
			sandbox.subscribe("otherTasksSection-clear", function(map){
				_p._taskObj= null;
				_p._currentTaskObjects=[];
				_p._cursor=null;
				_p._listEl.empty();
				_p._listEl.parents(".otherTaskFieldSet").addClass("hide");
			});
			
			sandbox.subscribe("task-updated", function(map){
				
				if(!_p._taskObj || _p._taskObj.id != map.id)
					return;
				
				var oldStatus = _p._taskObj.status; 
				
				_p._taskObj = map.obj;
				
				if(_p._listEl.children().length == 0)
					return;
				
				if(map.obj.status == "deleted")
					_p._listEl.find("li .icon-arrow-shuffle").addClass("hide");//disabling merge
				else if(oldStatus == "deleted" && oldStatus != map.obj.status)
					_p._listEl.find("li .icon-arrow-shuffle").removeClass("hide");//enabling merge
			});
			
			_p._listEl.on("click",".otherTaskLi code", _p.mergeTask);
			sandbox.dom("#otherTasksLoadMore").on("click", function(e){
				sandbox.dom("#otherTasksLoadMore").addClass("hide");
				_p.displayTasks({task: _p._taskObj, isLoadMoreCall:true});
			});
		},
		destroy : function() {
            sandbox.unsubscribe();
        }
	};
	
	/* Only for testing - STARTS */
	
	api._private = _p;
	
	/* Only for testing - END */
	
	return api;
});

DSCRM.Core.registerModule("todaysNextTask",["url","cache","alert","util","ajax"] ,function(sandbox) {
	
	var _nextTaskCache, _isExecutionOngoing = false;

	//fetches open tasks assigned to the user ordered by dueDate ascending and then createdDate descending 
	var getTask = function(e){
		
		if(_isExecutionOngoing)
			return;
		_isExecutionOngoing = true;
		
		var params, isFirstRequest = false, taskId = null, relatedTo = null, 
			dealId = '', contactId = null, accountId = '', analyticsAction,
			departmentID = sandbox.cache.get("selectedDepartmentID"),
			page = sandbox.url.page();

		switch(page) {
		
			case "contact" : analyticsAction = "Contact-Task-Next Due"; break;
			case "lead" : 	analyticsAction = "Lead-Task-Next Due"; break;
			case "deal" : 	analyticsAction = "Deal-Task-Next Due"; break;
			case "account" :analyticsAction = "Account-Task-Next Due"; break;
		}
		sandbox.publish("update-analytics", {category: "Other Task Events", action: analyticsAction});
				
		if(!sandbox.util.isEmptyObject(_nextTaskCache)) {
			
			taskId = _nextTaskCache["taskid"];
			relatedTo = _nextTaskCache["relatedto"];
			dealId = _nextTaskCache["dealid"];
			contactId = _nextTaskCache["contactid"];
			accountId = _nextTaskCache["accountid"];
			
		} else
			isFirstRequest = true;

		sandbox.alert.message({text:"Fetching today's next task..."});

		params = "?isFirstRequest=" + isFirstRequest+"&taskId="+taskId+"&relatedTo="+relatedTo+"&dealId="+dealId+"&contactId="+contactId+"&accountId="+accountId+"&departmentID="+departmentID;
		sandbox.ajax.request({url:"/getTodaysNextTaskOfUser"+params, method:"GET", endpoint:"/getTodaysNextTaskOfUser", callBack:getTask_Callback, data:{}});		
	},
	
	getTask_Callback = function(resultObject){

		var relatedTo, dealId, contactId, accountId, taskIdOfScheduledTaskToShow, 
			taskIdOfNextScheduledTask, entityID, arrayOfTaskId, mapOfTaskInfo, taskInfoToShow;
		
		sandbox.alert.hideMessage();

		if(sandbox.util.isEmptyObject(resultObject.listOfTaskID)) {
			_isExecutionOngoing = false;
			sandbox.alert.dialog({text:"There are no pending tasks for today", type:"ok"});
			return;
		}
		
		arrayOfTaskId = resultObject.listOfTaskID;
		mapOfTaskInfo = resultObject.taskInfo;
		
		if(arrayOfTaskId.length == 2) {
			taskIdOfScheduledTaskToShow = arrayOfTaskId[0];
			taskIdOfNextScheduledTask = arrayOfTaskId[1];
		} else 
			taskIdOfNextScheduledTask = arrayOfTaskId[0];
			
		if(!!taskIdOfNextScheduledTask)
			_nextTaskCache = mapOfTaskInfo[taskIdOfNextScheduledTask];
		else
			_nextTaskCache = null;
		
		if(!!taskIdOfScheduledTaskToShow) {
			
			taskInfoToShow = mapOfTaskInfo[taskIdOfScheduledTaskToShow];
			relatedTo = taskInfoToShow["relatedto"];
			dealId = taskInfoToShow["dealid"];
			contactId = taskInfoToShow["contactid"];
			accountId = taskInfoToShow["accountid"];

			if(relatedTo == "Account") 
				entityID = accountId;
			else if(relatedTo == "Deal") 
				entityID = dealId;
			else if(relatedTo == "Contact")
				entityID = contactId;
			
			if(!!entityID)
				sandbox.url.changeHash(relatedTo.toLowerCase(), entityID);
		}
		
		_isExecutionOngoing = false;
	};

	return {
		
		init : function() {
			sandbox.dom(".todaynexttask").on("click", getTask);
		}
	};
});

DSCRM.Core.registerModule("involved-account",["url","cache","alert","util","ajax"] ,function(sandbox) {
	var _task = {},
		_taskId = "",
		_involvedAccountSectionEl = sandbox.dom("#task-involved-account"),
		_searchExistingAccountBtn = _involvedAccountSectionEl.find("#search-existing-account"),
		_existingAccountsListEl = _involvedAccountSectionEl.find("#existing-account-search-results"),
		_searchExistingAccountInput = _involvedAccountSectionEl.find("input.search-existing-account"),
		_searchAccountsResultTemplate = dscrm.templates.search.searchResultsForExistingAccounts,
		
	
	displayInvolvedAccount = function(data){
		_task = data.obj;
		_taskId = data.id;
		
		_involvedAccountSectionEl.removeClass('hide');
		//Bind event listeners
		bindEventsForAddAccountAction();
		
	},
	
	bindEventsForAddAccountAction = function(){
		
		//Event listener for showing the search input
		_searchExistingAccountBtn.off().on("click", function(e) {
			
			if(sandbox.dom(e.target).parent().hasClass("open")) {
				hideSearchListing();
				return;
			}
			
			_existingAccountsListEl.empty();
			sandbox.dom(e.target).parent().removeClass("open").addClass("open");
			_searchExistingAccountInput.val('').focus();			
		});
		
		//Event listener for search account input 
		_searchExistingAccountInput.off().on("keyup", function(e) {				
			searchExistingAccounts(e);				
		});
		
		//Event listener for add btn in search list
		_existingAccountsListEl.off().on("click", "li span.btn", function(e) {
			addExistingAccount(e);
		});
	},
	
	searchExistingAccounts = function(e){
		
		if (e.keyCode==38 || e.keyCode==40)
			return;
		
		var searchString = e.target.value;
		if(searchString.length < 3) 
			return;
		
		_existingAccountsListEl.empty().append("<li> <span class='loading-search-list icon-spinner'> Loading..</span></li>");
		_searchExistingAccountInput.parent().parent().removeClass("open").addClass("open");
		
		url = "/search/results?searchType=AccountName&searchBy=AccountName&limit=30&cursor=&queryString="+searchString+"&departmentID="+sandbox.cache.get("selectedDepartmentID");
		sandbox.ajax.request({url:url, data:{}, endpoint:"/search/results", callBack: searchExistingAccountsCallback, method:"POST"});
		
	},
	
	searchExistingAccountsCallback = function(response){
		
		if(!response.success)
			return;
		
		var accountsList = response.results;
		
		if(sandbox.util.isEmptyObject(accountsList)){
			_existingAccountsListEl.empty();
			return;
		}
		
		showAccountNamesInSearchList(accountsList);
		
	},
	
	showAccountNamesInSearchList = function(accounts){
		
		var accountsList = {};
		var data = null, listOfData = null, name = null, category = null, accountsID = null;
			

		sandbox.dom.each(accounts, function(index,account){
		
			if(account.leadFlag != 'Account')
				return true;
			
			accountsID = '';
		
			accountsID = account['uniquepin'];
			accountsList[accountsID] = account;
			
		});
		
				
		if(!sandbox.util.isEmptyObject(accountsList)) {
			
			listOfData = [];
			
			sandbox.dom.each(accountsList, function(key,value){
				
				data = {}; name = ''; category = '';
				name = value.dealName;
				data['accountID'] = key;
				data['accountName'] = name;
				
				listOfData.push(data);
				
			});
		}
		
		//adding event handler on document for detecting a click outside
		sandbox.dom(document).on('mouseup',closeSearchList );
		
		_existingAccountsListEl.empty().append(_searchAccountsResultTemplate({accountsList: listOfData, appURL : sandbox.cache.get("appURL") }));
		_searchExistingAccountInput.parent().parent().removeClass("open").addClass("open");
		
	},
	
	addExistingAccount = function(e){
		
		var data = {},accountID = null, taskID = null;
		
		sandbox.alert.message({text:"Adding account to the task.."});
		
		accountID = sandbox.dom(e.target).parent().attr("id");
		taskID = sandbox.url.entityID();
		
		data['accountsID'] = accountID;
		data['taskID'] = taskID;
		
		sandbox.ajax.request({url:'/addExistingAccountToTask', data: data, endpoint:"/addExistingAccountToTask", callBack: addExistingAccountCallBack, method:"POST"});
	},
	
	addExistingAccountCallBack = function(response){
		
		var account = null,
			accountID = null,
			task = null,
			taskID = null;
		
		if(!response.success){
			sandbox.alert.message({text:"Server error! Please try again..",time:3000});
			return;
		}
		
		sandbox.alert.hideMessage();
			
		account = response.account;
		task = response.task;
		
		taskID = task.id;
		accountID = account.id;
		
		sandbox.publish("account-updated",{id : accountID, obj: account});
		sandbox.publish("task-updated", {id: taskID, obj: task});
		sandbox.publish("display-task-info",{id:taskID, taskObj: task, selectDisplay:{headerAndButtons : true, subtabs : true, fetchAccount: true, fetchContacts:true,fetchOtherTasks:true}});
		hideInvolvedAccount();
		
		sandbox.publish('get-Activity-Log-For-Associations',{userName : sandbox.cache.get('loggedInUserName'),
            operation : "existing", subEntity:"Account",
            url : '<a href="'+  sandbox.util.getEntityURL({ entityType : "account", entityID : accountID}) +'" target = "_blank">'+ sandbox.util.getEntityURL({ entityType : "account", entityID : accountID})+'</a>',
            entityType : "task", entityID : taskID});
		
	},
	
	hideSearchListing = function(){
		_existingAccountsListEl.empty();
		_searchExistingAccountBtn.parent().removeClass("open")
		
	},
	
	closeSearchList = function(e){
		
		var _searchPanelEl = sandbox.dom('.existingcontact_holder').find('.dropdown-menu.open');
		//check whether the click is outside search panel
	    if (!_searchPanelEl.is(e.target) && _searchPanelEl.has(e.target).length === 0){
	    	hideSearchListing();
	    	//Removing the event handler
	    	sandbox.dom(document).off('mouseup',closeSearchList );
	    }
	    
	};
	
	hideInvolvedAccount = function(){
		_involvedAccountSectionEl.addClass('hide');
		hideSearchListing();
		
	};
	
	
	
	return {
		init : function() {
			sandbox.subscribe("display-involved-account", displayInvolvedAccount );
			sandbox.subscribe("hide-involved-account", hideInvolvedAccount );
			
		}	
	};
});

DSCRM.Core.registerModule("unreadTasks",["ajax","cache","util","alert","url"] ,function(sandbox) {
	
	var _p = {
			
		_count:0,
		_taskMap:{},
		_listSelector:"header .task_listing .dropdown-menu",
		_isUnreadTaskClicked:false,
		_isWaitingForTaskTypes:true,
		
	fetchUnreadTasks: function(){
		
		var data = {
					 "taskStatus":"unread",
					 "assigneeID": sandbox.cache.get("loggedInUserID"),
					 "departmentID": sandbox.cache.get("selectedDepartmentID")
					},
			url = "/getAllAssigneeTasks_v2";
		
		sandbox.ajax.request({url:url, method:"POST", endpoint:"/getATask_v2", callBack: _p.fetchUnreadTasks_Callback, data: data});
	},
	
	fetchUnreadTasks_Callback: function(response){
		
		if(!!response.tasks)
			sandbox.publish("update-unread-tasks-in-cache",response.tasks);
		
		var data = {
				count : response.tasks.size,
				tasks : sandbox.dom.map(response.tasks, function(value, index) {
				    
				    value['taskTypeName'] = sandbox.cache.get("tasktype")[value.type].type;
				    return [value];
				})
		};
		
		_p.addUnreadTasks(data);
		
		
	},
	
	getATask: function(map){
		
		var data = {},
			url = "/getATask_v2?apikey="+sandbox.cache.get("accountID")+"&taskid="+map.id+"&isLoggedIn=true";
		
		data["departmentID"] = sandbox.cache.get("selectedDepartmentID");
		data["accessibleDepartments"] = sandbox.cache.get("accessibleDepartments");
		
		sandbox.ajax.request({url:url, method:"POST", endpoint:"/getATask_v2", callBack: _p.getATask_Callback, data: data});
	},
	
	getATask_Callback: function(result){
		
		if(result.hasOwnProperty("errorMessage")) {
			sandbox.alert.dialog({text:result["errorMessage"], type:"ok"});
			return;
		}
		
		// a3v - to clear the parameter of unreadTaskID - without refreshing - so that notification comes for the same detail page, it shows the latest data
		if(!!sandbox.url.entityID())
			window.history.replaceState({},document.title, sandbox.cache.get('appURL') + window.location.pathname +"#"+sandbox.url.page()+"/"+sandbox.url.entityID());

		var task = result["task"],
			taskID = task.id,
			taskInCache = sandbox.cache.get("tasks")[taskID],
			isPresentInUI = false,
			taskType = task.type,
			taskTypes = sandbox.cache.get("tasktype");
			taskType = taskTypes[taskType].type.toLowerCase();
	
		if(_p._isUnreadTaskClicked) {
			_p._isUnreadTaskClicked = false;
			sandbox.publish("task-updated", {id: taskID, obj: task});
			return;
		}
		
		sandbox.publish("task-updated", {id: taskID, obj: task});
		
		if(sandbox.dom(_p._listSelector).children("#unread_"+taskID).length != 0)
			isPresentInUI = true;
		
		if(task.status != "unread"){

			if(isPresentInUI){
				delete _p._taskMap[taskID];
				sandbox.dom(_p._listSelector).children("#unread_"+taskID).remove();
				sandbox.dom(_p._listSelector).removeClass('show');
				--_p._count;
				_p.updateCountHTML();
			}
			
			if(["call", "email", "to-do", "sms"].indexOf(taskType)!= -1) {
				return;
			}
			else if(taskID == sandbox.url.entityID()){
				sandbox.publish("display-task-info",{id:taskID, taskObj: task, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});
			}

			return;
		}
		
		_p.setTaskURLBasedOnType(task);
		
		if(isPresentInUI && !!taskInCache && taskInCache.status == "unread")
			return; //it was already unread in cache
		else if(!isPresentInUI){
			_p._taskMap[taskID] = task;
			sandbox.dom(_p._listSelector).append(dscrm.templates.tasks.unreadTasksList({tasks:[task]}));
			_p._count++;
			_p.updateCountHTML();
		}
	},
	
	setTaskURLBasedOnType: function(task) {
		
		var taskType = task.type, linkedAccount = null, linkedDeal = null, linkedContacts = null, pageURL,
			taskTypes = sandbox.cache.get("tasktype");
		
		taskType = taskTypes[taskType].type.toLowerCase();
		
		if("call" == taskType || "email" == taskType || "to-do" == taskType || "sms" == taskType) {
			
			linkedAccount = task.linkedAccount;
			linkedDeal = task.linkedDeal;
			linkedContacts = task.linkedContacts;
			
			if(!!linkedAccount)
				pageURL = "#account/" + linkedAccount + "?unreadTaskID=" + task.id;
			else if(!!linkedDeal)
				pageURL = "#deal/" + linkedDeal + "?unreadTaskID=" + task.id;
			else if(!$.isEmptyObject(linkedContacts))
				pageURL = "#contact/" + linkedContacts[0] + "?unreadTaskID=" + task.id;
			else
				pageURL = "#task/" + task.id;
		} else
			pageURL = "#task/" + task.id;
		
		task["pageURL"] = pageURL;	
	},
	
	unreadOpened: function(map){

		var data = {"status":"pending", "operation":"update", "isUnreadTaskUpdate":true},
			url = "/updateATask/"+map.id+"?apikey="+sandbox.cache.get("accountID")+"&isLoggedIn="+true;
		
		sandbox.ajax.request({url:url, method:"PUT", endpoint:"/updateATask", callBack: _p.getATask_Callback, data: data});
	},
	
	updateCountHTML: function(){
		
		if(!!_p._count)
			sandbox.dom(".unreadTasksCount").html(_p._count);
		else
			sandbox.dom(".unreadTasksCount").html("");
	},
	
	updateReadTask: function(data){
		
		var taskID = data.id,
			taskInfoMap = data.taskInfoMap;
		
		if(_p._taskMap.hasOwnProperty(taskID)){
			--_p._count;
			delete _p._taskMap[taskID];
			sandbox.dom(_p._listSelector).children("#unread_"+taskID).remove();
			_p.updateCountHTML();
		}
		
		var taskObj = sandbox.cache.get("tasks")[taskID],
			userID = sandbox.cache.get("loggedInUserID"),
			taskStatus;
		
		if(!taskObj)
			return;

		taskStatus = taskObj["status"] = taskInfoMap.status;
		taskObj["assigneeID"] = taskInfoMap.assigneeID;
		
		if(taskStatus == "completed" || taskStatus == "deleted")
			taskObj.open=false;
		
		sandbox.publish("task-updated",{id: taskID, obj: taskObj});
	},
	
	addUnreadTasks: function(map){

		var tasks = [], userID = sandbox.cache.get("loggedInUserID"), departmentID = sandbox.cache.get("selectedDepartmentID");
		
		map.tasks.map(function(task){
			if(!_p._taskMap.hasOwnProperty(task.id) && task.status == "unread" && departmentID == task.departmentID && userID == task.assigneeID){
				_p._taskMap[task.id] = task;
				_p.setTaskURLBasedOnType(task);
				tasks.push(task);
				_p._count++;
			}
		});
		
		if(tasks.length == 0)
			return;
		
		sandbox.dom(_p._listSelector).append(dscrm.templates.tasks.unreadTasksList({tasks:tasks}));
		_p.updateCountHTML();
	},
	
	updateAfterBulkTaskOperation: function(map){
		
		if(sandbox.dom(_p._listSelector).children().length == 0)
			return;
		else if(sandbox.util.isEmptyObject(map.tasks))
			return;
		else if(map.type == "bulkReschedule")
			return;
		
		var tasks = map.tasks,
			userID = sandbox.cache.get("loggedInUserID"),
			listEl = sandbox.dom(_p._listSelector), 
			el;

		sandbox.dom.each(tasks, function(index, task){
			
			if(task.status == "unread" && task.assigneeID == userID)
				return false;
			
			el = listEl.find("#unread_"+task.id);
			if(el.length > 0){
				el.remove();
				--_p._count;
				delete _p._taskMap[task.id];
			}
		});
		
		if(!!el)
			_p.updateCountHTML();
	}
	
	};
	var api = {
		
		init : function() {
			
			sandbox.dom("header .task_listing").on("click",function(e){
				if(!!_p._count)
					sandbox.dom(_p._listSelector).addClass("show");
			});
			
			sandbox.dom(_p._listSelector).on("click", "a",function(e){

				_p._isUnreadTaskClicked = true;
				var taskID = sandbox.dom(this).parent().attr('id').split("unread_")[1];
				
				delete _p._taskMap[taskID];
				sandbox.dom(_p._listSelector).children("#unread_"+taskID).remove();
				sandbox.dom(_p._listSelector).removeClass('show');
				--_p._count;
				_p.updateCountHTML();
				
				var taskInCache = sandbox.cache.get("tasks")[taskID];
				
				taskInCache.status = "pending";
				taskInCache.lastUpdatedDate = Date.now();

				sandbox.publish("task-updated", {id: taskID, obj: taskInCache});
				
				_p.setTaskURLBasedOnType(taskInCache);
				window.location.hash = taskInCache["pageURL"];
				
				if(taskInCache["pageURL"].indexOf("unreadTaskID") == -1) {
					sandbox.publish("display-task-info",{id:taskID, taskObj: taskInCache, selectDisplay:{headerAndButtons : true, subtabs : false, fetchAccount: true, fetchContacts:false,fetchOtherTasks:false}});					
					sandbox.alert.message({text : "Loading..."});
					sandbox.publish("unreadTasks-opened",{id: taskID});
				}

			});
			
			sandbox.subscribe("unreadTasks-add", _p.addUnreadTasks);
			sandbox.subscribe("unreadTasks-getATask", _p.getATask);
			sandbox.subscribe("unreadTasks-opened", _p.unreadOpened);
			sandbox.subscribe("unreadTasks-readUpdate", _p.updateReadTask);
			sandbox.subscribe("updated-tasktypes", function(){
				if(_p._isWaitingForTaskTypes){
					_p.fetchUnreadTasks();
					_p._isWaitingForTaskTypes = false;
				}
			});
			sandbox.subscribe("bulkTask-operation-complete", _p.updateAfterBulkTaskOperation);
			
		},
		destroy: function(){
			sandbox.unsubscribe();
		}
	};
	
	/* For testing purpose only  - starts*/
	api._private = _p;
	/* For testing purpose only - ends*/
	
	return api;
});


DSCRM.Core.registerModule("taskAccountNumbers",["cache","util","ajax"] ,function(sandbox) {
	
	var _self = null;
	
	var _private = {
			
		 _ID : null, _taskObj : null, _account : null, _customField:null,
		
	resetSection : function(map){
		_private._taskObj = map.task;
		_private._ID = map.task.id;
		sandbox.dom("#taskAccountNumbers").addClass("hide").find(".taskAccountNumHolder").empty();
	},

	setTaskAccountNumbers: function(map){
		
		if(sandbox.util.isEmptyObject(map.customField))
			return;
		
		_private._taskObj = map.task;
		_private._ID = map.task.id;
		_private._account = map.account;
		_private._customField = map.customField;

		var htmlStr="",
			fieldInfoID = sandbox.cache.get("accountNumberFieldInfoID");
		
		_private._customField.map(function(object){
			
			if( fieldInfoID == object["fieldInfoID"] )	
				//listAccountNumbers.push( object['value'] );
				htmlStr += '<li class="taskAccountNum"><input type="text" class="input-sm" readonly value="'+object["value"]+'"></li>';
		});		
		
		if(!!htmlStr){
			sandbox.dom("#taskAccountNumbers").removeClass("hide").find(".taskAccountNumHolder").empty();
			sandbox.dom("#taskAccountNumbers .taskAccountNumHolder").append(htmlStr);
		}
	},
	
	fetchAccountNumbers : function(map){

		_private._account = map.account;
		_private.resetSection(map);
		
		if(sandbox.util.isEmptyObject(_private._account.linkedCustomFields))
			return;
		
		var data = {};
		data["customFieldID"] = _private._account.linkedCustomFields;
		data["utcOffsetString"] = sandbox.cache.get("timeZoneAndOffset")["offset"];

		sandbox.ajax.requestDCM({url:"/services/crm/getCustomFields?apikey="+sandbox.cache.get("accountID"), method:"POST", data : data, callBack: _private.fetchAccountNumbers_Callback});
	},
	
	fetchAccountNumbers_Callback : function(result){
		_private.setTaskAccountNumbers({customField: result.customField, task: _private._taskObj, account: _private._account});
	}
	
	};

		
		var api = {
		
		init : function() {

			_self = this;
			sandbox.subscribe("task-detail-display", _private.resetSection);
			sandbox.subscribe("task-detail-linkedAccount-fetched", _private.setTaskAccountNumbers);
			sandbox.subscribe("taskAccountNumbers-fetch", _private.fetchAccountNumbers);
			sandbox.subscribe("taskAccountNumbers-clear", function(map){
				_private._ID = map.id;
				sandbox.dom("#taskAccountNumbers").addClass("hide").find(".taskAccountNumHolder").empty();
			});
			
		},
		
		destroy : function() {
			sandbox.unsubscribe();
		}
		};
		
	    /* Exposing private methods for test suites - START */

	    api._private = _private;

	    /* Exposing private methods for test suites - END */

	    return  api; 
	
});
