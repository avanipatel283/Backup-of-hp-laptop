package com.adaptavant.crm.service;

import static com.adaptavant.crm.service.AnswerConnectService.answerConnectAccountID;
import static com.adaptavant.crm.service.URLFetchService.utfCharset;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URLEncoder;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TimeZone;
import java.util.UUID;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.lang.time.DateUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.util.IOUtils;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.type.TypeReference;

import au.com.bytecode.opencsv.CSVReader;

import com.adaptavant.crm.dao.DataStoreObjectDAO;
import com.adaptavant.crm.dao.DataStoreUtil;
import com.adaptavant.crm.dao.DealDAO;
import com.adaptavant.crm.dao.TaskDAO;
import com.adaptavant.crm.dto.Account;
import com.adaptavant.crm.dto.Contact;
import com.adaptavant.crm.dto.ContactMethod;
import com.adaptavant.crm.dto.CustomField;
import com.adaptavant.crm.dto.Deal;
import com.adaptavant.crm.dto.History;
import com.adaptavant.crm.dto.InboxConfiguration;
import com.adaptavant.crm.dto.NotificationSubscription;
import com.adaptavant.crm.dto.Reminder;
import com.adaptavant.crm.dto.Tag;
import com.adaptavant.crm.dto.TagInfo;
import com.adaptavant.crm.dto.Task;
import com.adaptavant.crm.dto.TaskType;
import com.adaptavant.crm.util.EmailUtil;
import com.adaptavant.crm.util.StringConstants;
import com.adaptavant.crm.util.StringUtilSales;
import com.adaptavant.crm.util.Utilities;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.EntityNotFoundException;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.KeyFactory;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.taskqueue.TaskOptions;
import com.google.appengine.api.taskqueue.TaskOptions.Method;
import com.google.appengine.api.urlfetch.HTTPResponse;

import common.util.StringUtil;
import common.util.VelocityUtil;

public class TaskService
	{

		private static final Logger mLogger = Logger.getLogger( TaskService.class.getPackage().getName() );
		private static final String CS_Domain = StringUtilSales.getStringBasedOnMode( "chat.domain.name" );
		private static final String businessServiceDepartmentID = StringUtilSales.getStringBasedOnMode( "businessService.departmentID" );
		private static final String billingGroupID = StringUtilSales.getEnvironmentValues("businessService.billing.groupID");
//		private static final String serviceTaskDepartment = StringUtilSales.rsbAR.getString( "businessService.service.groupID" );
//		private static final String lexreceptionProductID = StringUtilSales.rsbAR.getString( "lexreception.productID" );
		private static final String salesEscalationUserID = StringUtilSales.getStringBasedOnMode( "salesEscalation.userID" );
		private static final String staticContentUrl = StringUtilSales.getStringBasedOnMode( "securedStaticContent.url" );
		private static final String mode = StringUtilSales.rsbAR.getString( "Mode" );
		private static final String dueDateReminderBefore10Mins = StringUtilSales.rsbAR.getString( "emailNotification.reminder.dueDateBefore10Minutes.notificationID" );
		private static final List<String> dueDateReminders = new ArrayList<String>(Arrays.asList(dueDateReminderBefore10Mins));
		private static final String cancelTicketTaskTypeID = StringUtilSales.rsbAR.getString( "jBilling.cancelTicketTaskType" );
		private static final String creditTicketTaskTypeID = StringUtilSales.rsbAR.getString( "jBilling.creditTicketTaskType" );
		private static final String unblockTicketTaskTypeID = StringUtilSales.rsbAR.getString( "jBilling.unblockTicketTaskType" );
		private static final String delayBillingTaskTypeID = StringUtilSales.rsbAR.getString( "jBilling.delayBillingTaskType" );
		private static final String jBillingWebhookNotificationID = StringUtilSales.rsbAR.getString( "jBilling.webhook.notificationID" );
		//private static final String	supportEmailAddress = StringUtilSales.rsbAR.getString( "support.emailAddress" );

		@SuppressWarnings( { "unchecked" } )
		public static Map <String , Object> createTask( String accountID , String json , HttpServletRequest request )
			{

				boolean success = false , isMultipart = false, isUnreadTask = false;

				Long dealID = null;

				String taskId = null, taskJson = null, uniqueTabID , departmentID = null, accountsID = null, appID;
				String requestJson = "", CMSPutURL = "", respJSON = "";

				List <String> linkedContacts = null, linkedDocuments = null;
				List <Map <String , Object>> documents = null, listOfCustomField = null;

				Map <String , Object> taskMap = null, map = new HashMap <String , Object>() , 
										mapTaskData = null , mapTagData = null , mapTag = null, mapHistoryData = null ,
										mapCustomField = null , mapSubTask = null, mapAllCf = null, mapOfTaskAssigneeEmail = null,
										mapOfTaskSubscriberEmail = null, mapOfDocumentInfo = new HashMap <String, Object>(), responseMap = null;

				Task task = new Task();
				ObjectMapper objMapper = new ObjectMapper();
				StringBuffer buffer = new StringBuffer();
				try
					{
							
						if(request != null)
							isMultipart = ServletFileUpload.isMultipartContent( request );

						if ( isMultipart )
							{
								
								mapTaskData = getTaskMultipartRequestData( request );
								taskMap = (Map <String , Object>) mapTaskData.get( "task" );
								documents = (List <Map <String , Object>>) mapTaskData.get( "documents" );
								//taskJson = objMapper.writeValueAsString( taskMap );
							}
						else if ( !StringUtil.isBlank( json ) )
							{
								taskJson = json;
								taskMap = objMapper.readValue( taskJson , new TypeReference <Map <String , Object>>(){} );
								
								appID = Utilities.getAppIDOfRequest( request );
								if(!StringUtil.isBlank( appID ) && !staticContentUrl.contains(appID))
									mLogger.log( java.util.logging.Level.INFO, "createTask json: "+json);
							}
						else if(request != null)
							{
								json = getTaskRequestDataFromReader( request );
								taskMap = objMapper.readValue( json , new TypeReference <Map <String , Object>>(){} );
								//taskMap = (Map <String , Object>) mapTaskData.get( "task" );
								documents = (List <Map <String , Object>>) taskMap.get( "documents" );
								taskMap.remove("documents");

								appID = Utilities.getAppIDOfRequest( request );
								if(!StringUtil.isBlank( appID ) && !staticContentUrl.contains(appID)){
									
									mLogger.log( java.util.logging.Level.INFO, "createTask json: "+json);
									if(!Utilities.isEmpty( documents ) && documents.size() > 1){
										map.put("error", "Cannot upload more than one document while creating task");
										return map;
									}
								}
							}

						uniqueTabID = (String) taskMap.get( "uniqueTabID" );
						departmentID = Utilities.getStringValueFromMap( "departmentID" , taskMap );
						listOfCustomField = (List <Map <String , Object>>) taskMap.get( "customField" );
						mapOfTaskAssigneeEmail = (Map <String , Object>) taskMap.get( "taskinfo" );
						mapOfTaskSubscriberEmail = (Map <String , Object>) taskMap.get( "taskSubscriberInfo" );
						linkedDocuments = (List<String>) taskMap.get( "linkedDocuments" );

						if ( !Utilities.isEmpty( linkedDocuments ) ) 
							taskMap.put("linkedDocuments", linkedDocuments);
						
						taskMap.put( "departmentID" , departmentID );
						
						searchAndLinkEntitiesToTask(taskMap, accountID, false);
						
						taskJson = objMapper.writeValueAsString( taskMap );
						mLogger.warning("Task Json \n"+taskJson);
						setTaskObject( accountID , "insert", taskMap, task );

						createHistoryMapsForServiceTasks( taskMap , task );

						if ( taskMap.containsKey( "history" ) )
							{
								mapHistoryData = createHistoryForTask( taskMap , task );

								if ( !(Boolean) mapHistoryData.get( "status" ) )
									throw new Exception( "Exception while creating custom history for task , taskMap : " + taskMap );
								mapHistoryData.remove( "status" );
								map.putAll( mapHistoryData );
							}
						
						accountsID = Utilities.correctToNull( task.getLinkedAccount() );
						linkedContacts = task.getLinkedContacts();
						dealID = task.getLinkedDeal();

						associateTaskToAccountsContactsAndDeals( accountsID , linkedContacts , dealID , task );
						createOrUpdateSearchIndexForTask( task );

						if ( !Utilities.isEmpty( listOfCustomField ) )
							{
								mapCustomField = createCustomFieldsForTask( listOfCustomField , taskMap , task );

								if ( !(Boolean) mapCustomField.get( "status" ) )
									throw new Exception( "Exception while creating custom fields for task , taskMap : " + taskMap );

								mapCustomField.remove( "status" );
								mapAllCf = (Map <String , Object>) mapCustomField.get( "customField" );
								map.putAll( mapAllCf );
							}

						if ( taskMap.containsKey( "tags" ) )
							{
								mapTagData = createTagsForTask( taskMap , task , "create" );
								mapTag = (Map <String , Object>) mapTagData.get( "tag" );
								task = (Task) mapTagData.get( "task" );
								map.put( "tag" , mapTag );
							}

						if ( taskMap.containsKey( "parentTaskID" ) )
							{
								mapSubTask = createSubTask( taskMap , task );

								if ( !(Boolean) mapSubTask.get( "status" ) )
									throw new Exception( "Exception while associating checklist for task , taskMap : " + taskMap );

								mapSubTask.remove( "status" );

								if ( !Utilities.isEmpty( mapSubTask ) )
									map.putAll( mapSubTask );
							}

						if ( !StringUtil.isBlank( task.getAssigneeID() ) && !task.getAssigneeID().equals( task.getOwnerID() ) )
							{
								isUnreadTask = true;
								task.setStatus( "unread" );
							}
						
						if(!taskMap.containsKey("dueDate"))
							task.setDueDate(getUTCTimeForTimeZonePlusOneHour("US/Pacific"));

						task = DataStoreUtil.write( task );
						
						// for new documents
						if ( !Utilities.isEmpty( documents ) ) {
							createDocumentsForTask( documents , task );
							task = DataStoreUtil.getObjectByID( Task.class , task.getID() );
						}

						taskId = task.getID();
						linkedContacts = task.getLinkedContacts();
						
						// for existing documents
						if ( !Utilities.isEmpty( linkedDocuments ) ) {
							
							mapOfDocumentInfo.put("taskID", taskId);
							mapOfDocumentInfo.put("documentIDs", linkedDocuments);
							
							requestJson = objMapper.writeValueAsString(mapOfDocumentInfo);						
							
							buffer.append(StringConstants.DS_API_URL).append(StringConstants.ASSOCIATE_DOCUMENTS_TO_TASK_URL_PATH).append("?apikey=").append(accountID);			
							CMSPutURL = buffer.toString();

							respJSON = (String) URLFetchService.URLFetch( CMSPutURL , "PUT" , "application/json" , requestJson );
							
							responseMap = objMapper.readValue(respJSON, new TypeReference<Map<String, Object>>(){});

							if(!(Boolean) responseMap.get("success"))
								throw new Exception("Unable to associate document");
						}

						NotificationSubscription pushNotificationParameter = checkTaskForPushingActiveResponseNotification( task,dealID,task.getOwnerID() );
						
						if ( (boolean) pushNotificationParameter.isPushNotification() )
							SettingsService.pushActiveResponseNotificationToQueue( pushNotificationParameter,"general" );

								Utilities.setTimeZoneAndOffset( task );

						if ( StringUtil.isBlank( task.getAssigneeID() ) )
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "pending" , taskId , null , accountID ,
									task.getDepartment() , uniqueTabID , departmentID );

						if ( isUnreadTask )
							UserChannelService.callUpdateChannelsTaskForUser_v3( "task" , "unread" , taskId , null , accountID ,
									task.getAssigneeID() , departmentID , uniqueTabID );

						// @k5r send notification mail to task assignee
						if ( !Utilities.isEmpty( mapOfTaskAssigneeEmail ) )
							{
								mapOfTaskAssigneeEmail.put( "taskID" , taskId );
								EmailService.sendMailNotificationForTaskUpdate( accountID , task.getOwnerID() , mapOfTaskAssigneeEmail , task );
							}
						
						// @k5r send mail notification to subscriber
						if ( !Utilities.isEmpty( mapOfTaskSubscriberEmail ) )
							{
								mapOfTaskSubscriberEmail.put( "taskID" , taskId );
								EmailService.sendMailNotificationForTaskUpdate( accountID , task.getOwnerID() , mapOfTaskSubscriberEmail , null );
							}
						
						addToMemcacheAndCheckSubscription(Arrays.asList(task.getID()), null);
						processWebhooks(Arrays.asList(task.getID()));
						success = true;
					}
				catch ( Exception e )
					{
						task = null;
						String params = "Params- accountId : " + accountID + "\nTask Json : " + taskJson + "\nTaskID : " + taskId + " \njson: " + json;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "success" , success );
						map.put( "task" , task );

						if ( taskMap.containsKey( "entityType" ) )
							map.put( "entityType" , (String) taskMap.get( "entityType" ) );
					}
				return map;
			}
		
		@SuppressWarnings("unchecked")
		public static Map <String , Object> readTask_v2( String accountId , String assigneeId, String departmentID, boolean ticketingSystemEnabled, String currentCursor)
			{

				boolean success = false;

				Map <String , Object> mapOfTaskData = null, responseMap = new HashMap <String , Object>();
				Map <String , Task> mapOfTask = new HashMap<String, Task>() , mapOfUnreadTask = new HashMap<String, Task>(); 
				//List<Task> listOfTask = null;
				//List<String> listOfTaskStatus = null;
				List<Entity> listOfEntity = null;
				Task taskObj = null;
				String nextCursor="";

				/*if(taskStatus.equals("pending") || taskStatus.equals("All Open"))
					listOfTaskStatus = Arrays.asList("pending","unread");
				else
					listOfTaskStatus = Arrays.asList(taskStatus);*/
					
				try
					{
						//for(String status : listOfTaskStatus) {

							List <Map <String , Object>> listOfFilterMap = new ArrayList <Map <String , Object>>();
	
							DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "accountID" , "EQUAL" , accountId );
							DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "assigneeID" , "EQUAL" , assigneeId );
							DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "departmentID" , "EQUAL" , departmentID );
							/*DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "status" , "EQUAL" , taskStatus );*/
							DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "open" , "EQUAL" , true );
							
							if("null".equalsIgnoreCase( currentCursor ))
								currentCursor = "";

								//listOfEntity = DataStoreUtil.getEntitiesWithChunkSize("Task", 1000, listOfFilterMap, null);
							mapOfTaskData = DataStoreUtil.getEntitiesUsingQueryCursor( "Task" , 500 , 500 , currentCursor , listOfFilterMap , null );
							listOfEntity = (List<Entity>) mapOfTaskData.get("entity");
							nextCursor = (String) mapOfTaskData.get("cursor");

								for(Entity entity : listOfEntity) {
									
									taskObj = new Task(entity);
									
									/*if( "unread".equals( taskStatus ))*/
									if( "unread".equals( taskObj.getStatus() ))
										mapOfUnreadTask.put( taskObj.getID() , taskObj );
									else
										mapOfTask.put( taskObj.getID() , taskObj );
								}	
						//}

						if ( !Utilities.isEmpty(mapOfUnreadTask) ) {
							responseMap.put( "unreadTasksCount" , mapOfUnreadTask.size() );
							responseMap.put( "unreadTasks" , mapOfUnreadTask );
						}
						
						success = true;
					}
				catch ( Exception e )
					{
						success = false;
						String params = "Params- assigneeId :" + assigneeId+" accountId: "+accountId+" departmentID: "+departmentID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{	
						responseMap.put( "tasksCount" , mapOfTask.size() );
						responseMap.put( "tasks" , mapOfTask );
						responseMap.put( "success" , success );
						responseMap.put("nextCursor", nextCursor);
					}

				return responseMap;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> updateTask( String userID , String accountId , String taskId , String taskJson )
			{

				boolean status = false , isAssigneeChanged = false , isUnreadTask = false , isUnreadTaskUpdate = false , isGroupChanged = false;

				String previousAssigneeID , currentAssigneeID, taskOperation = "" , currentTaskDepartment = null , 
						previousTaskDepartment = "" , uniqueTabID , departmentIDOfTask = null, utcOffsetString, respJSON;

				Map <String , Object> mapHistoryData = null, taskMap = null , mapTagData = null , mapTag = null,
										map = new HashMap <>(), linkedEntityUpdate, backendResponse;
				Map<String, List<String>> mapOfOldAssigneeToTaskID = new HashMap<String, List<String>>(), 
						taskIdsToBeRemovedFromTaskJobs = new HashMap<String, List<String>>();

				Task task = null;
				ObjectMapper objMapper = new ObjectMapper();
				List<String> linkedSubscribers = null;
				Map<String, Object> taskInfoMap = new HashMap<String, Object>(); 

				try
					{

						mLogger.log( java.util.logging.Level.INFO , "inside updateATask service, taskJson : " + taskJson );

						taskMap = objMapper.readValue( taskJson , new TypeReference <Map <String , Object>>(){} );

						try {
							task = DataStoreUtil.getObjectByID( Task.class , taskId );
						} catch( javax.jdo.JDOObjectNotFoundException e){
							mLogger.log( java.util.logging.Level.SEVERE , "Task not found, ID : " + taskId );
							return map;
						}
						
						//previousDepartmentIDOfTask = task.getDepartmentID();
						previousAssigneeID = task.getAssigneeID();
						previousTaskDepartment = task.getDepartment();
						//oldComments = task.getComments();
						taskOperation = (String) taskMap.get( "operation" );
						uniqueTabID = (String) taskMap.get( "uniqueTabID" );
						utcOffsetString = (String) taskMap.get("utcOffsetString");

						if ( taskMap.containsKey( "removetags" ) )
							TagService.removeTagsForTask( taskMap , taskId , accountId , task );

						if ( taskMap.containsKey( "isUnreadTaskUpdate" ) )
							{
								isUnreadTaskUpdate = (Boolean) taskMap.get( "isUnreadTaskUpdate" );
								if ( !"unread".equals( task.getStatus() ) )
									{
										taskMap.put( "status" , task.getStatus() );
										taskJson = objMapper.writeValueAsString( taskMap );
									}
							}
						
						linkedEntityUpdate = TaskService.updateAssociatedEntitiesForTaskUpdate( task , taskMap , userID , accountId );

						setTaskObject( accountId , "update", taskMap , task );
						
						currentTaskDepartment = task.getDepartment();
						//taskAccountID = task.getAccountID();
						currentAssigneeID = task.getAssigneeID();

						if ( taskMap.containsKey( "tags" ) )
							{
								mapTagData = createTagsForTask( taskMap , task , "update" );
								mapTag = (Map <String , Object>) mapTagData.get( "tag" );
								task = (Task) mapTagData.get( "task" );
								map.put( "tag" , mapTag );
							}
						
						if( taskMap.containsKey( "customField" ) ){
							Map<String, Object> cfResponse = CustomFieldService.updateCustomFields((List<Map<String, Object>>)taskMap.get( "customField" ), task, "task", utcOffsetString, userID, accountId);
							if((Boolean)cfResponse.get("success"))
								task = (Task) cfResponse.get("task");
						}

						if ( "reassign".equalsIgnoreCase( taskOperation ) ) {
							task.setStatus( "pending" );
							linkedSubscribers = task.getLinkedSubscribers();
							if(linkedSubscribers.contains(currentAssigneeID)) {
								linkedSubscribers.remove(currentAssigneeID);
								task.setLinkedSubscribers(linkedSubscribers);
							}
						}

						if ( !StringUtil.isBlank( currentAssigneeID ) && !currentAssigneeID.equals( previousAssigneeID )
								&& !currentAssigneeID.equals( userID ) ) {
							isAssigneeChanged = true;
							mapOfOldAssigneeToTaskID.put(previousAssigneeID, Arrays.asList(task.getID()));
						}
						else if ( StringUtil.isBlank( currentAssigneeID )
								&& ( !StringUtil.isBlank( previousTaskDepartment ) && !previousTaskDepartment
										.equalsIgnoreCase( currentTaskDepartment ) ) )
							isGroupChanged = true;

						if ( ( "pending".equals( task.getStatus() ) || "replied".equals( task.getStatus() ) ) && isAssigneeChanged )
							{
								task.setStatus( "unread" );
								isUnreadTask = true;
							}

						task = DataStoreUtil.write( task );

						taskId = task.getID();
						departmentIDOfTask = task.getDepartmentID();
						Utilities.setTimeZoneAndOffset( task );

						if ( taskMap.containsKey( "history" ) )
							{
								mapHistoryData = createHistoryForTask( taskMap , task );
								mapHistoryData.remove( "status" );
								map.putAll( mapHistoryData );
							}

						createOrUpdateSearchIndexForTask( task );
						
						taskInfoMap.put( "status" , task.getStatus() );
						taskInfoMap.put( "assigneeID" , task.getAssigneeID() );
						
						NotificationSubscription pushNotificationParameter = checkTaskForPushingActiveResponseNotification( task,task.getLinkedDeal(), userID );
						boolean isPushNotification = (boolean) pushNotificationParameter.isPushNotification();
						if (("reassign".equalsIgnoreCase( taskOperation) || isAssigneeChanged || isGroupChanged) && isPushNotification)
							SettingsService.pushActiveResponseNotificationToQueue( pushNotificationParameter, "general" );

						
						if ( "reassign".equalsIgnoreCase( taskOperation ) && !StringUtil.isBlank( currentTaskDepartment ) ) {
							
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "reassign" , taskId , null , accountId ,
									currentTaskDepartment , uniqueTabID , departmentIDOfTask );

							if ( !currentTaskDepartment.equalsIgnoreCase( previousTaskDepartment ) )
								UserChannelService.callUpdateChannelsTask_v3( "ticket" , "reassign" , taskId , null , accountId ,
										previousTaskDepartment , uniqueTabID , departmentIDOfTask );
							
						} else if( ("pending".equals(task.getStatus()) || "onhold".equals(task.getStatus()) ) 
									&& !StringUtil.isBlank( currentTaskDepartment ) ) {
							
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "pending" , taskId , null , accountId ,
									currentTaskDepartment , uniqueTabID , departmentIDOfTask );
							
						} else if ( "replied".equals(task.getStatus()) && !StringUtil.isBlank( currentTaskDepartment ) ) {
							
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "replied" , taskId , null , accountId ,
									currentTaskDepartment , uniqueTabID , departmentIDOfTask );
						}
						

						if ( isUnreadTask && !isUnreadTaskUpdate )
							UserChannelService.callUpdateChannelsTaskForUser_v3( "task" , "unread" , taskId , null , accountId ,
									currentAssigneeID , departmentIDOfTask , uniqueTabID );
						else if ( isUnreadTaskUpdate )
							UserChannelService.callUpdateChannelsTaskForUser_v3( "task" , "read" , taskId , taskInfoMap , accountId ,
									currentAssigneeID , departmentIDOfTask , null );
						else if ( "reassign".equalsIgnoreCase( taskOperation ) && !StringUtil.isBlank( previousAssigneeID ) )
							UserChannelService.callUpdateChannelsTaskForUser_v3( "task" , "read" , taskId , taskInfoMap , accountId ,
									previousAssigneeID , departmentIDOfTask , null );
						
						// @k5r send notification mail for task assignee
						Map <String , Object> mapOfTaskInfo = (Map <String , Object>) taskMap.get( "taskinfo" );
						EmailService.sendMailNotificationForTaskUpdate( accountId , userID , mapOfTaskInfo , task );
						
						if(!Utilities.isEmpty( linkedEntityUpdate )){
							
							if(!(Boolean)linkedEntityUpdate.get("success")){
								map.put("error","Unable to update linked entities");
								return map;
							}
							
							if(linkedEntityUpdate.containsKey( "deals" ))
								map.put("deals", linkedEntityUpdate.get( "deals" ));
							
							if(linkedEntityUpdate.containsKey( "backendResponse" )){
								
								respJSON = Utilities.getResponseFromFuture((Future <HTTPResponse>)linkedEntityUpdate.get("backendResponse"));
								backendResponse = objMapper.readValue(respJSON, new TypeReference <Map <String , Object>>(){} );
								
								if(!(Boolean)backendResponse.get( "success" )){
									map.put("error","Unable to update linked entities - account and/or contacts");
									return map;
								}
								
								if(backendResponse.containsKey( "contacts" ))
									map.put("contacts", backendResponse.get("contacts"));
								if(backendResponse.containsKey( "accounts" ))
									map.put("accounts", backendResponse.get("accounts"));
							}
						}

						status = true;
						
						if(currentAssigneeID == null && previousAssigneeID != null)
							taskIdsToBeRemovedFromTaskJobs.put(previousAssigneeID, Arrays.asList(task.getID()));
						
						if(!Utilities.isEmpty(taskIdsToBeRemovedFromTaskJobs)) {
							Queue queue = QueueFactory.getQueue( "DueDateReminders" );
							queue.add( TaskOptions.Builder.withUrl( "/removeTaskJobsFromMemcache" ).method( Method.POST ).payload(objMapper.writeValueAsString(taskIdsToBeRemovedFromTaskJobs)));
						}
						
						addToMemcacheAndCheckSubscription(Arrays.asList(task.getID()), mapOfOldAssigneeToTaskID);
						if ("reassign".equalsIgnoreCase(taskOperation))
							processWebhooks(Arrays.asList(task.getID()));

					}
				catch ( Exception e )
					{
						status = false;
						String params = "Params- accountId : " + accountId + "\ntaskId : "+ taskId + "\nTask Json : " + taskJson;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "status" , status );
						map.put( "task" , task );
						map.put( "date" , new Date() );

						if ( map.containsKey( "entityType" ) )
							map.put( "entityType" , (String) map.get( "entityType" ) );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> resolveTask( String userLogin , String accountId , String taskId , 
															String taskJson , String callType , String connectionID )
			{

				boolean status = false;

				String uniqueTabID = null , departmentIDOfTask = null, entityType = null , contactID = null;

				List <String> linkedContacts = null;

				Map <String , Object> taskMap = null, responseMap = new HashMap <String , Object>(), taskInfoMap = new HashMap<String, Object>();

				Task task = null , updatedTask = null;
				ObjectMapper objMapper = new ObjectMapper();

				try
					{
						taskMap = objMapper.readValue( taskJson , new TypeReference <Map <String , Object>>()
							{
							} );
						task = DataStoreUtil.getObjectByID( Task.class , taskId );
						
						if( task == null )
							return responseMap;

						uniqueTabID = (String) taskMap.get( "uniqueTabID" );
						entityType = (String) taskMap.get( "entityType" );

						departmentIDOfTask = task.getDepartmentID();
						linkedContacts = task.getLinkedContacts();

						if ( !Utilities.isEmpty( linkedContacts ) )
							contactID = linkedContacts.get( 0 );

						if(taskMap.containsKey("assigneeID") && taskMap.containsKey("department") && taskMap.containsKey("departmentID")){
							task.setAssigneeID( (String)taskMap.get("assigneeID") );
							task.setDepartment( (String)taskMap.get("department") );
							task.setDepartmentID( (String)taskMap.get("departmentID") );
						}

						if ( taskMap.containsKey( "history" ) && !taskMap.containsKey( "isSendMail" ) )
							{

								String historyID = null , historyJson = null;
								Map <String , Object> mapHistory = null;
								Object historyObj = null;

								historyObj = taskMap.get( "history" );

								if ( historyObj instanceof String )
									mapHistory = objMapper.readValue( (String) historyObj , new TypeReference <Map <String , Object>>()
										{
										} );
								else if ( historyObj instanceof Map )
									mapHistory = (Map <String , Object>) historyObj;

								historyID = UUID.randomUUID().toString();
								mapHistory.put( "historyID" , historyID );
								historyJson = objMapper.writeValueAsString( mapHistory );

								Queue queue = QueueFactory.getQueue( "Activity-Log" );
								queue.add( TaskOptions.Builder.withUrl( "/insertHistoryJob" ).method( Method.POST ).payload( historyJson ) );

								mapHistory.remove( "historyID" );
								mapHistory.put( "id" , historyID );

								responseMap.put( "history" , mapHistory );
							}

						task.setStatus( "completed" );
						updatedTask = DataStoreUtil.write( task );

						departmentIDOfTask = updatedTask.getDepartmentID();

						taskId = updatedTask.getID();

						Utilities.setTimeZoneAndOffset( updatedTask );

						deleteSearchIndexForTask( accountId , updatedTask );

						taskInfoMap.put("status",updatedTask.getStatus());
						taskInfoMap.put("assigneeID",updatedTask.getAssigneeID());

						if ( !StringUtil.isBlank( entityType ) && entityType.equals( "lead" ) )
							UserChannelService.callUpdateChannelsTask_v3( "lead" , "update" , contactID , null , accountId , null ,
									uniqueTabID , departmentIDOfTask );

						if ( !StringUtil.isBlank( taskId ) && !StringUtil.isBlank( accountId ) )
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "completed" , taskId , null , accountId ,
									updatedTask.getDepartment() , uniqueTabID , departmentIDOfTask );

						if ( !StringUtil.isBlank( connectionID ) && !"fetch".equalsIgnoreCase( callType ) )
							{
								mLogger.log( java.util.logging.Level.INFO , "going to add taskqueue updateResolveTaskInteraction, taskID : "
										+ taskId );
								updateTaskStatusToActiveResponse( userLogin , "Completed-Resolved" , updatedTask , connectionID );
							}

						if ( "completed".equalsIgnoreCase( task.getStatus() ) && !StringUtil.isBlank( task.getAssigneeID() ) )
							UserChannelService.callUpdateChannelsTaskForUser_v3( "task" , "read" , taskId , taskInfoMap , accountId ,
									task.getAssigneeID() , departmentIDOfTask , null );
						
						status = true;
						
						addToMemcacheAndCheckSubscription(Arrays.asList(task.getID()), null);
					}
				catch ( Exception e )
					{
						String params = "Params- accountId : " + accountId+ "\ntaskId : " + taskId + "\nTask Json : "+ taskJson+" userLogin: "+userLogin;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						responseMap.put( "success" , status );
						responseMap.put( "task" , updatedTask );
					}

				return responseMap;
			}

		// @srk for task api
		public static Map <String , Object> deleteTask( String userLogin, String accountId , String taskId , 
														String taskJson , String callType , String connectionID )
			{

				boolean status = false;

				String uniqueTabID = null , departmentIDOfTask = null , entityType = null , contactID = null;

				Map <String , Object> taskMap=null, responseMap = new HashMap <String , Object>();

				List <String> linkedContacts = null;

				Task task = null;
				ObjectMapper objMapper = new ObjectMapper();

				try
					{

						if ( !StringUtil.isBlank( taskJson ) )
							{
								taskMap = objMapper.readValue( taskJson , new TypeReference <Map <String , Object>>()
									{
									} );
								uniqueTabID = (String) taskMap.get( "uniqueTabID" );
							}

						entityType = (String) taskMap.get( "entityType" );

						task = DataStoreUtil.getObjectByID( Task.class , taskId );
						departmentIDOfTask = task.getDepartmentID();
						linkedContacts = task.getLinkedContacts();

						if ( !Utilities.isEmpty( linkedContacts ) )
							contactID = linkedContacts.get( 0 );

						task.setStatus( "deleted" );
						task = DataStoreUtil.write( task );

						if ( !StringUtil.isBlank( connectionID ) && !"fetch".equalsIgnoreCase( callType ) )
							{

								// update the interaction as completed in AR

								String arJson = null;
								Map <String , Object> mapAr = new HashMap <String , Object>();

								mapAr.put( "taskID" , taskId );
								mapAr.put( "userlogin" , userLogin );
								mapAr.put( "arstatus" , "Deleted" );
								mapAr.put( "connectionID" , connectionID );

								arJson = objMapper.writeValueAsString( mapAr );

								Queue queue = QueueFactory.getQueue( "Tasks" );
								queue.add( TaskOptions.Builder.withUrl( "/updateResolveTaskInteraction" ).method( Method.POST ).payload( arJson ) );
							}
						departmentIDOfTask = task.getDepartmentID();

						Utilities.setTimeZoneAndOffset( task );

						deleteSearchIndexForTask( accountId , task );

						if ( !StringUtil.isBlank( entityType ) && entityType.equals( "lead" ) )
							UserChannelService.callUpdateChannelsTask_v3( "lead" , "update" , contactID , null , accountId , null , uniqueTabID ,
									departmentIDOfTask );

						if ( !StringUtil.isBlank( taskId ) && !StringUtil.isBlank( accountId ) )
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "deleted" , taskId , null , accountId , task.getDepartment() ,
									uniqueTabID , departmentIDOfTask );

						if ( "deleted".equalsIgnoreCase( task.getStatus() ) && !StringUtil.isBlank( task.getAssigneeID() ) ){
							
							Map<String, Object> taskInfoMap = new HashMap<String, Object>(); 
							taskInfoMap.put( "status" , task.getStatus() );
							taskInfoMap.put( "assigneeID" , task.getAssigneeID() );
							
							UserChannelService.callUpdateChannelsTaskForUser_v3( "task" , "read" , taskId , taskInfoMap , accountId , task.getAssigneeID() ,
									departmentIDOfTask , null );
						}
						
						status = true;
						
						addToMemcacheAndCheckSubscription(Arrays.asList(task.getID()), null);
					}
				catch ( Exception e )
					{
						String params = "Params- accountId : " + accountId+ "\n taskId : " + taskId+" userLogin: "+userLogin+" taskJson: "+taskJson+
								"callType: "+callType+" connectionID: "+connectionID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						responseMap.put( "success" , status );
						responseMap.put( "task" , task );

						if ( taskMap.containsKey( "entityType" ) )
							responseMap.put( "entityType" , (String) taskMap.get( "entityType" ) );
					}
				return responseMap;
			}

		// @srk for task api
		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> deleteBulkTasks( String accountId , List<String> listOfTaskIds )
			{

				boolean status = false;
				String taskId = "" , accountsID = null, cmsJson;

				Long dealID = null;

				List <Long> listOfLinkedDeals = new ArrayList <Long>();
				List <Task> listOfTaskObj = new ArrayList <Task>(), listOfTasksFrmDb = null;
				
				List <String> listOfLinkedAccounts = new ArrayList <String>() , listOfLinkedDocuments = new ArrayList <String>() , 
						listOfLinkedCustomFields = new ArrayList <String>() , listOfLinkedTasks = new ArrayList <String>(),
						listOfLinkedContacts = new ArrayList <String>(), listOfContactId = null , 
						listOfDocumentId = null , listOfCustomFieldID = null , listOfLinkedTaskID = null;

				Map <Long , Deal> mapOfDealData = new HashMap <Long , Deal>();
				Map <String , Object> responseMap = new HashMap <String , Object>(), mapOfDealInfo = new HashMap <String , Object>(), 
						mapOfCmsData = new HashMap <String , Object>();

				ObjectMapper objMapper = new ObjectMapper();

				try
					{

						if( Utilities.isEmpty(listOfTaskIds) ) {
							status = true;
							return responseMap;
						}
					
						listOfTasksFrmDb = TaskDAO.getTasksByTaskIDS( listOfTaskIds );
						
						if( Utilities.isEmpty( listOfTasksFrmDb ) )
							{
								status = true;
								return responseMap;
							}

						listOfTaskIds.clear();

						for ( Task taskObjInItr : listOfTasksFrmDb )
							{

								accountsID = null;
								dealID = null;

								listOfTaskObj.add( taskObjInItr );

								taskId = taskObjInItr.getID();
								dealID = taskObjInItr.getLinkedDeal();
								listOfContactId = taskObjInItr.getLinkedContacts();
								accountsID = taskObjInItr.getLinkedAccount();
								accountsID = Utilities.correctToNull( accountsID );
								listOfDocumentId = taskObjInItr.getLinkedDocuments();
								listOfCustomFieldID = taskObjInItr.getLinkedCustomFields();
								listOfLinkedTaskID = taskObjInItr.getLinkedTasks();

								listOfTaskIds.add( taskId );

								if ( !Utilities.isEmpty( listOfContactId ))
									listOfLinkedContacts.addAll( listOfContactId );

								if ( dealID != null )
									listOfLinkedDeals.add( dealID );

								if ( !StringUtil.isBlank( accountsID ) )
									listOfLinkedAccounts.add( accountsID );
								
								if ( !Utilities.isEmpty( listOfDocumentId ) )
									listOfLinkedDocuments.addAll( listOfDocumentId );
								
								if ( !Utilities.isEmpty( listOfCustomFieldID ) )
									listOfLinkedCustomFields.addAll( listOfCustomFieldID );
								
								if ( !Utilities.isEmpty( listOfLinkedTaskID ) )
									listOfLinkedTasks.addAll( listOfLinkedTaskID );

								taskObjInItr.setStatus( "deleted" );
								taskObjInItr.setLinkedTags( null );
//								taskObjInItr.setLastUpdatedDate( new Date() );
							}

						DataStoreUtil.batchWrite( listOfTasksFrmDb );

						if ( !Utilities.isEmpty( listOfLinkedDeals ) )
							{

								mapOfDealInfo = DealService.dissociateBulkTasksFromDeals( accountId , listOfTaskIds , listOfLinkedDeals );
								mapOfDealData = (Map <Long , Deal>) mapOfDealInfo.get( "deal" );
								responseMap.put( "deal" , mapOfDealData );
							}


						if ( !Utilities.isEmpty( listOfLinkedAccounts ) )
							mapOfCmsData.put( "linkedAccounts" , listOfLinkedAccounts );
						
						if ( !Utilities.isEmpty( listOfLinkedContacts ) )
							mapOfCmsData.put( "linkedContacts" , listOfLinkedContacts );
						
						if ( !Utilities.isEmpty( listOfLinkedDocuments ) )
							mapOfCmsData.put( "linkedDocuments" , listOfLinkedDocuments );
						
						if ( !Utilities.isEmpty( listOfLinkedCustomFields ) )
							mapOfCmsData.put( "linkedCustomFields" , listOfLinkedCustomFields );
						
						if( !mapOfCmsData.isEmpty() )
							{
								mapOfCmsData.put( "linkedTasks" , listOfTaskIds );

								cmsJson = objMapper.writeValueAsString( mapOfCmsData );

								cmsJson = (String) URLFetchService.dissociateTasksFromAccountsAndContacts( accountId , cmsJson );
							}

						deleteSearchIndexForTask( accountId , listOfTasksFrmDb );
						status = true;
						
						addToMemcacheAndCheckSubscription(listOfTaskIds, null);
					}
				catch ( Exception e )
					{
						String params = "Params- accountId : " + accountId+ "\n listOfTaskIds : " + listOfTaskIds;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params, e );
					}
				finally
					{
						responseMap.put( "success" , status );
						responseMap.put( "ids" , listOfTaskIds );
						responseMap.put( "tasks" , listOfTaskObj );
					}
				return responseMap;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> rescheduleBulkTasks( String accountId , String taskJson )
			{

				boolean status = false;

				String scheduledDateStr = null , scheduledTimeStr = null;

				List <String> listOfTaskIds = new ArrayList <String>();
				List <Object> listOfTaskObjects = new ArrayList <Object>();
				List <Task> listOfPersistedTasks = new ArrayList <Task>();
				List <Long> listOfDealId = new ArrayList <Long>();
				List <Deal> listOfDeal = new ArrayList <Deal>();

				Map <String , Object> responseMap = new HashMap <String , Object>(), mapOfTaskData = new HashMap <String , Object>();
				Map <Long , Deal> mapOfDealInfo = new HashMap <Long , Deal>();

				Date scheduledDate = null;
				SimpleDateFormat sdfDateAndTime = new SimpleDateFormat( "MM/dd/yyyy hh:mm a" );
				ObjectMapper objMapper = new ObjectMapper();

				Long dealID = null;

				try
					{
						mapOfTaskData = objMapper.readValue( taskJson , new TypeReference <Map <String , Object>>(){} );
						
						if( !mapOfTaskData.containsKey( "tasks" ) )
								return responseMap;

						listOfTaskIds = (List <String>) mapOfTaskData.get( "tasks" );
						scheduledDateStr = (String) mapOfTaskData.get( "dueDate" );
						scheduledTimeStr = (String) mapOfTaskData.get( "dueTime" );

						scheduledDate = sdfDateAndTime.parse( scheduledDateStr + " " + scheduledTimeStr );

						listOfPersistedTasks = TaskDAO.rescheduleBulkTasks( accountId , scheduledDate , listOfTaskIds );
						
						if( Utilities.isEmpty( listOfPersistedTasks ) )
								return responseMap;

						listOfTaskIds.clear();

						for ( Task taskObj : listOfPersistedTasks )
							{

								listOfTaskObjects.add( taskObj );
								Utilities.setTimeZoneAndOffset( taskObj );
								
								listOfTaskIds.add(taskObj.getID());

								dealID = taskObj.getLinkedDeal();

								if ( dealID != null )
									listOfDealId.add( dealID );
							}

						if ( !Utilities.isEmpty( listOfDealId ) )
							{
								 
								listOfDeal = DealDAO.getDeal( accountId, listOfDealId );
								listOfDeal = (List<Deal>) DataStoreUtil.batchWrite( listOfDeal );

								for ( Deal dealObj : listOfDeal )
									{
										mapOfDealInfo.put( dealObj.getID() , dealObj );
									}
								responseMap.put( "deal" , mapOfDealInfo );
							}
						
						status = true;
						
						addToMemcacheAndCheckSubscription(listOfTaskIds, null);
					}
				catch ( Exception e )
					{
						String params = "Params- accountId : "+ accountId + "\n TaskJson : " + taskJson;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						responseMap.put( "success" , status );
						responseMap.put( "tasks" , listOfTaskObjects );
					}
				return responseMap;
			}

		// @srk for task api
		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> resolveBulkTasks( String accountId , String taskJson )
			{

				boolean status = false;
				String taskId = "" , resolutionComments = "" , userId = "" , historyTypeIdForCall = "", 
					   userName = "" , accountsID = null, cmsJson = null;

				Long dealID = null;

				List <Long> listOfLinkedDeals = new ArrayList <Long>(); 
				List <Task> listOfTaskObj = new ArrayList <Task>() , listOfTasksFrmDataStore = null, listOfPersistedTasks = new ArrayList <Task>();
				
				List <String> listOfLinkedAccounts = new ArrayList <String>(), listOfLinkedContacts = new ArrayList <String>(), 
						listOfLinkedTaskID = null, listOfLinkedTasks = new ArrayList <String>(),
						listOfContactId = null, listOfTaskIds = new ArrayList <String>();

				Map <Long , Deal> mapOfDealData = new HashMap <Long , Deal>();
				Map <String , Object> responseMap = new HashMap <String , Object>(), mapOfTaskData = new HashMap <String , Object>(),
										mapOfDealInfo = new HashMap <String , Object>(), mapOfHistoryData = new HashMap <String , Object>(),
										mapOfCmsData = new HashMap <String , Object>();

				ObjectMapper objMapper = new ObjectMapper();

				try
					{
						mapOfTaskData = objMapper.readValue( taskJson , new TypeReference <Map <String , Object>>(){} );
						
						if( !mapOfTaskData.containsKey( "tasks" ) )
							return responseMap;

						listOfTaskIds = (List <String>) mapOfTaskData.get( "tasks" );
						listOfTasksFrmDataStore = TaskDAO.getTasksByTaskIDS( listOfTaskIds );
						
						if( Utilities.isEmpty(listOfTasksFrmDataStore) )
							{
								status = true;
								return responseMap;
							}

						listOfTaskIds.clear();

						for ( Task taskObjInItr : listOfTasksFrmDataStore )
							{

								listOfTaskObj.add( taskObjInItr );

								taskId = taskObjInItr.getID();
								listOfContactId = taskObjInItr.getLinkedContacts();
								dealID = taskObjInItr.getLinkedDeal();
								accountsID = taskObjInItr.getLinkedAccount();
								listOfLinkedTaskID = taskObjInItr.getLinkedTasks();

								listOfTaskIds.add( taskId );

								if ( !Utilities.isEmpty( listOfContactId ) )
										listOfLinkedContacts.addAll( listOfContactId );

								if ( dealID != null )
										listOfLinkedDeals.add( dealID );

								if ( !StringUtil.isBlank( accountsID ) )
										listOfLinkedAccounts.add( accountsID );

								if ( !Utilities.isEmpty( listOfLinkedTaskID ) )
									listOfLinkedTasks.addAll( listOfLinkedTaskID );

								taskObjInItr.setStatus( "completed" );
								taskObjInItr.setLinkedTags( null );
//								taskObjInItr.setLastUpdatedDate( new Date() );
							}

						if ( !Utilities.isEmpty( listOfLinkedTasks ) )
							{
								List <Task> listLinkedTasks = TaskDAO.getTasksByLinkedTasks( listOfLinkedTasks );

								if ( !Utilities.isEmpty( listLinkedTasks ) )
									{

										for ( Task childTask : listLinkedTasks )
											{
												childTask.setStatus( "completed" );
//												childTask.setLastUpdatedDate( new Date() );
											}

										DataStoreUtil.batchWrite( listLinkedTasks );
										responseMap.put( "childtask" , listOfLinkedTasks );
									}
							}

						listOfPersistedTasks = (List <Task>) DataStoreUtil.batchWrite( listOfTasksFrmDataStore );

						resolutionComments = (String) mapOfTaskData.get( "resolutioncomments" );
						userId = (String) mapOfTaskData.get( "userid" );
						//historyTypeIdForCall = (String) mapOfTaskData.get( "historytypeidforcall" );
						userName = (String) mapOfTaskData.get( "userName" );

						mapOfHistoryData = HistoryService.insertHistoryForBulkTasks( accountId , userId , userName ,
								listOfPersistedTasks , resolutionComments);
						responseMap.putAll( mapOfHistoryData );

						if ( !Utilities.isEmpty( listOfLinkedDeals ) )
							{
								mapOfDealInfo = DealService.dissociateBulkTasksFromDeals( accountId , listOfTaskIds , listOfLinkedDeals );

								mapOfDealData = (Map <Long , Deal>) mapOfDealInfo.get( "deal" );
								responseMap.put( "deal" , mapOfDealData );
							}

						
						if ( !Utilities.isEmpty( listOfLinkedAccounts ))
							mapOfCmsData.put( "linkedAccounts" , listOfLinkedAccounts );
						
						if ( !Utilities.isEmpty( listOfLinkedContacts ))
							mapOfCmsData.put( "linkedContacts" , listOfLinkedContacts );
						
						if( !mapOfCmsData.isEmpty() )
							{
								mapOfCmsData.put( "linkedTasks" , listOfTaskIds );

								cmsJson = objMapper.writeValueAsString( mapOfCmsData );

								cmsJson = (String) URLFetchService.dissociateTasksFromAccountsAndContacts( accountId , cmsJson );
							}

						deleteSearchIndexForTask( accountId , listOfPersistedTasks );
						
						status = true;
						
						addToMemcacheAndCheckSubscription(listOfTaskIds, null);
					}
				catch ( Exception e )
					{
						String params = "Params- accountId : "+ accountId + "\n TaskJson : " + taskJson;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						responseMap.put( "success" , status );
						responseMap.put( "ids" , listOfTaskIds );
						responseMap.put( "tasks" , listOfTaskObj );
					}
				return responseMap;
			}

		// @author srk for task api
		private static void setTaskObject( String accountId , String operation , Map <String , Object> mapOfTask , Task task ) throws Exception
			{

				if ( Utilities.isEmpty( mapOfTask ) )
					throw new Exception("Task JSON is empty");

				if ( "insert".equals( operation ) )
					{
						task.setAccountID( accountId );
						task.setStatus( "pending" );
					}
				
				Utilities.applyMapOntoInstance( task , mapOfTask );
				
//				task.setLastUpdatedDate( new Date() );
			}

		public static Map <String , Object> getATask( String accountId , String taskId , String json )
			{

				boolean status = false;

				String departmentIDOfTask = null, utcOffsetString/*, taskTypeName*/;

				//Map <String , Task> taskMap = new HashMap <String , Task>();
				Map <String , Object> map = new HashMap <String , Object>(), inputMap, cfMap;

				Task taskObj = null;
				ObjectMapper mapper = new ObjectMapper();

				try
					{

						taskObj = DataStoreUtil.getObjectByFilter( Task.class , "accountID == '" + accountId + "' && ID == '" + taskId + "'" );

						if ( taskObj != null )
							{
								Utilities.setTimeZoneAndOffset( taskObj );
								departmentIDOfTask = taskObj.getDepartmentID();
							}

						if ( !StringUtil.isBlank( json ) )
							{
								Map <String , Object> mapDepartment = checkDepartmentForTask( json , departmentIDOfTask );

								if ( !Utilities.isEmpty( mapDepartment ) )
									map.putAll( mapDepartment );
							}

						if(!StringUtil.isBlank(json) && taskObj != null){
							
							inputMap = mapper.readValue(json, HashMap.class);
							
							if(!Utilities.isEmpty(taskObj.getLinkedCustomFields()) && inputMap.containsKey( "customField") && (Boolean)inputMap.get("customField")){
								
								utcOffsetString = (String) inputMap.get("utcOffsetString");
								if(StringUtil.isBlank(utcOffsetString))
									utcOffsetString = "GMT+0000";
								
								cfMap = CustomFieldService.getCustomFields( accountId , taskObj.getLinkedCustomFields() , utcOffsetString );
								
								if((Boolean)cfMap.get( "success" ))
									map.put("customField",cfMap.get("customField"));
							}
							
						/*	if(inputMap.containsKey( "isTaskTypeNeeded" ) && (Boolean)inputMap.get("isTaskTypeNeeded")){
								taskTypeName = TaskTypeService.getTaskTypeByTypeID( taskObj.getType() );
								map.put("taskTypeName", taskTypeName);
							}  */
						}

						//taskMap.put( taskId , taskObj );
						status = true;
					}
				catch ( Exception e )
					{
						String params = "Params- taskId : " + taskId+" accountId: "+accountId+" json: "+json;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "task" , taskObj );
						map.put( "taskId" , taskId );
						map.put( "status" , status );
						map.put( "date" , new Date() );
					}

				return map;
			}

		public static Map <String , Object> removeContactFromTask( String accountId , String json )
			{

				boolean status = false;

				String contactId = "" , taskId = "" , respJson = null;

				List <String> linkedContacts = null;

				Map <String , Object> mapOfJsData = null , mapForOneContact = null;
				Map <String , Object> responseMap = new HashMap <String , Object>() , responseContactMap = new HashMap <String , Object>();

				Contact contact = null;
				List<Contact> listOfContact = new ArrayList<Contact>();
				Task taskObjFrmDb = null , updatedTask = null;
				ObjectMapper objMapper = new ObjectMapper();
				objMapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES , false );
				JsonNode rootNode = null , successNode = null , contactNode = null;

				try
					{

						mapOfJsData = objMapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						contactId = (String) mapOfJsData.get( "contactID" );
						taskId = (String) mapOfJsData.get( "taskID" );

						respJson = (String) URLFetchService.dissociateTaskFromContact( accountId , contactId , taskId );

						rootNode = objMapper.readValue( respJson , JsonNode.class );
						successNode = rootNode.path( "status" );

						if ( successNode.isMissingNode() || !successNode.booleanValue() )
							throw new Exception( "Exception Occurred While Removing A Task From Contact, contactId : " + contactId + "\n taskId : "
									+ taskId );

						contactNode = rootNode.path( "contact" );
						contact = objMapper.convertValue( contactNode , new TypeReference <Contact>()
							{
							} );

						listOfContact.add(contact);
//						mapForOneContact = ContactService.constructReqFieldsForContact( contact );
//						responseContactMap.put( contact.getID() , mapForOneContact );

						taskObjFrmDb = DataStoreUtil.getObjectByID( Task.class , taskId );

						linkedContacts = taskObjFrmDb.getLinkedContacts();
	
						if ( linkedContacts != null )
								linkedContacts.remove( contactId );
						
						updatedTask = DataStoreUtil.write( taskObjFrmDb );
						status = true;
					}
				catch ( Exception e )
					{
						String params = "accountID :" + accountId + "\n contactid :  " + contactId + "\n taskid : "
								+ taskId +" json: "+json+" respJson: "+respJson;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}

				finally
					{
						responseMap.put( "success" , status );
						responseMap.put( "task" , updatedTask );
						responseMap.put( "contacts" , listOfContact );
					}

				return responseMap;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> getTasksForIds( String accountId , String json )
			{

				boolean success = false;

				List <String> listOfTaskId = null;
				List <Task> listOfTaskObj = null , listAllTasks = null;

				Map <String , Object> mapOfInput = new HashMap <String , Object>(),
									responseMap = new HashMap <String , Object>();

				ObjectMapper objMapper = new ObjectMapper();

				try
					{

						mapOfInput = objMapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						listOfTaskId = (List <String>) mapOfInput.get( "tasks" );
						
						if(Utilities.isEmpty( listOfTaskId ))
							{
								success = true;
								return responseMap;
							}

						listOfTaskObj = TaskDAO.getTasksByTaskIDS( listOfTaskId );

						Collections.sort( listOfTaskObj , new Utilities().new CreatedDateDesc() );

						listAllTasks = new ArrayList <Task>();

						for ( Task task : listOfTaskObj )
							{

								if ( "deleted".equalsIgnoreCase( task.getStatus() ) || !task.getAccountID().equals( accountId ) )
									continue;

								listAllTasks.add( task );
							}
						
						success = true;
					}
				catch ( Exception e )
					{
						
						String params = "Params- accountID: "+accountId+" json: "+json;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						responseMap.put( "success" , success );
						responseMap.put( "tasks" , listAllTasks );
					}

				return responseMap;
			}

		public static boolean associateTaskToContact( String accountId , String contactId , String taskID )
			{

				boolean status = false;

				String jsonFrmCms = "";

				ObjectMapper objMapper = new ObjectMapper();
				JsonNode rootNode = null , successNode = null;

				try
					{

						jsonFrmCms = (String) URLFetchService.associateTaskToContact( accountId , contactId , taskID );
						rootNode = objMapper.readValue( jsonFrmCms , JsonNode.class );

						if ( rootNode != null )
							{

								successNode = rootNode.path( "status" );
								if ( successNode.isMissingNode() || !successNode.booleanValue() )
									{
										return status;
									}
								status = successNode.booleanValue();
							}
					}
				catch ( Exception e )
					{
						String params = "Params- accountId : " + accountId+ "\n contactId : " + contactId + "\n taskID : " + taskID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				return status;
			}

		public static boolean addTaskOfDealToAccount( String apikey , Long dealID , String accountId , List <String> listOfTaskID ) throws Exception
			{

				boolean isTaskMoved = false;
				List <Task> listOfTask = null;
//				Date todaysDate = new Date();

				listOfTask = TaskDAO.getTasksByIDAndStatus( listOfTaskID, "pending" );

				for ( Task task : listOfTask )
					{
						task.setLinkedAccount( accountId );
//						task.setLastUpdatedDate( todaysDate );
					}

				DataStoreUtil.batchWrite( listOfTask );

				isTaskMoved = true;

				return isTaskMoved;
			}

		@SuppressWarnings(
			{ "static-access" , "unchecked" } )
		public static Map <String , Object> getTasksForTaskPage( String accountID, String assigneeID , String json )
			{

				boolean status = false , isOnLoad = false;

				String fromDateStr , toDateStr, sortOrder, sortColumn, nextCursor = "", previousCursor, departmentID;

				List <String> listOfTaskID = null;

				Map <String , Task> mapOfTask = null;
				Map <String , Object> mapOfInput = null , mapOfTaskData = null, responseMap = new HashMap <String , Object>();

				Date fromDate = null , toDate = null;
				Calendar cFromDate = Calendar.getInstance(), cToDate = Calendar.getInstance();
				ObjectMapper objMapper = new ObjectMapper();
				SimpleDateFormat sdf = new SimpleDateFormat( "MM/dd/yyyy" );
				Task tempTask = null;

				try
					{

						mapOfInput = objMapper.readValue( json , new TypeReference <Map <String , Object>>(){} );

						departmentID = Utilities.getStringValueFromMap( "departmentID", mapOfInput );
						fromDateStr = Utilities.getStringValueFromMap( "fromdate", mapOfInput );
						toDateStr = Utilities.getStringValueFromMap( "todate", mapOfInput );
						sortOrder = Utilities.getStringValueFromMap( "sortorder", mapOfInput );
						sortColumn = Utilities.getStringValueFromMap( "sortcolumn", mapOfInput );
						previousCursor = Utilities.getStringValueFromMap( "cursor", mapOfInput );

						if ( mapOfInput.containsKey( "onload" ) )
							isOnLoad = (Boolean) mapOfInput.get( "onload" );

						if ( isOnLoad )
							{

								cToDate.setTime( new Date() );
								cToDate.set( cToDate.get( cToDate.YEAR ) , cToDate.get( cToDate.MONTH ) , cToDate.get( cToDate.DATE ) , 23 , 59 , 59 );
								toDate = cToDate.getTime();
							}

						if ( !StringUtil.isBlank( fromDateStr ) )
							{

								fromDate = sdf.parse( fromDateStr );
								cFromDate.setTime( fromDate );
								cFromDate.set( cFromDate.get( cFromDate.YEAR ) , cFromDate.get( cFromDate.MONTH ) , cFromDate.get( cFromDate.DATE ) ,
										00 , 00 , 00 );
								fromDate = cFromDate.getTime();
							}

						if ( !StringUtil.isBlank( toDateStr ) )
							{

								toDate = sdf.parse( toDateStr );
								cToDate.setTime( toDate );
								cToDate.set( cToDate.get( cToDate.YEAR ) , cToDate.get( cToDate.MONTH ) , cToDate.get( cToDate.DATE ) , 23 , 59 , 59 );
								toDate = cToDate.getTime();
							}

						mapOfTaskData = TaskDAO.getTasksForTaskPage_v2( accountID , assigneeID , isOnLoad , fromDate , toDate , sortColumn ,
								sortOrder , previousCursor , "pending" , departmentID );

						if ( mapOfTaskData == null )
							throw new NullPointerException( "Tasks not fetched" );

						mapOfTask = (Map <String , Task>) mapOfTaskData.get( "tasks" );

						nextCursor = (String) mapOfTaskData.get( "cursor" );
						listOfTaskID = (List <String>) mapOfTaskData.get( "ids" );

						if ( !Utilities.isEmpty( mapOfTask ) )
							{
								for ( String taskID : mapOfTask.keySet() )
									{
										tempTask = (Task) mapOfTask.get( taskID );
										Utilities.setTimeZoneAndOffset( tempTask );
									}
								
								//setPopUpForTasksInMap( mapOfTask , accountID );
							}
						status = true;
					}
				catch ( Exception e )
					{
						String params = "Params- accountID : " + accountID + "\n json : " + json+" assigneeID: "+assigneeID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						responseMap.put( "status" , status );
						responseMap.put( "task" , mapOfTask );
						responseMap.put( "cursor" , nextCursor );
						responseMap.put( "ids" , listOfTaskID );
					}
				return responseMap;
			}

		public static Map <String , Map <String , Object>> getRelatedToInfoForListOfTask( String accountID , List <String> listOfTaskId ) throws Exception
			{

				if ( listOfTaskId == null || listOfTaskId.isEmpty() )
					throw new NullPointerException( "List Of Task is empty" );

				Long dealId = null;
				String contactId = null , taskId = null , relatedTo = null , accountsID = null;
				List <Task> listOfTask = null;
				Map <String , Object> mapOfTaskRelatedToInfo = null;
				Map <String , Map <String , Object>> map = new LinkedHashMap <String , Map <String , Object>>();

				listOfTask = TaskDAO.getTasksByIDAndOpenStatus( listOfTaskId, true );

				for ( Task lTaskFromItr : listOfTask )
					{
						taskId = null;
						dealId = null;
						contactId = null;
						relatedTo = null;
						mapOfTaskRelatedToInfo = new HashMap <String , Object>();

						taskId = lTaskFromItr.getID();

						if ( !StringUtil.isBlank( lTaskFromItr.getLinkedAccount() ) )
							{
								relatedTo = "Account";
								accountsID = lTaskFromItr.getLinkedAccount();
							}
						else if ( lTaskFromItr.getLinkedDeal() != null )
							{
								relatedTo = "Deal";
								dealId = lTaskFromItr.getLinkedDeal();
							}
						else if ( !Utilities.isEmpty(lTaskFromItr.getLinkedContacts()) )
							{
								relatedTo = "Contact";
								contactId = lTaskFromItr.getLinkedContacts().get( 0 );
							}

						mapOfTaskRelatedToInfo.put( "taskid" , taskId );
						mapOfTaskRelatedToInfo.put( "relatedto" , relatedTo );
						mapOfTaskRelatedToInfo.put( "dealid" , dealId );
						mapOfTaskRelatedToInfo.put( "contactid" , contactId );
						mapOfTaskRelatedToInfo.put( "accountid" , accountsID );
						map.put( taskId , mapOfTaskRelatedToInfo );
					}

				return map;
			}

		public static Map <String , Object> changeAccountIDForTask( String json )
			{

				String moveToAccount = null;
				boolean success = false;
				List <String> linkedTasks = null;
				List <Task> listOfTask = null;
				JsonNode rootJsonNode = null;
				Map <String , Object> map = new HashMap <String , Object>();
				ObjectMapper mapper = new ObjectMapper();
				List<String> listOfTaskIds = new ArrayList<String>();

				try
					{

						rootJsonNode = mapper.readValue( json , JsonNode.class );
						moveToAccount = rootJsonNode.path( "moveTo" ).textValue();

						JsonNode taskNode = rootJsonNode.path( "taskID" );
						linkedTasks = mapper.convertValue( taskNode , new TypeReference <List <String>>()
							{
							} );

						if ( Utilities.isEmpty( linkedTasks ) || StringUtil.isBlank( moveToAccount ) )
							throw new NullPointerException( "JSON is empty" );

						listOfTask = TaskDAO.getTasksByIDAndStatus( linkedTasks, "pending" );
						if ( Utilities.isEmpty( listOfTask ) )
							{
								map.put( "success" , true );
								return map;
							}

						for ( Task task : listOfTask )
							{
								task.setAccountID( moveToAccount );
								task.setStatus( "deleted" );
//								task.setLastUpdatedDate( new Date() );
								listOfTaskIds.add(task.getID());
							}

						DataStoreUtil.batchWrite( listOfTask );

						success = true;
						
						addToMemcacheAndCheckSubscription(listOfTaskIds, null);
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , " JSON :" + json , e );
						EmailUtil.sendJavaErrorMailWithParams( "JSON :" + json , e );
					}

				map.put( "success" , success );
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> reassignBulkTasksFromReport( String accountID , String loggedInPersonID, String json )
			{

				boolean success = false;

				String assigneeID = null, department = null , departmentID = null;

				List <String> listTaskID = null, linkedSubscribers = null;
				List <Entity> listEntity = new ArrayList <Entity>();
				List <Key> listOfKeys = new ArrayList <Key>();
				List <Task> listTask=new ArrayList <Task>();
				List <Long> listDealID = new ArrayList<Long>();
				List <Deal> listDeal;

				Map <Key , Entity> mapOfTask = null;
				Map <String , Object> mapOfInput = null, responseMap = new HashMap <String , Object>();
				Map <String , Task> mapOfTempTask=new HashMap <String , Task>();

				Entity entity = null;
				ObjectMapper mapper = new ObjectMapper();
				Task task;
				Map<String, List<String>> mapOfOldAssigneeToTaskID = new HashMap<String, List<String>>(); 
				
				try
					{

						mapOfInput = mapper.readValue( json , new TypeReference <Map <String , Object>>(){} );

						assigneeID = (String) mapOfInput.get( "assigneeID" );
						department = Utilities.getStringValueFromMap( "department" , mapOfInput );
						departmentID = Utilities.getStringValueFromMap( "departmentID" , mapOfInput );
						listTaskID = (List <String>) mapOfInput.get( "task" );
						
						if ( Utilities.isEmpty( listTaskID ))
							{
								success = true;
								return responseMap;
							}

						for ( String taskID : listTaskID )
							{
								listOfKeys.add( KeyFactory.createKey( "Task" , taskID ) );
							}

						mapOfTask = DataStoreUtil.getEntitiesUsingKey( listOfKeys );

						for ( Map.Entry <Key , Entity> mapOfObj : mapOfTask.entrySet() )
							{

								entity = mapOfObj.getValue();
								Task taskObj = new Task(entity);
								
								if(!mapOfOldAssigneeToTaskID.containsKey(taskObj.getAssigneeID()))
									mapOfOldAssigneeToTaskID.put(taskObj.getAssigneeID(), new ArrayList<String>());
								
								mapOfOldAssigneeToTaskID.get(taskObj.getAssigneeID()).add(taskObj.getID());
								
								entity.setProperty( "assigneeID" , assigneeID );
								entity.setProperty( "department" , department );
								entity.setProperty( "departmentID" , departmentID );
								
								linkedSubscribers = (List<String>) entity.getProperty("linkedSubscribers");
								
								if(!Utilities.isEmpty( linkedSubscribers )) {
									if(linkedSubscribers.contains(assigneeID)) {
										linkedSubscribers.remove(assigneeID);
										entity.setProperty("linkedSubscribers", linkedSubscribers);
									}
								}
								
								listEntity.add( entity );
							}

						TaskDAO.persistEntities( listEntity );

						for ( Entity entity1 : listEntity )
							{
								
								task = new Task( entity1 );
								mapOfTempTask.put( task.getID() , task );
								
								if(task.getLinkedDeal() != null)
									listDealID.add(task.getLinkedDeal());
							}

						//setPopUpForTasksInMap( mapOfTempTask , accountID );

						for ( String taskID : mapOfTempTask.keySet() )
							listTask.add( mapOfTempTask.get( taskID ) );

						if ( !Utilities.isEmpty( listDealID ) )
							{
								
								listDeal = DealDAO.getDeal( accountID, listDealID );
								listDeal = (List<Deal>) DataStoreUtil.batchWrite( listDeal );
								Map<Long, Deal> mapOfDealInfo = new HashMap<Long, Deal>();

								for ( Deal dealObj : listDeal )
									{
										mapOfDealInfo.put( dealObj.getID() , dealObj );
									}
								
								responseMap.put( "deal" , mapOfDealInfo );
							}
						
						success = true;
						addToMemcacheAndCheckSubscription(listTaskID, mapOfOldAssigneeToTaskID);
						processWebhooks(listTaskID);
					}
				catch ( Exception e )
					{
						String params = "Params- loggedInPersonID: "+loggedInPersonID+" accountID: "+accountID+" json: "+json;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						responseMap.put( "success" , success );
						responseMap.put( "task" , listTaskID );
						responseMap.put( "tasks" , listTask );
						responseMap.put( "assigneeID" , assigneeID );
					}
				return responseMap;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> getOtherReqInfoForTask( Map <String , Object> mapOfSessionObj , String taskJson )
			{

				String taskID = null , ownerID = null , accountID = null , userID = null , parentAccountID = null , utcOffsetString, historyJson = null,
						lCMSGetURL = null , lReqParams = null , lRespJson = null , lNextCursor = null, departmentID, parentTaskID = null , parentComments = null;
				boolean success = false , fetchOwnerInfo = false, isHistoryInfoFetched = false;
				Future <HTTPResponse> futureObjForContact = null;
				List <String> linkedDocuments = null , linkedCustomFields = null;
				List <String> linkedTasks = null , linkedTags = null , linkedContacts = null , linkedContactsForTags = null;
				List <Task> listParentTasks = null;
				Set <String> setOfContactID = null;
				Map <String , Object> map = new HashMap <String , Object>() , inputMap = null , mapOfUserInfo = null , mapOfContactInfo = null , mapOfTimeZoneInfo = null , 
									mapOfContact = null, mapCms, mapOfDocumentInfo = null, mapOfCustomFieldInfo = null, mapOfTagsInfo = null;
				Map <String , String> mappedContactToPhoneNo = null;
				ObjectMapper mapper = new ObjectMapper();

				JsonNode lRootNode = null, historyNode, cursorNode, lSuccessNode;
				Object listHistoryObj = null;
				Task parentTask = null;

				try
					{

						accountID = (String) mapOfSessionObj.get( "AccountPIN" );
						userID = (String) mapOfSessionObj.get( "peopleId" );
						parentAccountID = (String) mapOfSessionObj.get( "parentAccountID" );

						inputMap = mapper.readValue( taskJson , new TypeReference <Map <String , Object>>(){} );

						linkedDocuments = (List <String>) inputMap.get( "linkedDocuments" );
						linkedCustomFields = (List <String>) inputMap.get( "linkedCustomFields" );
						linkedTasks = (List <String>) inputMap.get( "linkedTasks" );
						linkedTags = (List <String>) inputMap.get( "linkedTags" );
						linkedContacts = (List <String>) inputMap.get( "contacts" );
						linkedContactsForTags = (List <String>) inputMap.get( "linkedContactsForTags" );
						taskID = (String) inputMap.get( "id" );
						utcOffsetString = (String) inputMap.get( "utcOffsetString" );
						mappedContactToPhoneNo = (Map <String , String>) inputMap.get( "phoneNo" );

						departmentID = (String) inputMap.get( "departmentID" );
						departmentID = Utilities.correctToNull( departmentID );

						mapOfUserInfo = ContactService.getUsersWhoHaveAccess( accountID , parentAccountID , mapOfSessionObj , inputMap );

						if ( !Utilities.isEmpty( linkedContacts ) )
							{

								mapOfContactInfo = ContactService.getReqContacts( "task" , accountID , linkedContacts );

								if ( ( (Boolean) mapOfContactInfo.get( "success" ) ).booleanValue() )
									{

										mapOfContactInfo.remove( "success" );
										map.putAll( mapOfContactInfo );
										mapOfContact = (Map <String , Object>) mapOfContactInfo.get( "contact" );
									}
							}

						mapOfTimeZoneInfo = ContactService.getUTCOffsetAndTimeZoneIDForContacts( mappedContactToPhoneNo , mapOfContact );

						// fetch tags for contacts in account
						if ( !Utilities.isEmpty( linkedContactsForTags ) )
							{

								StringBuilder url = new StringBuilder();
								String tagJson = null;

								Map <String , Object> mapData = new HashMap <String , Object>();
								mapData.put( "listEntityID" , linkedContactsForTags );

								tagJson = mapper.writeValueAsString( mapData );

								url.append( StringConstants.GET_SELECTED_TAGS_V2_URL ).append( "?apikey=" ).append( accountID );
								String respJSON = (String) URLFetchService.URLFetch( url.toString() , "POST" , "application/json" , tagJson );

								JsonNode rootNode = mapper.readValue( respJSON , JsonNode.class );
								JsonNode successNode = rootNode.path( "status" );

								if ( successNode.isMissingNode() || !successNode.booleanValue() )
									throw new Exception( "Unable to fetch tags" );

								Map <String , Object> mapTags = null;
								mapTags = mapper.readValue( respJSON , new TypeReference <Map <String , Object>>(){} );
								mapTags.remove( "status" );

								if ( !Utilities.isEmpty( (List <Tag>) mapTags.get( "tags" ) )
										&& !Utilities.isEmpty( (List <TagInfo>) mapTags.get( "taginfo" ) ) )
									map.putAll( mapTags );
							}

						if ( !Utilities.isEmpty( linkedTasks ) )
							{

								List <Task> listLinkedTasks = TaskDAO.getTasksByTaskIDS( linkedTasks );

								if ( !Utilities.isEmpty( listLinkedTasks ) )
									{

										for ( Task task : listLinkedTasks )
											Utilities.setTimeZoneAndOffset( task );

										map.put( "linkedTasks" , listLinkedTasks );
									}
							}

						listParentTasks = TaskDAO.getTasksByLinkedTasks( Arrays.asList( taskID ) );

						if ( !Utilities.isEmpty( listParentTasks ) )
							{
								parentTask = listParentTasks.get( 0 );
								parentTaskID = parentTask.getID();
								parentComments = parentTask.getComments();
								map.put( "parentTaskID" , parentTaskID );
								map.put( "parentComments" , parentComments );
							}

						mapCms = new HashMap <>();
						mapCms.put( "accountID" , accountID );
						mapCms.put( "limit" , "20" );
						mapCms.put( "entityID" , taskID );
						mapCms.put( "entityType" , "linkedTask" );

						historyJson = mapper.writeValueAsString( mapCms );

						lCMSGetURL = StringConstants.GET_HISTORY_FOR_ENTITY_URL.concat( "/" ).concat( taskID );
						lReqParams = "?apikey=".concat( accountID );
						lCMSGetURL = lCMSGetURL.concat( lReqParams );

						lRespJson = (String) URLFetchService.URLFetch( lCMSGetURL , "POST" , "application/json" , historyJson );
						lRootNode = mapper.readValue( lRespJson , JsonNode.class );
						lSuccessNode = lRootNode.path( "success" );
						isHistoryInfoFetched = lSuccessNode.booleanValue();

						if ( !isHistoryInfoFetched )
							throw new IllegalArgumentException( "History Information not fetched For plain task" );

						historyNode = lRootNode.path( "history" );
						listHistoryObj = mapper.treeToValue( historyNode , Object.class );

						cursorNode = lRootNode.path( "cursor" );
						lNextCursor = cursorNode.textValue();

						map.put( "history" , listHistoryObj );
						map.put( "cursor" , lNextCursor );

						if(!Utilities.isEmpty(linkedDocuments)) {
							mapOfDocumentInfo = DocumentService.getDocumentsForDocumentIDs(linkedDocuments, accountID);
							if((Boolean) mapOfDocumentInfo.get("success")){
								mapOfDocumentInfo.remove("success");
								map.put("mapOfLinkedDocumentInfo", mapOfDocumentInfo);
							} else 
								throw new Exception("Unable to fetch linkedDocuments info");
						}
						
						if(!Utilities.isEmpty(linkedCustomFields)){
							mapOfCustomFieldInfo = CustomFieldService.getCustomFields(accountID, linkedCustomFields, utcOffsetString);
							if((Boolean) mapOfCustomFieldInfo.get("success")){
								mapOfCustomFieldInfo.remove("success");
								//map.putAll( mapOfCustomFieldInfo );
								map.put("mapOfCustomFieldInfo", mapOfCustomFieldInfo);
							} else 
								throw new Exception("Unable to fetch customFields");
						}

						if(!Utilities.isEmpty(linkedTags)){
							String tagJson = null;

							Map <String , Object> mapData = new HashMap <String , Object>();
							mapData.put( "tags" , linkedTags );

							tagJson = mapper.writeValueAsString( mapData );
							
							mapOfTagsInfo = TagService.getSelectedTags( accountID , tagJson );
							
							if((Boolean) mapOfTagsInfo.get("status")){
								mapOfTagsInfo.remove("status");
								map.put("tasktags", mapOfTagsInfo.get("tags"));
							} else 
								throw new Exception("Unable to fetch tags");
						}

//						if ( !Utilities.isNull( futureObjForContact ) )
//							{
//								mapOfUserInfo = ContactService.getUserInfoFromAsyncHTTPResponse( futureObjForContact );
//							}

						success = true;

					}
				catch ( Exception e )
					{

						String params = "Params- mapOfSessionObj: "+mapOfSessionObj+" accountID: "+accountID+" userID: "+userID+" taskJson: "+taskJson; 
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );

					}
				finally
					{
						map.put( "success" , success );
						map.put( "id" , taskID );
						map.put( "timeZoneInfo" , mapOfTimeZoneInfo );
						if ( !Utilities.isEmpty( mapOfUserInfo ) )
							map.put( "userInfo" , mapOfUserInfo );
					}
				return map;
			}

		public static Task updateTaskForDocument( String accountID , String entityID , List <String> documentID , String operation )
			{

				Task updatedTask = null , task = null;
				List <String> linkedDocuments = null;
				String logInfo = null;

				try
					{

						task = DataStoreUtil.getObjectByID( Task.class , entityID );

						linkedDocuments = task.getLinkedDocuments();

						if ( operation.equals( "add" ) )
							{

								linkedDocuments = Utilities.createNewIfNull( linkedDocuments );
								linkedDocuments.addAll( documentID );

							}
						else if ( operation.equals( "remove" ) )
							linkedDocuments.removeAll( documentID );

						task.setLinkedDocuments( linkedDocuments );

						updatedTask = DataStoreUtil.write( task );

					}
				catch ( Exception e )
					{

						StringBuilder logInfoBuilder = new StringBuilder();
						logInfoBuilder.append( "accountID : " ).append( accountID ).append( " \n entityID : " ).append( entityID );
						logInfoBuilder.append( "\n documentID : " ).append( documentID ).append("\n operation: ").append(operation);
						logInfo = logInfoBuilder.toString();
						mLogger.log( java.util.logging.Level.SEVERE , logInfo , e );
						EmailUtil.sendJavaErrorMailWithParams( logInfo , e );
					}
				return updatedTask;
			}

		public static Map <String , Object> addOrRemoveSubscriberForTask( Map <String , Object> mapOfSessionObj , String json )
			{

				boolean success = false , isSubscriberAddedOrRemoved = false;

				String taskID = null , subscriberID = null, staticContentUrl = null , 
						userID = null , accountID = null, operation, createdDateStr = null , dueDateStr = null;

				List <String> linkedSubscribers = null;

				Map <String , Object> mapOfInput = null, map = new HashMap <String , Object>();

				Task task = null , updatedTask = null;
				ObjectMapper mapper = new ObjectMapper();
				Date createdDate = null , dueDate = null;

				try
					{

						staticContentUrl = (String) mapOfSessionObj.get( "staticContentUrl" );
						userID = (String) mapOfSessionObj.get( "peopleId" );
						accountID = (String) mapOfSessionObj.get( "AccountPIN" );
						mapOfInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						taskID = (String) mapOfInput.get( "taskID" );
						subscriberID = (String) mapOfInput.get( "subscriberID" );
						operation = (String) mapOfInput.get( "operation" );

						task = DataStoreUtil.getObjectByID( Task.class , taskID );

						linkedSubscribers = task.getLinkedSubscribers();

						if( "add".equals( operation ))
							{
							
								linkedSubscribers = Utilities.createNewIfNull( linkedSubscribers );
								if( !linkedSubscribers.contains( subscriberID ) )
									isSubscriberAddedOrRemoved = linkedSubscribers.add( subscriberID );
							}
						else if( "remove".equals( operation ) && linkedSubscribers != null)
								isSubscriberAddedOrRemoved = linkedSubscribers.remove( subscriberID );

						updatedTask = DataStoreUtil.write( task );

						if ( !StringUtil.isBlank( subscriberID ) && isSubscriberAddedOrRemoved )
							{
								
								SimpleDateFormat sdfDateAndTime = new SimpleDateFormat( "MM/dd/yyyy hh:mm a" );

								createdDate = task.getCreatedDate();
								dueDate = task.getDueDate();
								createdDateStr = sdfDateAndTime.format( createdDate );
								mapOfInput.put( "createdDate" , createdDateStr );
								
								if ( dueDate != null )
									{
										dueDateStr = sdfDateAndTime.format( dueDate );
										mapOfInput.put( "dueDate" , dueDateStr );
									}

								mapOfInput.put( "appUrl" , staticContentUrl );
								mapOfInput.put( "isSubscribed" , ( operation.equals( "add" )? true : false ) );
								mapOfInput.put( "tasksubscribernotification" , true );
								mapOfInput.remove("operation");
								mapOfInput.remove("subscriberID");

								EmailService.sendMailNotificationForTaskUpdate( accountID , userID , mapOfInput , null );
							}

						Utilities.setTimeZoneAndOffset( updatedTask );
								
						success = true;
					}
				catch ( Exception e )
					{
						String params = "Params- json : " + json+" mapOfSessionObj: "+mapOfSessionObj;
						mLogger.log( java.util.logging.Level.WARNING , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "success" , success );
						map.put( "task" , updatedTask );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> restoreTask( Map <String , Object> mapOfSessionObj , String operation , String taskID , String json )
			{

				boolean status = false;

				String accountID = null;
				String userID = null , departmentIDOfTask = null;

				StringBuilder url = null;

				Map <String , Object> map = null , searchIndexMap = null , tasksMap = null;
				ObjectMapper mapper = null;
				Task task = null , updatedTask = null;

				try
					{

						map = new HashMap <String , Object>();
						task = DataStoreUtil.getObjectByID( Task.class , taskID );

						if ( task != null )
							{

								accountID = (String) mapOfSessionObj.get( "AccountPIN" );
								userID = (String) mapOfSessionObj.get( "peopleId" );

								task.setStatus( "pending" );
								updatedTask = DataStoreUtil.write( task );

								tasksMap = new HashMap <String , Object>();
								searchIndexMap = new HashMap <String , Object>();
								searchIndexMap.put( "taskID" , updatedTask.getID() );
								searchIndexMap.put( "linkedCustomFields" , updatedTask.getLinkedCustomFields() );
								searchIndexMap.put( "lastUpdatedDate" , updatedTask.getLastUpdatedDate() );
								searchIndexMap.put( "comments" , updatedTask.getComments() );

								departmentIDOfTask = updatedTask.getDepartmentID();

								if ( !StringUtil.isBlank( departmentIDOfTask ) )
									searchIndexMap.put( "departmentID" , departmentIDOfTask );

								if ( "deleted".equalsIgnoreCase( (String) updatedTask.getStatus() ) )
									searchIndexMap.put( "deleted" , true );
								else
									searchIndexMap.put( "deleted" , false );

								tasksMap.put( updatedTask.getID() , searchIndexMap );

								url = new StringBuilder();
								url.append( StringConstants.INSERT_TASK_SEARCH_INDEX_URL ).append( "?apikey=" ).append( accountID );

								mapper = new ObjectMapper();
								URLFetchService.URLFetch( url.toString() , "POST" , "application/json" , mapper.writeValueAsString( tasksMap ) );

								url = new StringBuilder();
								url.append( StringConstants.TASK_SEARCH_API_INDEX_URL ).append( "?apikey=" ).append( accountID );

								mapper = new ObjectMapper();
								URLFetchService.URLFetch( url.toString() , "POST" , "application/json" , mapper.writeValueAsString( tasksMap ) );

								Utilities.setTimeZoneAndOffset( updatedTask );

								// send emails
								Map <String , Object> mapOfInfo = null , mapOfTaskInfo = null;
								mapOfInfo = mapper.readValue( json , new TypeReference <Map <String , Object>>()
									{
									} );
								mapOfTaskInfo = (Map <String , Object>) mapOfInfo.get( "taskinfo" );
								EmailService.addTaskQueueToSendMailForTask( accountID , userID , mapOfTaskInfo );
							}
						status = true;
						
						addToMemcacheAndCheckSubscription(Arrays.asList(updatedTask.getID()), null);
					}
				catch ( Exception e )
					{
						String params = "Params- mapOfSessionObj: "+mapOfSessionObj+" json: "+json+" taskID: "+taskID+" operation: "+operation;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "success" , status );
						map.put( "operation" , operation );
						map.put( "task" , updatedTask );
					}
				return map;
			}

		public static Map <String , Object> associateSubTaskToTask( String parentTaskID , String subTaskID )
			{

				boolean status = false;
				List <String> linkedTasks = null;
				Map <String , Object> map = new HashMap <String , Object>();
				Task task , updatedTask = null;

				try
					{

						task = DataStoreUtil.getObjectByID( Task.class , parentTaskID );

						linkedTasks = Utilities.createNewIfNull( task.getLinkedTasks() );

						if ( !linkedTasks.contains( subTaskID ) )
							linkedTasks.add( subTaskID );

						updatedTask = DataStoreUtil.write( task );

						Utilities.setTimeZoneAndOffset( updatedTask );
						status = true;
					}
				catch ( Exception e )
					{
						String params = "Params- parentTaskID :  " + parentTaskID+ "\n subTaskID : " + subTaskID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "status" , status );
						map.put( "task" , updatedTask );
					}
				return map;
			}

		private static List <String> getTaskIdOfNextTaskToBeShown_v2( List <String> listOfScheduledTaskID , String taskIDOfCurrentTaskShown ,
																		String currentTaskIsRelatedTo , Long dealIDOfCurrentTask ,
																		String contactIDOfCurrentTask , String accountIDOfCurrentTask ) throws Exception
			{

				int indexOfMatchedTaskID = -1 , indexOfNextScheduledTaskID = 0 , noOfScheduledTaskID = 0;
				boolean isRelatedToSameType = false;
				String taskID = null , contactIDOfNextScheduledTask = null , nextScheduledTaskIsRelatedTo = null , accountIDOfNextScheduledTask = null;
				Long dealIDOfNextScheduledTask = null;
				Task task = null;
				List <String> listOfNextScheduledTaskID = new ArrayList <String>();

				if ( Utilities.isEmpty( listOfScheduledTaskID ) )
					return listOfNextScheduledTaskID;

				noOfScheduledTaskID = listOfScheduledTaskID.size();

				if ( !StringUtil.isBlank( taskIDOfCurrentTaskShown ) )
					indexOfMatchedTaskID = listOfScheduledTaskID.indexOf( taskIDOfCurrentTaskShown );

				if ( StringUtil.isBlank( taskIDOfCurrentTaskShown ) || indexOfMatchedTaskID == -1 )
					{

						for ( String taskIDFromItr : listOfScheduledTaskID )
							{

								listOfNextScheduledTaskID.add( taskIDFromItr );
								if ( listOfNextScheduledTaskID.size() == 2 )
									break;
							}
						return listOfNextScheduledTaskID;
					}

				indexOfNextScheduledTaskID = indexOfMatchedTaskID + 1;
				listOfNextScheduledTaskID.add( taskIDOfCurrentTaskShown );

				do
					{

						isRelatedToSameType = false;
						nextScheduledTaskIsRelatedTo = null;
						dealIDOfNextScheduledTask = null;
						contactIDOfNextScheduledTask = null;

						if ( noOfScheduledTaskID == 1 )
							break;
						else if ( indexOfNextScheduledTaskID == noOfScheduledTaskID )
							{
								indexOfNextScheduledTaskID = 0;
							}

						taskID = listOfScheduledTaskID.get( indexOfNextScheduledTaskID );

						task = DataStoreUtil.getObjectByID( Task.class , taskID );

						if ( !StringUtil.isBlank( task.getLinkedAccount() ) )
							{
								nextScheduledTaskIsRelatedTo = "Account";
								accountIDOfNextScheduledTask = task.getLinkedAccount();
							}
						else if ( task.getLinkedDeal() != null )
							{
								nextScheduledTaskIsRelatedTo = "Deal";
								dealIDOfNextScheduledTask = task.getLinkedDeal();
							}
						else if ( !Utilities.isEmpty(task.getLinkedContacts()) )
							{
								nextScheduledTaskIsRelatedTo = "Contact";
								contactIDOfNextScheduledTask = task.getLinkedContacts().get( 0 );
							}

						if ( currentTaskIsRelatedTo.equalsIgnoreCase( nextScheduledTaskIsRelatedTo )
								&& ( ( "Deal".equalsIgnoreCase( nextScheduledTaskIsRelatedTo ) && dealIDOfCurrentTask
										.equals( dealIDOfNextScheduledTask ) )
										|| ( ( "Contact".equalsIgnoreCase( nextScheduledTaskIsRelatedTo ) ) && contactIDOfCurrentTask
												.equalsIgnoreCase( contactIDOfNextScheduledTask ) ) || ( ( "Account"
										.equalsIgnoreCase( nextScheduledTaskIsRelatedTo ) ) && accountIDOfCurrentTask
										.equalsIgnoreCase( accountIDOfNextScheduledTask ) ) ) )
							{

								isRelatedToSameType = true;
								indexOfNextScheduledTaskID += 1;

							}
						else
							{
								listOfNextScheduledTaskID.add( taskID );
							}

					}
				while ( isRelatedToSameType );

				return listOfNextScheduledTaskID;
			}

		public static Map <String , Object> getTodaysNextTaskOfUser_v2( String accountID , String userID , String taskIDOfCurrentTaskShown ,
																		String currentTaskIsRelatedTo , Long dealIDOfCurrentTask ,
																		String contactIDOfCurrenTask , String accountIDOfCurrentTask ,
																		String departmentID )
			{

				String error = null;
				StringBuilder errorInfo = new StringBuilder();
				boolean success = false;
				List <String> listOfTaskIDForUser = null , listOfNextScheduledTaskID = null;
				Map <String , Map <String , Object>> mapOfTaskRelatedToInfo = null;
				Map <String , Object> map = new HashMap <String , Object>();

				try
					{

						departmentID = Utilities.correctToNull( departmentID );

						errorInfo.append( " accountID : " ).append( accountID ).append( "<br/><br/>" );
						errorInfo.append( " userID : " ).append( userID ).append( "<br/><br/>" );
						errorInfo.append( " taskIDOfCurrentTaskShown : " ).append( taskIDOfCurrentTaskShown ).append( "<br/><br/>" );
						errorInfo.append( " currentTaskIsRelatedTo : " ).append( currentTaskIsRelatedTo ).append( "<br/><br/>" );
						errorInfo.append( " dealIDOfCurrentTask : " ).append( dealIDOfCurrentTask ).append( "<br/><br/>" );
						errorInfo.append( " contactIDOfCurrenTask : " ).append( contactIDOfCurrenTask ).append( "<br/><br/>" );
						errorInfo.append( " accountIDOfCurrentTask : " ).append( accountIDOfCurrentTask ).append( "<br/><br/>" );
						errorInfo.append( " departmentID : " ).append( departmentID ).append( "<br/><br/>" );

						mLogger.log( java.util.logging.Level.INFO , "Request parameters :" + errorInfo.toString() );

						listOfTaskIDForUser = TaskDAO.getListOfTodaysScheduledTaskIdOfUser( accountID , userID , departmentID );

						if ( Utilities.isEmpty( listOfTaskIDForUser ) )
							{
								success = true;
								return map;
							}

						listOfNextScheduledTaskID = getTaskIdOfNextTaskToBeShown_v2( listOfTaskIDForUser , taskIDOfCurrentTaskShown ,
								currentTaskIsRelatedTo , dealIDOfCurrentTask , contactIDOfCurrenTask , accountIDOfCurrentTask );

						if ( !Utilities.isEmpty( listOfNextScheduledTaskID ) )
							{
								mapOfTaskRelatedToInfo = getRelatedToInfoForListOfTask( accountID , listOfNextScheduledTaskID );
							}

						success = true;

					}
				catch ( Exception e )
					{
						errorInfo.append( " listOfTaskIDForUser :" ).append( listOfTaskIDForUser ).append( "<br/><br/>" );
						errorInfo.append( " listOfNextScheduledTaskID :" ).append( listOfNextScheduledTaskID ).append( "<br/><br/>" );
						errorInfo.append( " departmentID :" ).append( departmentID ).append( "<br/><br/>" );
						error = errorInfo.toString();
						mLogger.log( java.util.logging.Level.SEVERE , error , e );
						EmailUtil.sendJavaErrorMailWithParams( error , e );
					}
				finally
					{
						map.put( "success" , success );
						if ( success )
							{
								map.put( "listOfTaskID" , listOfNextScheduledTaskID );
								map.put( "taskInfo" , mapOfTaskRelatedToInfo );
							}
					}
				return map;
			}

		public static Map <String , Object> createPlainTaskEntities( String json )
			{

				boolean status = false;
				Entity entity = null;
				List <Entity> listEntity = new ArrayList <Entity>();
				List <String> listContactID = null;
				Map <String , Object> map = new HashMap <String , Object>();
				ObjectMapper mapper = new ObjectMapper();

				try
					{

						listContactID = mapper.readValue( json , new TypeReference <List <String>>()
							{
							} );
						
						if( Utilities.isEmpty( listContactID ))
							return map;

						for ( String contactID : listContactID )
							{
								entity = new Entity( "PlainTask" , contactID );
								entity.setProperty( "enabled" , true );
								entity.setProperty( "workshop" , false );
								listEntity.add( entity );
							}
						
						DataStoreUtil.put( listEntity );
						
						status = true;
					}
				catch ( Exception e )
					{
						String params = "Exception in createPlainTaskEntities, json : " + json;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "status" , status );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> createTaskForIBCall( HttpServletRequest request , String json )
			{

				boolean success = false, isNewContactCreated=false, isServiceDeptMessage = false;

				String accountsID = null , comments = null , brandID = null, taskID = null , name = null , phone = null , 
						email = null , contactID = null, taskComments = "Call", accountNumber=null;

				Map <String , Object> map = new HashMap <String , Object>() , mapTask = null,
									mapOfSessionObj = new HashMap <String , Object>(), historyMap, searchMap;
				List<String> internalNumbers = Arrays.asList("8773229610","8663033097","8667221031","1004618520","8005315828","8774003096","8772280862","8663043334","8773835435",
												"8662105976","8005251315","8005251315","8663109928","8662707022","8663109928","8773831722","8663105789","1004618520","8773292748","8773293730",
												"8773293946","8662327606","8773229911","8773298861","8887967938","8669575402","8882875070","8662454364","8665505762","5032084811","2066868420",
												"5034473935","5034473924","5414184816","5415267920","5417052542","5414024262","8773294369","5034473939","8004618520","8668188090","8005504797");

				Task task = null;

				ObjectMapper mapper = new ObjectMapper();
				
				try
					{
						
						mLogger.log( java.util.logging.Level.INFO, "createTaskForIBCall json: "+json);

						mapTask = mapper.readValue( json , new TypeReference <Map <String , Object>>(){} );

						//comments = (String) mapInput.get( "comments" );
						//notes = (String) mapTask.get( "notes" );
						brandID = (String) mapTask.get( "brandID" );
						
						historyMap = (Map<String, Object>) mapTask.get("historyProperties");
						searchMap = (Map<String, Object>) mapTask.get("searchRelationships");
						
						if(mapTask.containsKey("isServiceDeptMessage"))
							isServiceDeptMessage = Boolean.valueOf((String.valueOf( mapTask.get( "isServiceDeptMessage" ))));
						
						name = (String) historyMap.get("name");
						
						if(!Utilities.isEmpty( searchMap )){
							phone = (String) searchMap.get("phone");
							email = (String) searchMap.get("email");
							accountNumber = (String) searchMap.get("accountNumber");
						}

						/*if ( StringUtil.isBlank( accountNumber ) || StringUtil.isBlank( notes ) )
							{
								map.put( "error" , "Mandatory fields are missing" );
								return map;
							}*/
						
						if(!StringUtil.isBlank( accountNumber )){
						
						accountNumber = accountNumber.replaceAll( "-" , "" );
						accountNumber = accountNumber.replaceAll( "\\)" , "" );
						accountNumber = accountNumber.replaceAll( "\\(" , "" );
						accountNumber = accountNumber.replaceAll( " " , "" );
								
						if(internalNumbers.indexOf( accountNumber ) != -1){
							searchMap.remove( "accountNumber" );
							mapTask.put( "searchRelationships" , searchMap );
							//commented because people might need to know the original input, even if its incorrect
							/*historyMap.remove("accountNumber");
							mapTask.put( "historyProperties" , historyMap );*/
						}
						}
						
						if ( !StringUtil.isBlank( name ) )
							taskComments += " " + name;

						if ( !StringUtil.isBlank( phone ) )
							taskComments += " (" + phone + ")";
						
						mapTask.put( "comments" , taskComments );

						searchAndLinkEntitiesToTask( mapTask , answerConnectAccountID, true );

						if(mapTask.containsKey("linkedAccounts")){
							
							List<String> linkedAccounts = (List<String>) mapTask.get("linkedAccounts");
							accountsID = linkedAccounts.get( 0 );
							mapTask.remove( "accounts" );
							
							if(!StringUtil.isBlank( (String)mapTask.get("brandID") ))
								brandID = (String) mapTask.get("brandID");
						}
						
						if(mapTask.containsKey("linkedContacts")){

							List<String> linkedContacts  = (List<String>) mapTask.get("linkedContacts");
							contactID = linkedContacts.get(0);
							
							if(accountsID == null){
								
								List<Contact> contacts = (List<Contact>) mapTask.get("contacts");
								Contact chosenContact=null;
								
								for(Contact contact : contacts){
									if(!Utilities.isEmpty( contact.getLinkedAccounts() )){
										chosenContact = contact;
										contactID = contact.getID();
										break;
									}
								}
								
								if( chosenContact != null ){
									accountsID = chosenContact.getLinkedAccounts().get(0);
									mapTask.put("linkedAccounts", Arrays.asList(accountsID));
								}
							}
							
							mapTask.remove( "linkedContacts" );
							mapTask.remove( "contacts" );
						}

						if ( StringUtil.isBlank( contactID ) && !StringUtil.isBlank( name ) 
								&& (!isServiceDeptMessage || (isServiceDeptMessage && StringUtil.isBlank( accountsID )) ) )
							{

								String firstName = "" , lastName = "" , contactJSON = "";
								Map <String , Object> contactMap = new HashMap <String , Object>() , contactInfoMap = new HashMap <String , Object>() , 
													contactMethodMap = null , contactResponse = null , contactMapFromCMS = null , historyInfoMap = new HashMap <String , Object>();
								List <Map <String , Object>> contactMethodList = new ArrayList <Map <String , Object>>();

								firstName = Utilities.getFirstOrLastNameFromFullName( name , true );
								lastName = Utilities.getFirstOrLastNameFromFullName( name , false );

								contactInfoMap.put( "firstName" , firstName );
								contactInfoMap.put( "lastName" , lastName );
								contactInfoMap.put( "source" , "IB Service Call" );
								contactInfoMap.put( "brandID" , brandID );
								contactInfoMap.put( "departmentID" , businessServiceDepartmentID );

								if ( !StringUtil.isBlank( email ) )
									{

										contactMethodMap = new HashMap <String , Object>();
										contactMethodMap.put( "title" , "Email" );
										contactMethodMap.put( "value" , email );
										contactMethodMap.put( "type" , "Email" );

										contactMethodList.add( contactMethodMap );
									}

								if ( !StringUtil.isBlank( phone ) )
									{

										contactMethodMap = new HashMap <String , Object>();
										contactMethodMap.put( "title" , "Phone" );
										contactMethodMap.put( "value" , phone );
										contactMethodMap.put( "type" , "Phone" );

										contactMethodList.add( contactMethodMap );
									}

								if ( !contactMethodList.isEmpty() )
									contactInfoMap.put( "linkedContactMethods" , contactMethodList );

								historyInfoMap.put( "historyComments" , comments );

								contactInfoMap.put( "history" , historyInfoMap );

								contactMap.put( "contactInfo" , contactInfoMap );

								contactJSON = mapper.writeValueAsString( contactMap );

								mapOfSessionObj.put( "AccountPIN" , answerConnectAccountID );

								contactResponse = ContactService.insertContact_v1( mapOfSessionObj , contactJSON );

								contactMapFromCMS = (Map <String , Object>) contactResponse.get( "contact" );

								for ( String key : contactMapFromCMS.keySet() )
									contactID = key;
								
								isNewContactCreated = true;
							}

						if ( isNewContactCreated && !StringUtil.isBlank( contactID ) && !StringUtil.isBlank( accountsID ) )
							{

								Map <String , Object> accountInfoMap = new HashMap <String , Object>();
								mapOfSessionObj.put( "AccountPIN" , answerConnectAccountID );

								accountInfoMap.put( "contactIdsToAdd" , Arrays.asList( contactID ) );
								accountInfoMap.put( "property" , "contactIdsToAdd" );

								String accountJSON = mapper.writeValueAsString( accountInfoMap );

								AccountsService.updateAccount( mapOfSessionObj , accountsID , accountJSON );
							}

						if( !StringUtil.isBlank( contactID ) )
							mapTask.put( "linkedContacts" , Arrays.asList( contactID ) );
						
						mapTask.remove( "searchRelationships" );
						mapTask = createTask( answerConnectAccountID , mapper.writeValueAsString( mapTask ) , request );

						task = (Task) mapTask.get( "task" );

						taskID = task.getID();

						/*if ( !StringUtil.isBlank( contactID ) )
							{

								Map <String , Object> mapOfTaskInfoForUpdate = new HashMap <String , Object>();
								String taskInfoForUpdateAsJson = "";

								List <String> linkedContacts = new ArrayList <>();
								linkedContacts.add( contactID );

								mapOfTaskInfoForUpdate.put( "linkedContacts" , linkedContacts );

								taskInfoForUpdateAsJson = mapper.writeValueAsString( mapOfTaskInfoForUpdate );

								updateTask( null , answerConnectAccountID , taskID , taskInfoForUpdateAsJson , null );
								associateTaskToContact( answerConnectAccountID , contactID , taskID );
							}*/

						success = true;
					}
				catch ( Exception e )
					{
						String params = "Params , json : " + json + "\n taskID : "+ taskID+" mapTask: "+mapTask;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "success" , success );
						map.put( "task" , task );
					}
				return map;
			}

		public static Map <String , Object> addExistingContactToTask( String accountID , String json )
			{

				boolean success = false;

				String taskID = null , contactID = null , respJson = null;

				List <String> linkedContacts = null;

				Map <String , Object> map = new HashMap <String , Object>() , mapInput = null , mapForOneContact = null;
				Map <String , Object> responseContactMap = null;

				Contact contact = null;
				Task task = null;
				ObjectMapper mapper = new ObjectMapper();
				mapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES , false );
				JsonNode rootNode = null , successNode = null , contactNode = null;

				try
					{

						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						taskID = (String) mapInput.get( "taskID" );
						contactID = (String) mapInput.get( "contactID" );

						associateTaskToContact( accountID , contactID , taskID );

						respJson = (String) URLFetchService.associateTaskToContact( accountID , contactID , taskID );
						rootNode = mapper.readValue( respJson , JsonNode.class );

						if ( rootNode != null )
							{

								successNode = rootNode.path( "status" );

								if ( successNode.isMissingNode() || !successNode.booleanValue() )
									throw new Exception( "Exception when trying to associate task to contact" );

								contactNode = rootNode.path( "contact" );
								contact = mapper.convertValue( contactNode , new TypeReference <Contact>() {} );
								
//								mapForOneContact = ContactService.constructReqFieldsForContact( contact );
//
//								responseContactMap = new HashMap <String , Object>();
//								responseContactMap.put( contact.getID() , contact );
//								Map <String , Object> mapOfTimeZoneInfo = ContactService.getUTCOffsetAndTimeZoneIDForContacts( null ,
//										responseContactMap );
//								map.put( "timeZoneInfoForContact" , mapOfTimeZoneInfo );
							}

						task = DataStoreUtil.getObjectByID( Task.class , taskID );

						if ( task != null )
							{
								linkedContacts = task.getLinkedContacts();

								if ( Utilities.isEmpty( linkedContacts ) )
									linkedContacts = new ArrayList <String>();

								if ( !linkedContacts.contains( contactID ) )
									linkedContacts.add( contactID );

								task.setLinkedContacts( linkedContacts );
								task = DataStoreUtil.write( task );
								success = true;
							}
					}
				catch ( Exception e )
					{
						String data = "Exception in addExistingContactToTask, json : " + json+" accountID: "+accountID;
						mLogger.log( java.util.logging.Level.SEVERE , data , e );
						EmailUtil.sendJavaErrorMailWithParams( data , e );
					}
				finally
					{
						map.put( "task" , task );
						map.put( "contact" , contact );
						map.put( "success" , success );
					}
				return map;
			}

		public static Map <String , Object> addExistingAccountToTask( String accountID , String json )
			{

				boolean success = false;

				String taskID = null , accountsID = null , respJson = null;

				Map <String , Object> map = new HashMap <String , Object>() , mapInput = null;

				Account account = null;
				Task task = null;
				ObjectMapper mapper = new ObjectMapper();
				
				JsonNode rootNode = null , successNode = null , contactNode = null;

				try
					{
						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						taskID = (String) mapInput.get( "taskID" );
						accountsID = (String) mapInput.get( "accountsID" );

						respJson = (String) URLFetchService.associateTaskToAccounts( accountID , accountsID , taskID );
						rootNode = mapper.readValue( respJson , JsonNode.class );

						successNode = rootNode.path( "status" );

						if ( successNode.isMissingNode() || !successNode.booleanValue() )
							throw new Exception( "Exception when trying to associate task to account" );

						contactNode = rootNode.path( "account" );
						
						mapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES , false );
						account = mapper.convertValue( contactNode , new TypeReference <Account>()
							{
							} );

						task = DataStoreUtil.getObjectByID( Task.class , taskID );

						task.setLinkedAccount( accountsID );
						task.setProductID( account.getBrandID() );
						task = DataStoreUtil.write( task );
						success = true;
					}
				catch ( Exception e )
					{
						String data = "Exception in addExistingAccountToTask, json : " + json+" accountID: "+accountID+" respJson: "+respJson;
						mLogger.log( java.util.logging.Level.SEVERE , data , e );
						EmailUtil.sendJavaErrorMailWithParams( data , e );
					}
				finally
					{
						map.put( "task" , task );
						map.put( "account" , account );
						map.put( "success" , success );
					}
				return map;
			}

		/*public static Map <String , Object> createTaskForClientFeeBack( HttpServletRequest request , String staticContentUrl , String json )
			{

				boolean status = false;
				Boolean isAccountExist = false;

				Long dealID = null;

				String accountsID = null , comments = null , historyJson = null , taskJson = null , accountNumber = null, 
						taskID = null , historyComments = null , agentLogin = null , department = null , respJSON = null , feedBackType = null, 
						brandID = null , contactID = null , contactBrandID = null;

				List <String> linkedAccounts = null, linkedContacts = new ArrayList <String>();
				List <Map <String , Object>> listHistoryMap = new ArrayList <Map <String , Object>>();
				List <Long> listDealID = null;

				Map <String , Object> map = new HashMap <String , Object>() , mapInput = null , mapTask = null , mapOfRespInfo = null, mapHistory = null;

				Task task = null;

				StringBuilder historyBuilder = null , url = null;
				ObjectMapper mapper = new ObjectMapper();
				JsonNode rootNode = null;
				Account account = null;
				Contact contact = null;
				Deal deal = null;

				try
					{

						mLogger.log( java.util.logging.Level.WARNING , "createTaskForClientFeeBack , json : " + json );

						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						accountsID = (String) mapInput.get( "accountsID" );
						comments = (String) mapInput.get( "comments" );
						accountNumber = (String) mapInput.get( "accountNumber" );
						agentLogin = (String) mapInput.get( "login" );
						feedBackType = (String) mapInput.get( "feedBackType" );

						accountsID = Utilities.correctToNull( accountsID );
						feedBackType = Utilities.correctToNull( feedBackType );

						if ( StringUtil.isBlank( accountsID ) )
							throw new NullPointerException( "accountsID is empty, json : " + json );

						if ( StringUtil.isBlank( feedBackType ) )
							throw new NullPointerException( "feedBackType is empty, json : " + json );

						linkedAccounts = new ArrayList <String>();
						mapTask = new HashMap <String , Object>();

						try
							{

								url = new StringBuilder();
								url.append( StringConstants.ACCOUNTS_API_URL ).append( "/" ).append( accountsID )
										.append( StringConstants.GET_ACCOUNT_URL_PATH ).append( "?apikey=" ).append( answerConnectAccountID );

								mapOfRespInfo = URLFetchService.URLFetch_v2( url.toString() , "GET" , "application/json" , "" );
								respJSON = (String) mapOfRespInfo.get( "response" );
								rootNode = mapper.readValue( respJSON , JsonNode.class );

								JsonNode accountNode = rootNode.path( "account" );
								account = mapper.readValue( accountNode , Account.class );

								if ( account != null )
									{
										linkedAccounts.add( account.getID() );
										brandID = account.getBrandID();
										mapTask.put( "linkedAccounts" , linkedAccounts );
									}

								if ( !StringUtil.isBlank( agentLogin ) )
									{
										contact = SearchService.getSearchedContact( answerConnectAccountID , businessServiceDepartmentID , agentLogin );

										if ( contact != null )
											{
												contactID = contact.getID();
												contactBrandID = contact.getBrandID();
												listDealID = contact.getLinkedDeals();
											}
									}

								if ( !StringUtil.isBlank( contactID ) )
									{
										linkedContacts.add( contactID );
										mapTask.put( "linkedContacts" , linkedContacts );
									}

								//no need to do this because theyre no longer doing trial signups for lex
								if ( account == null && contact != null && !Utilities.isEmpty( listDealID ) )
									{

										dealID = listDealID.get( 0 );
										deal = DataStoreUtil.getObjectByID( Deal.class , dealID );

										if ( deal != null )
											{

												if ( lexreceptionProductID.equalsIgnoreCase( deal.getProductID() ) )
													{
														mapTask.put( "brandID" , deal.getProductID() );
													}
											}
									}
							}
						catch ( Exception e )
							{
								String data = null;
								data = "Exception while trying to fetch account and contact for the task in client feedback flow, accountsID : "
										+ accountsID + "\n contactID : " + contactID;
								mLogger.log( java.util.logging.Level.SEVERE , data , e );
								EmailUtil.sendJavaErrorMailWithParams( data , e );
							}

						try
							{
								UUID typeID = UUID.fromString( feedBackType );
								feedBackType = TaskTypeService.getTaskTypeByTypeID( typeID.toString() );
								mapTask.put( "type" , typeID );

							}
						catch ( IllegalArgumentException ex )
							{
								mapTask.put( "type" , feedBackType );
							}
						mapTask.put( "department" , serviceTaskDepartment );
						mapTask.put( "comments" , feedBackType + ":" + accountNumber );
						mapTask.put( "notes" , comments );
						mapTask.put( "departmentID" , businessServiceDepartmentID );

						if ( !StringUtil.isBlank( brandID ) )
							mapTask.put( "brandID" , brandID );
						else if ( !StringUtil.isBlank( contactBrandID ) )
							mapTask.put( "brandID" , contactBrandID );

						taskJson = mapper.writeValueAsString( mapTask );

						mapTask = createTask( answerConnectAccountID , taskJson , request );

						task = (Task) mapTask.get( "task" );

						if ( task == null )
							throw new NullPointerException( "Feedback Task Not Saved in createTaskForClientFeeBack, json : " + json );

						taskID = task.getID();
						department = task.getDepartment();

						historyBuilder = new StringBuilder();
						historyComments = historyBuilder.append( task.getNotes() ).toString();

						mapHistory = new HashMap <String , Object>();
						mapHistory.put( "accountID" , answerConnectAccountID );
						mapHistory.put( "ownerName" , agentLogin );
						mapHistory.put( "taskID" , taskID );
						mapHistory.put( "type" , "inboundemail" );
						mapHistory.put( "historyComments" , historyComments );
						mapHistory.put( "departmentID" , businessServiceDepartmentID );

						listHistoryMap.add( mapHistory );

						historyBuilder = new StringBuilder();
						historyBuilder.append( "Task Info : " ).append( "<br/><br/>" ).append( "<b style=color:#0084b0;>Summary : </b>" )
								.append( task.getComments() ).append( "<br/>" ).append( "<b style=color:#0084b0;>Description : </b>" )
								.append( task.getNotes() ).append( "<br/>" ).append( "<b style=color:#0084b0;>Type : </b>" ).append( task.getType() )
								.append( "<br/>" ).append( "<b style=color:#0084b0;>URL : </b>" ).append( "<a href=" ).append( staticContentUrl )
								.append( "/crm#task/" ).append( taskID ).append( " target=_blank>" ).append( staticContentUrl ).append( "/crm#task/" )
								.append( taskID ).append( "</a>" ).append( "<br/>" );

						if ( isAccountExist )
							{
								historyBuilder.append( "<b style=color:#0084b0;>Associated Account : </b>" ).append( "<a href=" )
										.append( staticContentUrl ).append( "/crm#account/" ).append( accountsID ).append( " target=_blank>" )
										.append( staticContentUrl ).append( "/crm#account/" ).append( accountsID ).append( "</a>" ).append( "<br/>" );
							}
						historyBuilder.append( "<b style=color:#0084b0;>Account Number : </b>" ).append( accountNumber ).append( "<br/>" )
								.append( "<b style=color:#0084b0;>Task ID : </b>" ).append( taskID ).append( "<br/>" )
								.append( "<b style=color:#0084b0;> Agent Login : </b>" ).append( agentLogin ).append( "<br/>" )
								.append( "<b style=color:#0084b0;> Task Type : </b>" ).append( feedBackType );

						historyComments = historyBuilder.toString();

						mapHistory = new HashMap <String , Object>();
						mapHistory.put( "accountID" , answerConnectAccountID );
						mapHistory.put( "ownerName" , "Log" );
						mapHistory.put( "taskID" , taskID );
						mapHistory.put( "historyComments" , historyComments );
						mapHistory.put( "type" , "log" );
						mapHistory.put( "departmentID" , businessServiceDepartmentID );

						listHistoryMap.add( mapHistory );

						Map <String , Object> mapHistoryData = new HashMap <String , Object>();

						mapHistoryData.put( "accountID" , answerConnectAccountID );
						mapHistoryData.put( "history" , listHistoryMap );

						historyJson = mapper.writeValueAsString( mapHistoryData );

						Queue queue = QueueFactory.getQueue( "Activity-Log" );
						queue.add( TaskOptions.Builder.withUrl( "/insertBulkHistoryJob" ).method( Method.POST ).payload( historyJson ) );

						if ( !StringUtil.isBlank( taskID ) )
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "pending" , taskID , null , answerConnectAccountID , department , null ,
									businessServiceDepartmentID );

						status = (boolean) mapTask.get( "success" );
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "Exception in createTaskForClientFeeBack method , json : " + json
								+ "\n taskID : " + taskID , e );
						EmailUtil.sendJavaErrorMailWithParams( "Exception in createTaskForClientFeeBack method , json : " + json , e );
					}
				finally
					{
						map.put( "status" , status );
					}
				return map;
			}*/

		public static Map <String , Object> getPlainTaskRelatedInfo_v1( StringBuilder errorInfo , String contactID )
			{

				boolean success = false;
				Map <String , Object> map = new HashMap <String , Object>() , mapOfReqVariables = new HashMap <String , Object>();

				try
					{

						boolean isPlainTask = false;

						try
							{

								Entity entity = TaskDAO.checkIfPlainTask( contactID );
								isPlainTask = (Boolean) entity.getProperty( "enabled" );

							}
						catch ( EntityNotFoundException objNotFound )
							{
								mLogger.log( java.util.logging.Level.INFO , " PlainTask Entity Not Found For : " + contactID );
							}

						if ( "dev".equalsIgnoreCase( mode ) )
							isPlainTask = true;

						mapOfReqVariables.put( "isPlainTask" , isPlainTask );

						success = true;
					}
				catch ( Exception e )
					{
						mLogger.log( Level.SEVERE , " getPlainTaskRelatedInfo_v1 : " + errorInfo , e );
						EmailUtil.sendExceptionMail( errorInfo , e );
					}
				finally
					{
						map.put( "success" , success );
						if ( !Utilities.isEmpty( mapOfReqVariables ) )
							map.put( "request_attributes" , mapOfReqVariables );
					}
				return map;
			}

		public static Map <String , Object> updateResolveTaskInteraction( String json , HttpServletRequest request )
			{

				Integer statusCode = null;

				String taskID = null , userlogin = null , arStatus = null , connectionID = null;
				String arGetURL = null , responseStr = null;

				Map <String , Object> mapOfInput = null , map = new HashMap <>();
				Map <String , Object> mapCmsInfo = null;

				ObjectMapper mapper = new ObjectMapper();
				StringBuilder strBuilder = new StringBuilder();

				try
					{

						mapOfInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						taskID = (String) mapOfInput.get( "taskID" );
						userlogin = (String) mapOfInput.get( "userlogin" );
						arStatus = (String) mapOfInput.get( "arstatus" );
						connectionID = (String) mapOfInput.get( "connectionID" );
						connectionID = Utilities.correctToNull( connectionID );

						if ( !StringUtil.isBlank( connectionID ) )
							strBuilder.append( CS_Domain ).append( new Date().getTime() ).append( "?connectionId=" ).append( connectionID )
									.append( "&status=" ).append( arStatus ).append( "&agentLogin=" ).append( userlogin );

						arGetURL = strBuilder.toString();
						mapCmsInfo = URLFetchService.URLFetch_v2( arGetURL , "GET" , "application/json" , "" );
						responseStr = (String) mapCmsInfo.get( "response" );
						statusCode = (Integer) mapCmsInfo.get( "statusCode" );
						mLogger.log( java.util.logging.Level.INFO , " updateResolveTaskInteraction , updateInteractionStatus :" + responseStr
								+ "\n taskID : " + taskID + "\n statusCode : " + statusCode );
					}
				catch ( Exception e )
					{
						String params = "Exception in Task Queue updateResolveTaskInteraction, JSON :  " + json;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "statusCode" , statusCode );
					}
				return map;
			}

		public static Map <String , Object> moveTaskToExistingAccount( String accountId , String json )
			{

				boolean status = false;

				String taskID = null , accountsID = null , cmsResponse = null , cmsJson = null , brandID = null;
				String taskAccountsID = null;

				Long taskDealID = null;

				List <String> listAccountID = null , linkedContacts = null , listDissociateAccount = null;
				List <Long> linkedDeals = null;

				Map <String , Object> mapOfJsData = null , mapContact = null;
				Map <String , Object> map = new HashMap <String , Object>() , mapData = null;

				Task task = null;
				Account account = null;
				ObjectMapper mapper = new ObjectMapper();
				mapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES , false );
				JsonNode rootNode = null , successNode = null , accountNode = null , contactNode = null;

				try
					{

						mapOfJsData = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						taskID = (String) mapOfJsData.get( "taskID" );
						accountsID = (String) mapOfJsData.get( "accountsID" );

						task = DataStoreUtil.getObjectByID( Task.class , taskID );

						taskAccountsID = task.getLinkedAccount();

						if ( !StringUtil.isBlank( taskAccountsID ) )
							{
								listDissociateAccount = new ArrayList <>();
								listDissociateAccount.add( taskAccountsID );
							}

						linkedContacts = task.getLinkedContacts();
						taskDealID = task.getLinkedDeal();

						if ( taskDealID != null )
							{
								linkedDeals = new ArrayList <>();
								linkedDeals.add( taskDealID );
							}

						listAccountID = new ArrayList <>();
						listAccountID.add( accountsID );

						mapData = new HashMap <String , Object>();
						mapData.put( "taskID" , task.getID() );
						mapData.put( "associate" , listAccountID );
						mapData.put( "dissociate" , listDissociateAccount );
						mapData.put( "linkedContacts" , linkedContacts );

						cmsJson = mapper.writeValueAsString( mapData );
						cmsResponse = (String) URLFetchService.moveTaskToExistingAccount( accountId , cmsJson );

						rootNode = mapper.readValue( cmsResponse , JsonNode.class );

						successNode = rootNode.path( "status" );

						if ( successNode.isMissingNode() || !successNode.booleanValue() )
							throw new Exception( "Exception when trying to move task, json : " + json );

						accountNode = rootNode.path( "account" );
						account = mapper.convertValue( accountNode , new TypeReference <Account>()
							{
							} );

						brandID = account.getBrandID();

						contactNode = rootNode.path( "contact" );

						if ( contactNode != null )
							{
								mapContact = ContactService.getCustomFieldsMapForContacts( contactNode );
								map.put( "contact" , mapContact );
							}

						task.setLinkedAccount( accountsID );
						task.setLinkedContacts( null );
						task.setLinkedDeal( null );
						task.setProductID( brandID );
						task = DataStoreUtil.write( task );

						if ( !Utilities.isEmpty( linkedDeals ) )
							{

								List <Deal> listDeal = null;
								List <String> linkedTasks = null;

								listDeal = DealDAO.getDealByID( linkedDeals );

								for ( Deal deal : listDeal )
									{

										linkedTasks = deal.getLinkedTasks();

										if ( !Utilities.isEmpty( linkedTasks ) )
											linkedTasks.remove( taskID );
									}
								listDeal = (List <Deal>) DataStoreUtil.batchWrite( listDeal );
							}
						status = true;
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "accountID :" + accountId + "\n json :  " + json , e );
						EmailUtil.sendJavaErrorMailWithParams( "accountID :" + accountId + "\n json :  " + json , e );
					}
				finally
					{
						map.put( "success" , status );
						map.put( "task" , task );
						map.put( "account" , account );
						map.put( "dissociateaccount" , listDissociateAccount );
					}
				return map;
			}

		@SuppressWarnings( "deprecation" )
		public static Map <String , Object> updateContactForLinkedTask_v1( String accountID , String taskID , String json )
			{

				boolean success = false;

				String errorInfo = null , CMSUrl = null , respJSON = null , contactID = null , newCompanyID = null, timeZoneFromContactMethods = null;

				List <String> listOfContactIDToLink = null , listOfContactIDToDelink = null , linkedContacts = null;

				Map <String , Object> map = new HashMap <String , Object>() , mapOfContactInfoForUpdate = null , mapOfContactInfo = null , mapOfTimeZoneInfo = null;

				StringBuilder errorInfoBuilder = null , urlBuilder = null;
				JsonNode rootNode = null;
				ObjectMapper objectMapper = new ObjectMapper();
				Task task = null , updatedTask = null;
				List<Map<String, String>> linkedContactMethods = null;

				try
					{

						mapOfContactInfoForUpdate = objectMapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );
						contactID = (String) mapOfContactInfoForUpdate.get( "contactID" );
						
						//@shv - for updating the timezone of the lead based on the linked contact methods
						if(mapOfContactInfoForUpdate.containsKey("linkedContactMethods") && !mapOfContactInfoForUpdate.containsKey("timeZone")) {
							linkedContactMethods = (List<Map<String, String>>) mapOfContactInfoForUpdate.get("linkedContactMethods");
							timeZoneFromContactMethods = Utilities.getTimeZoneInfoOfContact(linkedContactMethods);
							
							if(!StringUtil.isBlank( timeZoneFromContactMethods ))
								mapOfContactInfoForUpdate.put("timeZone", timeZoneFromContactMethods);
						}

						urlBuilder = new StringBuilder();
						urlBuilder.append( StringConstants.DS_API_URL ).append( "/" ).append( taskID )
								.append( StringConstants.UPDATE_CONTACT_FOR_LINKED_TASK_URL_PATH ).append( "?apikey=" ).append( accountID );
						CMSUrl = urlBuilder.toString();

						json = objectMapper.writeValueAsString( mapOfContactInfoForUpdate );
						respJSON = (String) URLFetchService.URLFetch( CMSUrl , "PUT" , "application/json" , json );

						rootNode = Utilities.validateSuccessAndGetRootNodeFromJSON( respJSON , "Contact not updated" );

						JsonNode mapOfContactNode = rootNode.path( "contact" );
						mapOfContactInfo = ContactService.getCustomFieldsMapForContacts( mapOfContactNode );

						JsonNode linkContactsNode = rootNode.path( "linkContacts" );
						listOfContactIDToLink = objectMapper.convertValue( linkContactsNode , new TypeReference <List <String>>()
							{
							} );

						JsonNode delinkContactsNode = rootNode.path( "delinkContacts" );
						listOfContactIDToDelink = objectMapper.convertValue( delinkContactsNode , new TypeReference <List <String>>()
							{
							} );

						JsonNode newCompanyIDNode = rootNode.path( "newCompanyID" );
						if ( !newCompanyIDNode.isMissingNode() )
							newCompanyID = newCompanyIDNode.asText();

						task = DataStoreUtil.getObjectByID( Task.class , taskID );
						linkedContacts = Utilities.createNewIfNull( task.getLinkedContacts() );

						if ( !Utilities.isEmpty( listOfContactIDToLink ) && !linkedContacts.contains( listOfContactIDToLink.get( 0 ) ) )
							linkedContacts.add( listOfContactIDToLink.get( 0 ) );

						updatedTask = DataStoreUtil.write( task );

						mapOfTimeZoneInfo = ContactService.getUTCOffsetAndTimeZoneIDForContacts( null , mapOfContactInfo );

						// add/remove tags
						Map <String , Object> mapTagData = null;
						mapTagData = objectMapper.readValue( respJSON , new TypeReference <Map <String , Object>>()
							{
							} );

						if ( mapTagData.containsKey( "tags" ) || mapTagData.containsKey( "deletedtags" ) )
							{

								if ( mapTagData.containsKey( "tags" ) )
										map.put( "tags" , mapTagData.get( "tags" ) );

								if ( mapTagData.containsKey( "taginfo" ) )
										map.put( "taginfo" , mapTagData.get( "taginfo" ) );

								if ( mapTagData.containsKey( "deletedtags" ) )
										map.put( "deletedtags" , mapTagData.get( "deletedtags" ) );
							}
						success = true;
					}
				catch ( Exception e )
					{
						errorInfoBuilder = new StringBuilder();
						errorInfoBuilder.append( " taskID : " ).append( taskID ).append( "  contactID : " ).append( contactID );
						errorInfoBuilder.append( " JSON : " ).append( json );
						errorInfo = errorInfoBuilder.toString();
						mLogger.log( Level.SEVERE , "\n Exception : " + errorInfo , e );
						EmailUtil.sendJavaErrorMailWithParams( "Exception :" + errorInfo , e );
					}
				finally
					{
						map.put( "success" , success );
						if ( success )
							{
								if ( !Utilities.isEmpty( listOfContactIDToLink ) )
									map.put( "linkContacts" , listOfContactIDToLink );

								if ( !Utilities.isEmpty( listOfContactIDToDelink ) )
									map.put( "delinkContacts" , listOfContactIDToDelink );

								if ( !Utilities.isNull( newCompanyID ) )
									map.put( "newCompanyID" , newCompanyID );

								if ( !Utilities.isEmpty( mapOfTimeZoneInfo ) )
									map.put( "timeZoneInfo" , mapOfTimeZoneInfo );

								map.put( "contactID" , contactID );
								map.put( "contacts" , mapOfContactInfo );
								map.put( "task" , updatedTask );
								map.put( "taskID" , taskID );
							}
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> checkDepartmentForTask( String json , String departmentIDOfTask ) throws Exception
			{

				String departmentID = null;

				List <String> listOfAccessibleDepartments = null;
				Map <String , Object> map = new HashMap <String , Object>(), mapInput = null;

				ObjectMapper mapper = new ObjectMapper();

				mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
					{
					} );

				departmentID = (String) mapInput.get( "departmentID" );
				listOfAccessibleDepartments = (List <String>) mapInput.get( "accessibleDepartments" );

				if ( !StringUtil.isBlank( departmentID ) && !StringUtil.isBlank( departmentIDOfTask )
						&& !departmentID.equals( departmentIDOfTask ) )
					{

						if ( Utilities.isEmpty( listOfAccessibleDepartments ) || !listOfAccessibleDepartments.contains( departmentIDOfTask ) )
							{
								map.put( "errorMessage" ,
										"Cannot access other department task from this department, try changing to the right department and load the task." );
								return map;
							}
						else
							{
								map.put( "switchDepartment" , departmentIDOfTask );
							}
					}

				return map;
			}

		public static Map <String , Object> getDsEntities()
			{

				boolean success = false;

				List <String> listEntity = null;
				Map <String , Object> map = new HashMap <>();

				try
					{

						listEntity = new ArrayList <String>();
						listEntity.add( "Task" );
						success = true;
					}
				catch ( Exception e )
					{
						String msg = "Exception in getDsEntities";
						mLogger.log( java.util.logging.Level.SEVERE , msg , e );
						// EmailUtil.sendJavaErrorMailWithParams(msg, e);
					}
				finally
					{
						map.put( "success" , success );
						map.put( "entities" , listEntity );
					}
				return map;
			}

		public static Map <String , Object> getDsEntitiyProperties( String entityType )
			{

				boolean success = false;
				Map <String , Object> map = new HashMap <>();

				try
					{

						if ( "task".equalsIgnoreCase( entityType ) )
							{

								String[] arrTaskProperties =
									{ "ID" , "type" , "status" , "dueDate" , "comments" , "notes" , "createdDate" , "assigneeID" , "ownerID" ,
											"linkedAccount" , "linkedContacts" , "linkedDeal" , "linkedSubscribers" , "linkedCustomFields" ,
											"linkedTags" , "linkedTasks" , "linkedDocuments" , "timeZone" , "accountID" , "rating" , "department" ,
											"productID" , "mailContent" , "taskContent" , "timeZoneID" , "UTCOffset" , "departmentID" ,
											"accountNumber" , "name" , "phone" , "email" };
								map.put( "properties" , arrTaskProperties );
							}
						success = true;
					}
				catch ( Exception e )
					{
						String msg = "Exception in getDsEntitiyProperties, entityType : " + entityType;
						mLogger.log( java.util.logging.Level.SEVERE , msg , e );
						// EmailUtil.sendJavaErrorMailWithParams(msg, e);
					}
				finally
					{
						map.put( "success" , success );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		private static Map <String , Object> createCustomFieldForTask( List <Map <String , Object>> listOfCustomField , String utcOffsetString ,
																		Task task , String departmentID ) throws Exception
			{

				List <String> linkedCustomFieldID = null;

				Map <String , Object> customFieldMap = null;
				Map <String , Object> map = new HashMap <String , Object>();

				ObjectMapper mapper = new ObjectMapper();

				if ( !Utilities.isEmpty( listOfCustomField ) )
					{

						Map <String , Object> cfMap = new HashMap <String , Object>() , taskDetailMap = new HashMap <>();
						Map <String , Object> taskMap = new HashMap <>();

						cfMap.put( "entityID" , task.getID() );
						cfMap.put( "departmentID" , departmentID );
						cfMap.put( "customField" , listOfCustomField );
						cfMap.put( "ownerID" , task.getOwnerID() );

						if ( !StringUtil.isBlank( utcOffsetString ) )
							cfMap.put( "utcOffsetString" , utcOffsetString );

						cfMap.put( "entityType" , "task" );

						taskDetailMap.put( "comments" , task.getComments() );
						taskDetailMap.put( "createdDate" , task.getCreatedDate().getTime() );
						if ( !Utilities.isNull( task.getLastUpdatedDate() ) )
							taskDetailMap.put( "lastUpdatedDate" , task.getLastUpdatedDate().getTime() );
						taskDetailMap.put( "deleted" , false );
						taskDetailMap.put( "departmentID" , task.getDepartmentID() );
						taskMap.put( task.getID() , taskDetailMap );

						cfMap.put( "searchinfo" , taskMap );

						mLogger.log( java.util.logging.Level.INFO , "customFieldMap : " + customFieldMap );

						mLogger.log( java.util.logging.Level.INFO , "cfMap : " + cfMap );

						customFieldMap = CustomFieldService.createCustomFieldForNewEntity( task.getOwnerID() , task.getAccountID() ,
								mapper.writeValueAsString( cfMap ) );

						if ( (Boolean) customFieldMap.get( "success" ) )
							{

								linkedCustomFieldID = (List <String>) customFieldMap.get( "customFieldID" );

								if ( !Utilities.isEmpty( linkedCustomFieldID ) )
									{
										task.setLinkedCustomFields( linkedCustomFieldID );
										task = DataStoreUtil.write( task );
									}
								customFieldMap.remove( "success" );
								map.put( "customfield" , customFieldMap );
							}
					}
				return map;
			}

		private static String getTaskRequestDataFromReader( HttpServletRequest request )
			{

				String taskJson = null;
				
				try
					{

						StringBuffer sb = new StringBuffer();
						BufferedReader bufferedReader = null;

						try
							{
								request.setCharacterEncoding( utfCharset );
								bufferedReader = request.getReader();
								char[] charBuffer = new char [128];
								int bytesRead;

								while ( ( bytesRead = bufferedReader.read( charBuffer ) ) != -1 )
									{
										sb.append( charBuffer , 0 , bytesRead );
									}

							}
						catch ( IOException ex )
							{
								throw ex;
							}
						finally
							{

								if ( bufferedReader != null )
									{
										try
											{
												bufferedReader.close();
											}
										catch ( IOException ex )
											{
												throw ex;
											}
									}
							}
						taskJson = sb.toString();
					}
				catch ( Exception e )
					{
						String params = "Params: taskJson: "+taskJson;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				return taskJson;

			}

		@SuppressWarnings( "unchecked" )
		private static Map <String , Object> getTaskMultipartRequestData( HttpServletRequest request ) throws Exception
			{

				String fileName = "" , fileNameLC = null , mimeType = null;

				List <Map <String , Object>> documents = null;
				List<String> listData = Arrays.asList( "linkedSubscribers", "subscribers", "tags", "linkedDeals", "linkedAccounts", "linkedContacts",
														"removeSubscribers", "customField", "history", "linkedDocuments");

				List<String> mapData = Arrays.asList( "taskinfo", "taskSubscriberInfo");
				
				List <Object> tempList = null;

				Map <String , Object> map = new HashMap <>() , documentMap = null , taskMap = null, tempMap = null;

				ObjectMapper mapper = new ObjectMapper();

				try
					{

						taskMap = new HashMap <String , Object>();
						Base64 base64 = new Base64();
						documents = new ArrayList <Map <String , Object>>();
						ServletFileUpload upload = new ServletFileUpload();

						FileItemIterator iter;
						iter = upload.getItemIterator( request );

						while ( iter.hasNext() )
							{
								mimeType = null;
								documentMap = new HashMap <String , Object>();
								fileName = null;
								FileItemStream item = iter.next();
								InputStream stream = item.openStream();

								if ( item.isFormField() )
									{
										String name = item.getFieldName();
										Object data = Streams.asString( stream , utfCharset );
										if ( listData.contains( name ) && !StringUtil.isBlank( (String) data ) )
											{

												tempList = new ArrayList <Object>();
												if ( data instanceof String )
													tempList = mapper.readValue( (String) data , ArrayList.class );
												else if ( data instanceof List )
													tempList = (List <Object>) data;

												taskMap.put( name , tempList );
											}
										else if ( mapData.contains( name ) && !StringUtil.isBlank( (String) data ) )
											{

												tempMap = new HashMap<String,Object>();
												if ( data instanceof String )
													tempMap = mapper.readValue( (String) data ,
															new TypeReference <HashMap <String , Object>>()
															{
															} );
												else if ( data instanceof Map )
													tempMap = (Map<String,Object>) data;

												taskMap.put( name , tempMap );
											}
										else if ( !StringUtil.isBlank( (String) data ) )
											taskMap.put( name , data );
									}
								else
									{
										fileName = item.getName();
										if ( !StringUtil.isBlank( fileName ) )
											fileNameLC = fileName.toLowerCase();

										if ( !StringUtil.isBlank( fileNameLC ) )
											mimeType = Utilities.getMimeTypeFromFile( fileNameLC );

										documentMap.put( "documentData" , new String( base64.encode( IOUtils.toByteArray( stream ) ) ) );
										documentMap.put( "type" , mimeType );
										documentMap.put( "name" , fileName );
										documents.add( documentMap );
									}
							}
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE ,
								"Exception in TaskService , method - getTaskMultipartRequestData , task data  : " + taskMap , e );
						EmailUtil.sendJavaErrorMailWithParams( "Exception in TaskService , method - getTaskMultipartRequestData , task data  : "
								+ taskMap , e );
					}
				finally
					{
						map.put( "task" , taskMap );
						map.put( "documents" , documents );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		private static Map <String , Object> createTagsForTask( Map <String , Object> taskMap , Task task , String operation )
			{

				String taskJson = null , respJSON = null;

				StringBuilder url = null;

				List <String> listTagName = null , linkedTags = null;
				List <Tag> listTagsFrmDb = null;

				Map <String , Object> map = new HashMap <>() , mapOfTag = null;

				ObjectMapper mapper = new ObjectMapper();
				JsonNode rootNode = null , successNode = null , tagNode = null , linkedTagsNode = null;

				try
					{

						listTagName = (List <String>) taskMap.get( "tags" );

						if ( !Utilities.isEmpty( listTagName ) && !listTagName.contains( "null" ) )
							{

								taskMap.put( "entityType" , "task" );
								taskMap.put( "entityID" , task.getID() );
								taskMap.put( "departmentID" , task.getDepartmentID() );

								taskJson = mapper.writeValueAsString( taskMap );

								url = new StringBuilder();
								url.append( StringConstants.CREATE_TAG_URL ).append( "?apikey=" ).append( task.getAccountID() );

								respJSON = (String) URLFetchService.URLFetch( url.toString() , "POST" , "application/json" , taskJson );
								rootNode = mapper.readValue( respJSON , JsonNode.class );

								if ( rootNode == null )
									return map;

								successNode = rootNode.path( "status" );

								if ( successNode.isMissingNode() || !successNode.booleanValue() )
									return map;

								tagNode = rootNode.path( "tags" );
								linkedTagsNode = rootNode.path( "ids" );

								mapOfTag = new HashMap <String , Object>();
								listTagsFrmDb = mapper.convertValue( tagNode , new TypeReference <List <Tag>>()
									{
									} );

								if ( "create".equalsIgnoreCase( operation ) )
									{
										linkedTags = mapper.convertValue( linkedTagsNode , new TypeReference <List <String>>()
											{
											} );
									}
								else if ( "update".equalsIgnoreCase( operation ) )
										linkedTags = Utilities.createNewIfNull( task.getLinkedTags() );

								if ( !Utilities.isEmpty( listTagsFrmDb ) )
									{

										for ( Tag tag : listTagsFrmDb )
											{

												if ( !linkedTags.contains( tag.getID() ) )
													linkedTags.add( tag.getID() );

												mapOfTag.put( tag.getID() , tag );
											}
										task.setLinkedTags( linkedTags );
									}
							}
					}
				catch ( Exception e )
					{
						String params= "Params- taskMap: "+taskMap+" operation: "+operation;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "task" , task );
						map.put( "tag" , mapOfTag );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		private static void createDocumentsForTask( List <Map <String , Object>> documents , Task task )
			{

				String respJSON = null, mimeType, fileName, accountID = null, departmentID, taskID = null;

				Map <String , Object> docMap, documentsMap = new HashMap<String, Object>(), respMap = null;
				List<Map<String,Object>> documentMaps = new ArrayList<Map<String, Object>>();

				ByteArrayInputStream stream=null;
				Object data;
				byte[] bytes=null;

				try
					{
						
						taskID = task.getID();
						accountID = task.getAccountID();
						departmentID = task.getDepartmentID();
						
						for(Map<String, Object> documentMap : documents) {

							mimeType = (String) documentMap.get("type");
							fileName = (String) documentMap.get("name");
							
							data = documentMap.get("documentData"); 
							
							if(data instanceof String){
								Base64 base64 = new Base64();
								bytes= base64.decode(((String)data).getBytes());
							}
							else if(!(data instanceof byte[]))
								throw new Exception("Unrecognized documentData type");
							else
								bytes = (byte[])data;
							
							stream = new ByteArrayInputStream(bytes);
							
							docMap = DocumentService.uploadDocumentToGcs( fileName , true , departmentID , stream , accountID , mimeType , null , false );
							documentMaps.add(docMap);
						}

						documentsMap.put("entityID", taskID);
						documentsMap.put("entityType", "task");
						documentsMap.put("ownerID", task.getOwnerID()); //ownerID could be null
						
						//we can send a null value in below statement because it is not used for datastore operations and we don't need the response of the request
						documentsMap.put("linkedDocuments", task.getLinkedDocuments());
						
						documentsMap.put("documents", documentMaps);
						documentsMap.put("departmentID", departmentID);
						
						respMap = (HashMap<String, Object>) DocumentService.uploadDocumentsForEntity_CMSUpdate( documentsMap , accountID , false );
						
						if(!(Boolean)respMap.get( "success" ) || respMap.containsKey( "error" ))
							throw new Exception("Unable to upload documents for task");
					}
				catch ( Exception e )
					{
						String params = "Params- documents"+documents+" \n documentMaps: "+documentMaps+" respJSON: "+respJSON+" accountID: "+accountID
										+" taskID: "+taskID+" respMap: "+respMap;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
			}

		@SuppressWarnings( "unchecked" )
		private static Map <String , Object> createHistoryForTask( Map <String , Object> taskMap , Task task )
			{

				boolean status = false;

				String historyJson = null , respJSON = null , CMSPostURL = null;

				StringBuilder urlBuilder = null;

				List <Map <String , Object>> listMapHistory = null;
				List <History> listHistory = null;

				Map <String , Object> map = new HashMap <>(), mapHistory = null;

				ObjectMapper mapper = new ObjectMapper();
				JsonNode rootNode = null , successNode = null, historyNode = null;

				try
					{

						listMapHistory = (List <Map <String , Object>>) taskMap.get( "history" );

						//important because some projects use API to create history while creating task
						for ( Map <String , Object> mapItr : listMapHistory )
							{
								mapItr.put( "taskID" , task.getID() ); 
							}

						mapHistory = new HashMap <>();
						mapHistory.put( "history" , listMapHistory );
						historyJson = mapper.writeValueAsString( mapHistory );

						urlBuilder = new StringBuilder();
						urlBuilder.append( StringConstants.INSERT_BULK_HISTORY_URL ).append( "?apikey=" ).append( task.getAccountID() );
						CMSPostURL = urlBuilder.toString();

						respJSON = (String) URLFetchService.URLFetch( CMSPostURL , "POST" , "application/json" , historyJson );

						rootNode = mapper.readValue( respJSON , JsonNode.class );
						successNode = rootNode.path( "status" );
						historyNode = rootNode.path( "history" );

						if ( successNode.isMissingNode() || !successNode.booleanValue() )
							throw new Exception( "History Not Inserted In Insert Task Service, respJSON : " + respJSON );

						listHistory = mapper.convertValue( historyNode , new TypeReference <List <History>>()
							{
							} );
						status = true;
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "Exception in TaskService , method - createHistoryForTask , taskMap  : "
								+ taskMap , e );
						EmailUtil
								.sendJavaErrorMailWithParams( "Exception in TaskService , method - createHistoryForTask , taskMap  : " + taskMap , e );
					}
				finally
					{
						map.put( "status" , status );
						map.put( "history" , listHistory );
					}
				return map;
			}

		private static void createOrUpdateSearchIndexForTask( Task task )
			{

				String respJSON = null;

				StringBuilder url = null;

				Map <String , Object> searchIndexMap = null , tasksMap = null;

				ObjectMapper mapper = new ObjectMapper();

				try
					{

						searchIndexMap = new HashMap <String , Object>();
						tasksMap = new HashMap <String , Object>();
						searchIndexMap.put( "taskID" , task.getID() );
						searchIndexMap.put( "linkedCustomFields" , task.getLinkedCustomFields() );
						searchIndexMap.put( "comments" , task.getComments() );
						searchIndexMap.put( "lastUpdatedDate" , task.getLastUpdatedDate() );

						if ( "deleted".equalsIgnoreCase( (String) task.getStatus() ) )
							searchIndexMap.put( "deleted" , true );
						else
							searchIndexMap.put( "deleted" , false );

						searchIndexMap.put( "departmentID" , task.getDepartmentID() );

						tasksMap.put( task.getID() , searchIndexMap );

						url = new StringBuilder();
						url.append( StringConstants.INSERT_TASK_SEARCH_INDEX_URL ).append( "?apikey=" ).append( task.getAccountID() );

						respJSON = (String) URLFetchService.URLFetch( url.toString() , "POST" , "application/json" ,
								mapper.writeValueAsString( tasksMap ) );

						mLogger.log( java.util.logging.Level.INFO , "insert lucene search for task response , respJSON :  " + respJSON );

						url = new StringBuilder();
						url.append( StringConstants.TASK_SEARCH_API_INDEX_URL ).append( "?apikey=" ).append( task.getAccountID() );

						respJSON = (String) URLFetchService.URLFetch( url.toString() , "POST" , "application/json" ,
								mapper.writeValueAsString( tasksMap ) );

						mLogger.log( java.util.logging.Level.INFO , "insert app engine search for task response , respJSON :  " + respJSON );

					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE ,
								"Exception in TaskService , method - createOrUpdateSearchIndexForTask , searchIndexMap  : " + searchIndexMap , e );
						EmailUtil.sendJavaErrorMailWithParams(
								"Exception in TaskService , method - createOrUpdateSearchIndexForTask , searchIndexMap  : " + searchIndexMap , e );
					}
				finally
					{

					}
			}

		private static void associateTaskToAccountsContactsAndDeals( String accountsID , List <String> linkedContacts, Long dealID , Task task )
			{

				String json = null , respJSON = null;

				Map <String , Object> mapData = null;

				ObjectMapper mapper = new ObjectMapper();

				try
					{

						if ( !StringUtil.isBlank( accountsID ) || !Utilities.isEmpty( linkedContacts ) )
							{

								mapData = new HashMap <String , Object>();

								if ( !StringUtil.isBlank( accountsID ) )
									mapData.put( "linkedAccounts" , Arrays.asList(accountsID) );

								if ( !Utilities.isEmpty( linkedContacts ) )
									mapData.put( "linkedContacts" , linkedContacts );

								json = mapper.writeValueAsString( mapData );
								respJSON = (String) URLFetchService.associateTaskToAccountsAndContacts( task.getAccountID() , task.getID() , json );

								mLogger.log( java.util.logging.Level.INFO , "associate plain task to account/contact response json : " + respJSON );
							}

						if ( dealID != null && dealID != 0D )
							{

								mapData = new HashMap <String , Object>();
								mapData.put( "linkedDeals" , Arrays.asList(dealID) );
//								mapData.put( "departmentID" , task.getDepartmentID() );

								DealService.associateTaskToDeals_v2( task.getAccountID() , task.getID() , mapData );
							}
					}
				catch ( Exception e )
					{
						String params = "Params- accountsID: "+accountsID+" dealID: "+dealID+" linkedContacts: "+linkedContacts+" respJSON: "+respJSON;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
			}

		private static Map <String , Object> createSubTask( Map <String , Object> taskMap , Task task )
			{

				boolean status = false;

				String parentTaskID = null;

				Map <String , Object> mapParentTask = null, map = new HashMap <>();

				Task parentTask = null;

				try
					{
						parentTaskID = (String) taskMap.get( "parentTaskID" );

						if ( !StringUtil.isBlank( parentTaskID ) && parentTaskID != "undefined" && parentTaskID != "null" )
							{
								mapParentTask = associateSubTaskToTask( parentTaskID , task.getID() );
								parentTask = (Task) mapParentTask.get( "task" );
							}
						status = true;
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "Exception in TaskService , method - createSubTask , taskMap  : " + taskMap , e );
						EmailUtil.sendJavaErrorMailWithParams( "Exception in TaskService , method - createSubTask , taskMap  : " + taskMap , e );
					}
				finally
					{
						map.put( "status" , status );
						map.put( "parentTask" , parentTask );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		private static Map <String , Object> createCustomFieldsForTask( List <Map <String , Object>> listOfCustomField , Map <String , Object> taskMap , Task task )
			{

				boolean status = false;

				String utcOffsetString = null;

				Map <String , Object> map = new HashMap <>();
				Map <String , Object> mapCustomField = null , mapCf = null;

				try
					{

						utcOffsetString = (String) taskMap.get( "utcOffsetString" );

						if ( !Utilities.isEmpty( listOfCustomField ) )
							{
								mapCustomField = createCustomFieldForTask( listOfCustomField , utcOffsetString , task , task.getDepartmentID() );

								mapCf = (Map <String , Object>) mapCustomField.get( "customfield" );
							}
						status = true;
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "Exception in TaskService , method - createCustomFieldsForTask , taskMap  : "
								+ taskMap , e );
						EmailUtil.sendJavaErrorMailWithParams( "Exception in TaskService , method - createCustomFieldsForTask , taskMap  : "
								+ taskMap , e );
					}
				finally
					{
						map.put( "status" , status );
						map.put( "customField" , mapCf );
					}
				return map;
			}

		private static void updateTaskStatusToActiveResponse( String login , String status , Task task , String connectionID ) throws Exception
			{

				String arJson = null;
				Map <String , Object> mapAr = new HashMap <>();
				ObjectMapper mapper = new ObjectMapper();

				mapAr.put( "taskID" , task.getID() );
				mapAr.put( "userlogin" , login );
				mapAr.put( "arstatus" , status );
				mapAr.put( "connectionID" , connectionID );

				arJson = mapper.writeValueAsString( mapAr );

				mLogger.log( java.util.logging.Level.INFO , "going to add taskqueue updateResolveTaskInteraction, taskID : " + task.getID()
						+ "\n arJson : " + arJson );

				Queue queue = QueueFactory.getQueue( "Tasks" );
				queue.add( TaskOptions.Builder.withUrl( "/updateResolveTaskInteraction" ).method( Method.POST ).payload( arJson ) );

			}

		/*public static Map <String , Object> createTaskForServiceDeptMsgs( HttpServletRequest request , String staticContentUrl , String json )
			{

				boolean success = false;

				String taskID = null , accountNumber = null , phone = null , email = null , respJSON = null, 
						historyComments = null , cmsJson = null , historyJson = null, agentName = null , 
						agentLogin = null , brandID = null , name = null , taskNotes = null, taskSummary = null;

				List <Map <String , Object>> listHistoryMap = null;
				List <Account> listAccount = null;
				List <Contact> listContact = null;
				List <String> linkedAccounts = null , linkedContacts = null;

				Map <String , Object> map = new HashMap <>() , mapInput = null , mapCms = null , 
									mapTask = null, mapHistory = null , mapOfRespInfo = null;

				StringBuilder url = null , historyBuilder = null;
				ObjectMapper mapper = new ObjectMapper();
				mapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES , false );
				Task task = null;
				Account account = null;
				Contact contact = null;
				JsonNode rootNode = null , accountNode = null , contactNode = null;

				try
					{
						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						mLogger.log( java.util.logging.Level.INFO , "createTaskForServiceDeptMsgs, incoming data : " + mapInput );

						accountNumber = (String) mapInput.get( "accountNumber" );
						name = (String) mapInput.get( "name" );
						phone = (String) mapInput.get( "phone" );
						email = (String) mapInput.get( "email" );

						accountNumber = Utilities.correctToNull( accountNumber );
						name = Utilities.correctToNull( name );
						phone = Utilities.correctToNull( phone );
						email = Utilities.correctToNull( email );

						try
							{

								if ( StringUtil.isBlank( accountNumber ) )
									accountNumber = "";

								mapCms = new HashMap <>();
								mapCms.put( "accountNumber" , accountNumber );
								mapCms.put( "email" , email );
								mapCms.put( "phone" , phone );
								mapCms.put( "departmentID" , businessServiceDepartmentID );

								cmsJson = mapper.writeValueAsString( mapCms );

								url = new StringBuilder();
								url.append( SalesResources.SEARCH_FOR_SERVICE_DEPARTMENT_MESSAGE_TASK_URL ).append( "?apikey=SEN42" );

								mapOfRespInfo = URLFetchService.URLFetch_v2( url.toString() , "POST" , "application/json" , cmsJson );

								mLogger.log( java.util.logging.Level.INFO , "mapOfRespInfo : " + mapOfRespInfo );

								respJSON = (String) mapOfRespInfo.get( "response" );
								rootNode = mapper.readValue( respJSON , JsonNode.class );

								accountNode = rootNode.path( "accounts" );
								contactNode = rootNode.path( "contacts" );

								if ( accountNode != null && !accountNode.isNull() )
									listAccount = mapper.readValue( accountNode , new TypeReference <List <Account>>()
										{
										} );

								if ( contactNode != null && !contactNode.isNull() )
									listContact = mapper.readValue( accountNode , new TypeReference <List <Contact>>()
										{
										} );

								if ( !Utilities.isEmpty( listAccount ) )
									{

										linkedAccounts = new ArrayList <>();

										account = listAccount.get( 0 );
										linkedAccounts.add( account.getID() );
										brandID = account.getBrandID();

										mapInput.put( "linkedAccounts" , linkedAccounts );
									}

								if ( !Utilities.isEmpty( listContact ) )
									{

										linkedContacts = new ArrayList <>();
										contact = listContact.get( 0 );
										brandID = contact.getBrandID();

										linkedContacts.add( contact.getID() );
										mapInput.put( "linkedContacts" , linkedContacts );
									}
								mapInput.put( "brandID" , brandID );
							}
						catch ( Exception e )
							{
								String data = null;
								data = "Exception while trying to fetch account in cms method = searchForServiceDeptMsgTask, cmsJson : " + cmsJson;
								mLogger.log( java.util.logging.Level.SEVERE , data , e );
								EmailUtil.sendJavaErrorMailWithParams( data , e );
							}

						mapInput.put( "status" , "pending" );
						mapInput.put( "department" , serviceTaskDepartment );
						mapInput.put( "departmentID" , businessServiceDepartmentID );

						String taskTypeID = TaskTypeService.getTaskTypeIDByType( answerConnectAccountID , "inbound-service-call" );
						mapInput.put( "type" , taskTypeID );

						json = mapper.writeValueAsString( mapInput );

						mapTask = createTask( answerConnectAccountID , json , request );

						task = (Task) mapTask.get( "task" );

						if ( task == null )
							throw new NullPointerException( "Service Dept Msg Task Not Saved in createTaskForServiceDeptMsgs, json : " + json );

						taskID = task.getID();
						taskNotes = task.getNotes();
						taskSummary = task.getComments();

						listHistoryMap = new ArrayList <>();

						historyBuilder = new StringBuilder();

						if ( !StringUtil.isBlank( taskSummary ) )
							historyBuilder.append( "Details : " ).append( "<br/><br/>" ).append( "<b style=color:#0084b0;>Summary : </b>" )
									.append( task.getComments() ).append( "<br/>" );

						historyBuilder.append( "<b style=color:#0084b0;>Account Number : </b>" ).append( accountNumber );

						if ( !StringUtil.isBlank( name ) )
							historyBuilder.append( "<br/>" ).append( "<b style=color:#0084b0;>Name : </b>" ).append( name );

						if ( !StringUtil.isBlank( phone ) )
							historyBuilder.append( "<br/>" ).append( "<b style=color:#0084b0;>Phone : </b>" ).append( phone );

						if ( !StringUtil.isBlank( email ) )
							historyBuilder.append( "<br/>" ).append( "<b style=color:#0084b0;>Email : </b>" ).append( email );

						if ( !StringUtil.isBlank( taskNotes ) )
							historyBuilder.append( "<br/>" ).append( "<b style=color:#0084b0;>Description : </b>" ).append( taskNotes );

						historyComments = historyBuilder.toString();

						if ( mapInput.containsKey( "agentEmail" ) )
							{
								agentLogin = (String) mapInput.get( "agentEmail" );
								agentLogin = Utilities.correctToNull( agentLogin );

								if ( !StringUtil.isBlank( agentLogin ) )
									{
										agentName = agentLogin.split( "\\." ) [0];
										agentName = agentName + "<" + agentLogin + ">";
									}
							}

						mapHistory = new HashMap <String , Object>();
						mapHistory.put( "accountID" , answerConnectAccountID );
						mapHistory.put( "ownerName" , agentName );
						mapHistory.put( "taskID" , taskID );
						mapHistory.put( "type" , "inboundemail" );
						mapHistory.put( "historyComments" , historyComments );
						mapHistory.put( "departmentID" , businessServiceDepartmentID );

						listHistoryMap.add( mapHistory );

						historyBuilder = new StringBuilder();
						historyBuilder.append( "Task Info : " ).append( "<br/><br/>" ).append( "<b style=color:#0084b0;>Summary : </b>" )
								.append( task.getComments() ).append( "<br/>" );

						if ( !StringUtil.isBlank( taskNotes ) )
							historyBuilder.append( "<b style=color:#0084b0;>Description : </b>" ).append( taskNotes );

						if ( !StringUtil.isBlank( name ) )
							historyBuilder.append( "<b style=color:#0084b0;>Name : </b>" ).append( name ).append( "<br/>" );

						if ( !StringUtil.isBlank( phone ) )
							historyBuilder.append( "<b style=color:#0084b0;>Phone : </b>" ).append( phone ).append( "<br/>" );

						if ( !StringUtil.isBlank( email ) )
							historyBuilder.append( "<b style=color:#0084b0;>Email : </b>" ).append( email ).append( "<br/>" );

						historyBuilder.append( "<b style=color:#0084b0;>Type : </b>" ).append( task.getType() ).append( "<br/>" )
								.append( "<b style=color:#0084b0;>URL : </b>" ).append( "<a href=" ).append( staticContentUrl ).append( "/crm#task/" )
								.append( taskID ).append( " target=_blank>" ).append( staticContentUrl ).append( "/crm#task/" ).append( taskID )
								.append( "</a>" ).append( "<br/>" );

						if ( account != null )
							{
								historyBuilder.append( "<b style=color:#0084b0;>Associated Account : </b>" ).append( "<a href=" )
										.append( staticContentUrl ).append( "/crm#account/" ).append( account.getID() ).append( " target=_blank>" )
										.append( staticContentUrl ).append( "/crm#account/" ).append( account.getID() ).append( "</a>" )
										.append( "<br/>" );
							}
						historyBuilder.append( "<b style=color:#0084b0;>Account Number : </b>" ).append( accountNumber ).append( "<br/>" )
								.append( "<b style=color:#0084b0;>Task ID : </b>" ).append( taskID ).append( "<br/>" )
								.append( "<b style=color:#0084b0;> Agent Login : </b>" ).append( agentLogin );

						historyComments = historyBuilder.toString();

						mapHistory = new HashMap <String , Object>();
						mapHistory.put( "accountID" , answerConnectAccountID );
						mapHistory.put( "ownerName" , "Log" );
						mapHistory.put( "taskID" , taskID );
						mapHistory.put( "historyComments" , historyComments );
						mapHistory.put( "type" , "log" );
						mapHistory.put( "departmentID" , businessServiceDepartmentID );

						listHistoryMap.add( mapHistory );

						Map <String , Object> mapHistoryData = new HashMap <String , Object>();

						mapHistoryData.put( "accountID" , answerConnectAccountID );
						mapHistoryData.put( "history" , listHistoryMap );

						historyJson = mapper.writeValueAsString( mapHistoryData );

						Queue queue = QueueFactory.getQueue( "Activity-Log" );
						queue.add( TaskOptions.Builder.withUrl( "/insertBulkHistoryJob" ).method( Method.POST ).payload( historyJson ) );

						if ( !StringUtil.isBlank( taskID ) )
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "pending" , taskID , null , answerConnectAccountID , serviceTaskDepartment ,
									null , businessServiceDepartmentID );

						success = true;
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "Exception in createTaskForServiceDeptMsgs method , json : " + json
								+ "\n taskID : " + taskID , e );
						EmailUtil.sendJavaErrorMailWithParams( "Exception in createTaskForServiceDeptMsgs method , json : " + json , e );
					}
				finally
					{
						map.put( "success" , success );
						map.put( "task" , task );
					}
				return map;
			}*/

		//update task
		public static Map <String , Object> updateLastUpdatedDateForTask( String taskID , String json )
			{
				Map <String , Object> mapInput = null;
				Map <String , Object> map = new HashMap <String , Object>();
				ObjectMapper mapper = new ObjectMapper();
				Task task = null;
				String status;

				boolean success = false;

				try
					{

						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						taskID = Utilities.correctToNull( taskID );

						task = DataStoreUtil.getObjectByID( Task.class , taskID );

						if( mapInput.containsKey( "status" ) ) 
							{
								status = (String) mapInput.get( "status" );
								task.setStatus( status );
							}
						
						task = DataStoreUtil.write( task );
						// setTimeZoneAndOffset( task );
							
						success = true;
					}
				catch ( Exception e )
					{
						String params = "Params- json: "+json+" taskID: "+taskID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "task" , task );
						map.put( "success" , success );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> moveTicketType( String userID, String accountId , String taskID , String taskJson )
			{

				Map <String , Object> map = new HashMap <String , Object>() , responseMap = null, 
							taskMap = null , mapCustomField = null , mapAllCf = null;
				boolean success = false;
				Task task = null;
				ObjectMapper mapper = new ObjectMapper();
				String taskType = null , utcOffsetString = null;
				List <Map <String , Object>> listOfCustomField = null;
				List <String> linkedCustomFields = null;

				try
					{
						taskID = Utilities.correctToNull( taskID );

						if ( StringUtil.isBlank( taskID ) )
							throw new Exception( "move ticket type , taskID is empty/null, taskID : " + taskID );

						taskMap = mapper.readValue( taskJson , new TypeReference <Map <String , Object>>()
							{
							} );

						listOfCustomField = (List <Map <String , Object>>) taskMap.get( "customField" );
						taskType = (String) taskMap.get( "type" );
						utcOffsetString = (String) taskMap.get( "utcOffsetString" );

						task = DataStoreUtil.getObjectByID( Task.class , taskID );
						linkedCustomFields = task.getLinkedCustomFields();

						if ( !Utilities.isEmpty( linkedCustomFields ) )
							{

								String cmsDeleteURL = "" , respJSON = "";
								StringBuffer buffer = new StringBuffer();

								buffer.append( StringConstants.DELETE_CUSTOM_FIELD_BY_ENTITYID_URL ).append( "?apikey=" );
								buffer.append( accountId ).append( "&entityID=" ).append( taskID );

								cmsDeleteURL = buffer.toString();

								respJSON = (String) URLFetchService.URLFetch( cmsDeleteURL , "DELETE" , "application/json" , "" );
								responseMap = mapper.readValue( respJSON , HashMap.class );

								if ( responseMap == null || !(Boolean) responseMap.get( "success" ) )
									throw new Exception( "Unable to delete customField in CMS" );

							}

						// 1.create a custom fields for the change ticket type
						if ( !Utilities.isEmpty( listOfCustomField ) )
							{
								mapCustomField = createCustomFieldForMoveTicketType( listOfCustomField , utcOffsetString , task ,
										task.getDepartmentID() , userID );

								mapAllCf = (Map <String , Object>) mapCustomField.get( "customfield" );

								if ( !Utilities.isEmpty( mapAllCf ) )
									map.putAll( mapAllCf );

							}
						else
							{
								task.setLinkedCustomFields( null );
							}

						// 2.update the search index(DB table) and search API document for the task
						createOrUpdateSearchIndexForTask( task );

						// 3.change the ticket type for the task
						task.setType( taskType );

						task = DataStoreUtil.write( task );

						Utilities.setTimeZoneAndOffset( task );
						
						success = true;

					}
				catch ( Exception e )
					{
						String params = "Params- accountId : " + accountId+ "\n TaskJson : " + taskJson + "\nTaskID : " + taskID+"\n userID: "+userID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );

					}
				finally
					{
						map.put( "success" , success );
						map.put( "task" , task );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> createCustomFieldForMoveTicketType( List <Map <String , Object>> listOfCustomField ,
																				String utcOffsetString , Task task , String departmentID ,
																				String ownerID ) throws Exception
			{

				List <String> linkedCustomFieldID = null;

				Map <String , Object> customFieldMap = null;
				Map <String , Object> map = new HashMap <String , Object>();

				ObjectMapper mapper = new ObjectMapper();

				if ( Utilities.isEmpty( listOfCustomField ) )
					return map;

				Map <String , Object> cfMap = new HashMap <String , Object>() , taskDetailMap = new HashMap <>();
				Map <String , Object> taskMap = new HashMap <>();

				cfMap.put( "entityID" , task.getID() );
				cfMap.put( "departmentID" , departmentID );
				cfMap.put( "customField" , listOfCustomField );
				cfMap.put( "ownerID" , ownerID );
				cfMap.put( "utcOffsetString" , utcOffsetString );
				cfMap.put( "entityType" , "task" );

				taskDetailMap.put( "comments" , task.getComments() );
				taskDetailMap.put( "createdDate" , task.getCreatedDate().getTime() );
				if ( !Utilities.isNull( task.getLastUpdatedDate() ) )
					taskDetailMap.put( "lastUpdatedDate" , task.getLastUpdatedDate().getTime() );
				taskDetailMap.put( "deleted" , false );
				taskDetailMap.put( "departmentID" , task.getDepartmentID() );
				taskMap.put( task.getID() , taskDetailMap );

				cfMap.put( "searchinfo" , taskMap );

				customFieldMap = CustomFieldService
						.createCustomFieldForNewEntity( ownerID , task.getAccountID() , mapper.writeValueAsString( cfMap ) );

				if ( (Boolean) customFieldMap.get( "success" ) )
					{

						linkedCustomFieldID = (List <String>) customFieldMap.get( "customFieldID" );

						if ( !Utilities.isEmpty( linkedCustomFieldID ) )
							{
								task.setLinkedCustomFields( linkedCustomFieldID );
								task = DataStoreUtil.write( task );
							}
						customFieldMap.remove( "success" );
						map.put( "customfield" , customFieldMap );
					}

				return map;
			}

		//welcome-call tasks are no longer being created
		/*public static Map <String , Object> createTaskForWelcomeCall( HttpServletRequest request , String staticContentUrl , String json )
			{

				boolean status = false;
				Boolean isAccountExist = false;

				String accountsID = null , comments = null , historyJson = null , taskJson = null , accountNumber = null;
				String taskID = null , historyComments = null , department = null , respJSON = null , feedBackType = null;
				String brandID = null , accountID = "SEN42" , contactID = null;

				List <String> linkedAccounts = null , linkedContacts = null;
				List <Map <String , Object>> listHistoryMap = new ArrayList <Map <String , Object>>();

				Map <String , Object> map = new HashMap <String , Object>() , mapInput = null , mapTask = null , mapOfRespInfo = null;
				Map <String , Object> mapHistory = null;

				Task task = null;

				StringBuilder historyBuilder = null , url = null;
				ObjectMapper mapper = new ObjectMapper();
				JsonNode rootNode = null;
				Account account = null;

				try
					{

						mLogger.log( java.util.logging.Level.WARNING , "createTaskForWelcomeCall , json : " + json );

						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						accountsID = (String) mapInput.get( "accountsID" );
						accountsID = Utilities.correctToNull( accountsID );

						accountNumber = (String) mapInput.get( "accountNumber" );

						if ( StringUtil.isBlank( accountsID ) )
							throw new NullPointerException( "accountsID is empty, json : " + json );

						linkedAccounts = new ArrayList <String>();
						mapTask = new HashMap <String , Object>();

						try
							{

								url = new StringBuilder();
								url.append( SalesResources.ACCOUNTS_API_URL ).append( "/" ).append( accountsID )
										.append( SalesResources.GET_ACCOUNT_URL_PATH ).append( "?apikey=" ).append( accountID );

								mapOfRespInfo = URLFetchService.URLFetch_v2( url.toString() , "GET" , "application/json" , "" );
								respJSON = (String) mapOfRespInfo.get( "response" );
								rootNode = mapper.readValue( respJSON , JsonNode.class );

								JsonNode accountNode = rootNode.path( "account" );
								account = mapper.readValue( accountNode , Account.class );

								if ( account != null )
									{
										linkedAccounts.add( account.getID() );
										brandID = account.getBrandID();
										linkedContacts = account.getLinkedContacts();

										if ( !Utilities.isEmpty( linkedContacts ) )
											mapTask.put( "linkedContacts" , linkedContacts );

										mapTask.put( "linkedAccounts" , linkedAccounts );
									}
							}
						catch ( Exception e )
							{
								String data = null;
								data = "Exception while trying to fetch account for task in welcome call task flow, accountsID : " + accountsID
										+ "\n contactID : " + contactID;
								mLogger.log( java.util.logging.Level.SEVERE , data , e );
								EmailUtil.sendJavaErrorMailWithParams( data , e );
							}

						comments = "Welcome Call : " + accountNumber;

						mapTask.put( "department" , serviceTaskDepartment );
						mapTask.put( "comments" , comments );
						mapTask.put( "notes" , comments );
						mapTask.put( "departmentID" , businessServiceDepartmentID );

						String taskTypeID = TaskTypeService.getTaskTypeIDByType( "SEN42" , "welcome-call" );
						mapTask.put( "type" , taskTypeID );

						if ( !StringUtil.isBlank( brandID ) )
							mapTask.put( "brandID" , brandID );

						taskJson = mapper.writeValueAsString( mapTask );

						mapTask = createTask( staticContentUrl , staticContentUrl , "SEN42" , taskJson , request );

						task = (Task) mapTask.get( "task" );

						if ( task == null )
							throw new NullPointerException( "Task Not Saved in welcome call task flow, json : " + json );

						taskID = task.getID();
						department = task.getDepartment();

						historyBuilder = new StringBuilder();
						historyBuilder.append( "Task Info : " ).append( "<br/><br/>" ).append( "<b style=color:#0084b0;>Summary : </b>" )
								.append( task.getComments() ).append( "<br/>" ).append( "<b style=color:#0084b0;>Description : </b>" )
								.append( task.getNotes() ).append( "<br/>" ).append( "<b style=color:#0084b0;>Type : </b>" ).append( task.getType() )
								.append( "<br/>" ).append( "<b style=color:#0084b0;>URL : </b>" ).append( "<a href=" ).append( staticContentUrl )
								.append( "/crm#task/" ).append( taskID ).append( " target=_blank>" ).append( staticContentUrl ).append( "/crm#task/" )
								.append( taskID ).append( "</a>" ).append( "<br/>" );

						if ( isAccountExist )
							{
								historyBuilder.append( "<b style=color:#0084b0;>Associated Account : </b>" ).append( "<a href=" )
										.append( staticContentUrl ).append( "/crm#account/" ).append( accountsID ).append( " target=_blank>" )
										.append( staticContentUrl ).append( "/crm#account/" ).append( accountsID ).append( "</a>" ).append( "<br/>" );
							}
						historyBuilder.append( "<b style=color:#0084b0;>Account Number : </b>" ).append( accountNumber ).append( "<br/>" )
								.append( "<b style=color:#0084b0;>Task ID : </b>" ).append( taskID ).append( "<br/>" )
								.append( "<b style=color:#0084b0;> Task Type : </b>" ).append( task.getType() );

						historyComments = historyBuilder.toString();

						mapHistory = new HashMap <String , Object>();
						mapHistory.put( "accountID" , "SEN42" );
						mapHistory.put( "ownerName" , "Log" );
						mapHistory.put( "taskID" , taskID );
						mapHistory.put( "historyComments" , historyComments );
						mapHistory.put( "type" , "log" );
						mapHistory.put( "departmentID" , businessServiceDepartmentID );

						listHistoryMap.add( mapHistory );

						Map <String , Object> mapHistoryData = new HashMap <String , Object>();

						mapHistoryData.put( "accountID" , "SEN42" );
						mapHistoryData.put( "history" , listHistoryMap );

						historyJson = mapper.writeValueAsString( mapHistoryData );

						Queue queue = QueueFactory.getQueue( "Activity-Log" );
						queue.add( TaskOptions.Builder.withUrl( "/insertBulkHistoryJob" ).method( Method.POST ).payload( historyJson ) );

						if ( !StringUtil.isBlank( taskID ) )
							UserChannelService.callUpdateChannelsTask_v3( "ticket" , "pending" , taskID , null , "SEN42" , department , null ,
									businessServiceDepartmentID );

						status = (boolean) mapTask.get( "success" );
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "Exception in createTaskForClientFeeBack method , json : " + json
								+ "\n taskID : " + taskID , e );
						EmailUtil.sendJavaErrorMailWithParams( "Exception in createTaskForClientFeeBack method , json : " + json , e );
					}
				finally
					{
						map.put( "status" , status );
						map.put( "task" , task );
					}
				return map;
			}*/

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> getTasksForEntity( String accountID , String json )
			{

				boolean success = false;

				Long linkedDeal = null;

				String entityType = null , linkedEntity = null;

				List <Task> listTask = null;

				Map <String , Object> map = new HashMap <String , Object>() , mapInput = null , mapTask = null;

				ObjectMapper mapper = new ObjectMapper();

				try
					{

						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						entityType = (String) mapInput.get( "entityType" );
						linkedEntity = (String) mapInput.get( "entityID" );

						if ( "linkedDeal".equalsIgnoreCase( entityType ) )
							linkedDeal = new Long( linkedEntity );

						mapTask = TaskDAO.getTasksForEntity( accountID , entityType , linkedEntity , linkedDeal);

						listTask = (List <Task>) mapTask.get( "task" );
						// nextCursor = (String) mapTask.get("nextCursor");

						if ( !Utilities.isEmpty( listTask ) )
							{

								Collections.sort( listTask , new Utilities().new CreatedDateDesc() );

								for ( Task task : listTask )
									{
										Utilities.setTimeZoneAndOffset( task );
									}
							}
						success = true;
						
						map.put("entityID", linkedEntity);
					}
				catch ( Exception e )
					{
						String error = "Params- json : " + json + "\n accountID :  " + accountID;
						mLogger.log( java.util.logging.Level.SEVERE , error , e );
						EmailUtil.sendJavaErrorMailWithParams( error , e );
					}
				finally
					{
						map.put( "task" , listTask );
						// map.put("nextCursor", nextCursor);
						map.put( "success" , success );
					}
				return map;
			}

		public static Map <String , Object> insertBulkTasksForAccounts( String apikey , HttpServletRequest request , String ownerID )
			{

				boolean status = false , isMultiPart = false;
				Map <String , Object> map = new HashMap <String , Object>() , taskMap = new HashMap <String , Object>();
				ObjectMapper mapper = new ObjectMapper();
				List <List <String>> rowDataList = new ArrayList <List <String>>();
				Map <String , Object> mapOfBulkData = new HashMap <String , Object>();
				CSVReader reader = null;

				try
					{

						isMultiPart = ServletFileUpload.isMultipartContent( request );
						if ( !isMultiPart )
							return map;

						ServletFileUpload upload = new ServletFileUpload();
						FileItemIterator itr = upload.getItemIterator( request );

						while ( itr.hasNext() )
							{
								FileItemStream item = itr.next();
								InputStream stream = item.openStream();

								if ( item.isFormField() )
									{
										String name = item.getFieldName();
										Object data = Streams.asString( stream );

										if ( !StringUtil.isBlank( (String) data ) )
											taskMap.put( name , data );

									}
								else
									{
										reader = new CSVReader( new InputStreamReader( stream ) );
										List <String> nextLine = null;
										String[] record = null;
										while ( ( record = reader.readNext() ) != null )
											{
												List <String> cellDataList = new ArrayList <String>();
												nextLine = Arrays.asList( record );

												for ( int i = 0 ; i < nextLine.size() ; i++ )
													cellDataList.add( nextLine.get( i ) );

												rowDataList.add( cellDataList );
											}
									}
							}
						if ( Utilities.isEmpty( rowDataList ) || rowDataList.size() > 300 )
							{
								map.put( "error_message" , "CSV File Should Not be Empty or Should Not Exceed More Than 300 Records." );
								return map;
							}
						List <String> firstRecord = rowDataList.get( 0 );
						if ( !firstRecord.get( 0 ).equalsIgnoreCase( "accountID" ) || !firstRecord.get( 1 ).equalsIgnoreCase( "description" )
								|| !firstRecord.get( 2 ).equalsIgnoreCase( "due date" ) )
							{
								map.put( "error_message" ,
										"File Should Contain Headers in Specific Order,For Example accountID,description,due date, .." );
								return map;
							}

						taskMap.put( "ownerID" , ownerID );
						taskMap.put( "apikey" , apikey );

						mapOfBulkData.put( "taskMap" , taskMap );
						mapOfBulkData.put( "rowDataList" , rowDataList );
						mLogger.log( java.util.logging.Level.INFO , "Create task for account in bulk ->" + mapOfBulkData );

						Queue queue = QueueFactory.getQueue( "Tasks" );
						queue.add( TaskOptions.Builder.withUrl( "/insertBulkTaskJobToQueue" ).method( Method.POST )
								.payload( mapper.writeValueAsString( mapOfBulkData ) ) );

						status = true;

					}
				catch ( Exception e )
					{
						String params = "Params- apikey: "+apikey+" mapOfBulkData: "+mapOfBulkData+" ownerID: "+ownerID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						map.put( "status" , status );
						try
							{
								reader.close();
							}
						catch ( IOException e )
							{
								// TODO Auto-generated catch block
								mLogger.log( java.util.logging.Level.SEVERE , "Exception in Closing the Resource  :- apikey: " + apikey
										+ "rowDataList" + rowDataList , e );
							}
					}
				return map;
			}

		private static Map <String , Object> createCustomFieldForBulkTask( List <Map <String , Object>> listOfCustomField , String utcOffsetString ,
																			Task task , String departmentID ) throws Exception
			{

				Map <String , Object> cfMap = null;

				if ( Utilities.isEmpty( listOfCustomField ) )
					return cfMap;

				cfMap = new HashMap <String , Object>();
				cfMap.put( "entityID" , task.getID() );
				cfMap.put( "departmentID" , departmentID );
				cfMap.put( "customField" , listOfCustomField );
				cfMap.put( "ownerID" , task.getOwnerID() );
				cfMap.put( "utcOffsetString" , utcOffsetString );
				cfMap.put( "entityType" , "task" );

				return cfMap;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> insertBulkTaskJobToQueue( String json )
			{
				boolean status = false , isMailSent = false , sendEmail = false ;
				List <List <String>> rowDataListBulk = null;
				List <List <List <String>>> batches = new ArrayList <List <List <String>>>();
				List <Task> listOfTask = null;
				List <Map <String , Object>> listOfAssociateData = null , listOfCustomFieldData = null , listOfcfMap = null;
				List <String> linkedAccounts = null, listOfTaskIds = new ArrayList<String>();
				List <Map <String , Object>> lListOfHistoryMap = null;
				Map <String , Object> mapOfCustomFieldResp = null;
				Map <String , List <String>> mapOfCustomFieldIDs = null;
				Map <String , Object> map = new HashMap <String , Object>() , inputMap = null , taskMap = null , lMapOfHistoryInfo = null;
				Map <String , Object> mapData = null , mapOfCustomField = null , cfMap = null , taskDetailMap = null , mapOfSearchInfo = null , fieldInfo = null;
				Map <String , Object> lMapOfContactInfo = null;
				ObjectMapper mapper = new ObjectMapper();
				Object fieldInfoObj = null;
				String letterCode = "Pac" , timeZone = null;
				String respJSON = null , departmentID = null , ownerID = null , apikey = null , utcOffsetString = null , value = "" , header = null , userName = null , userEmail = null , appUrl = null , assigneeName = null;
				String type = null , entityType = null , fileName = null , accountID = null , comments = null , dueDate = null , taskID = null;
				String historyInfoAsJson = null , lCMSPostURL = null , lReqParams = null , lRespJson = null;
				String date_pattern = "(0?[1-9]|1[012])/(0?[1-9]|[12][0-9]|3[01])/((19|20)\\d\\d)";
				StringBuilder historyBuilder = null;
				Task task = null;
				final int batchSize = 50;
				int j = 0;

				try
					{
						mLogger.log( java.util.logging.Level.INFO , "insertBulkTaskJobToQueue json: -> " + json );

						inputMap = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						taskMap = (Map <String , Object>) inputMap.get( "taskMap" );
						rowDataListBulk = (List <List <String>>) inputMap.get( "rowDataList" );

						if ( Utilities.isEmpty( rowDataListBulk ) && Utilities.isEmpty( taskMap ) )
							return map;

						departmentID = (String) taskMap.get( "departmentID" );
						ownerID = (String) taskMap.get( "ownerID" );
						apikey = (String) taskMap.get( "apikey" );
						userName = (String) taskMap.get( "userName" );
						userEmail = (String) taskMap.get( "userEmail" );
						assigneeName = (String) taskMap.get( "assigneeName" );
						appUrl = (String) taskMap.get( "appUrl" );
						utcOffsetString = (String) taskMap.get( "utcOffsetString" );
						fieldInfoObj = taskMap.get( "fieldInfo" );
						type = (String) taskMap.get( "type" );
						fileName = (String) taskMap.get( "fileName" );
						entityType = "task+" + type;

						if ( fieldInfoObj instanceof String )
							fieldInfo = mapper.readValue( (String) fieldInfoObj , new TypeReference <Map <String , Object>>()
								{
								} );
						else if ( fieldInfoObj instanceof Map )
							fieldInfo = (Map <String , Object>) fieldInfoObj;

						// get the header row of csv file
						List <String> firstRow = rowDataListBulk.get( 0 );
						rowDataListBulk.remove( 0 );

						while ( j < rowDataListBulk.size() )
							{
								int nextInc = Math.min( rowDataListBulk.size() - j , batchSize );
								List <List <String>> batch = rowDataListBulk.subList( j , j + nextInc );
								j = j + nextInc;
								batches.add( batch );
							}

						for ( List <List <String>> rowDataList : batches )
							{

								listOfTask = new ArrayList <Task>();

								listOfAssociateData = new ArrayList <Map <String , Object>>();
								listOfcfMap = new ArrayList <Map <String , Object>>();
								lListOfHistoryMap = new ArrayList <Map <String , Object>>();
								lMapOfContactInfo = new HashMap <String , Object>();

								for ( List <String> row : rowDataList )
									{

										if ( row.size() < 2 )
											continue;

										accountID = row.get( 0 );
										comments = row.get( 1 );

										if ( row.size() > 2 )
											dueDate = row.get( 2 );

										if ( StringUtil.isBlank( accountID ) || StringUtil.isBlank( comments ) )
											continue;

										if ( !StringUtil.isBlank( dueDate ) && dueDate.matches( date_pattern ) )
											{
												dueDate = new StringBuilder().append( dueDate.trim() ).append( " " ).append( "8:00 AM" ).toString();
												taskMap.put( "dueDate" , dueDate );

											}

										task = new Task();
										listOfCustomFieldData = new ArrayList <Map <String , Object>>();
										mapData = new HashMap <String , Object>();
										linkedAccounts = new ArrayList <String>();
										linkedAccounts.add( accountID );
										taskMap.put( "linkedAccounts" , linkedAccounts );
										taskMap.put( "comments" , comments );
										taskMap.put( "ownerID" , ownerID );

										setTaskObject( apikey , "insert" , taskMap , task );
										timeZone = Utilities.getTimeZone( letterCode );
										task.setTimeZone( timeZone );

										taskID = task.getID();
										mapData.put( "taskID" , taskID );
										mapData.put( "accountID" , accountID );
										listOfAssociateData.add( mapData );

										lMapOfHistoryInfo = new HashMap <String , Object>();
										historyBuilder = new StringBuilder();
										historyBuilder.append( userName )
												.append( " Added a task<br/><br/>Added Task Details<br/><b style='color:#0084b0;'>Summary :</b>" )
												.append( comments ).append( "<br/>" );

										if ( !StringUtil.isBlank( dueDate ) )
											historyBuilder.append( "<b style='color:#0084b0;'>Due Date :</b>" ).append( dueDate ).append( "<br/>" );

										historyBuilder.append( "<b style='color:#0084b0;'>Assignee :</b>" ).append( assigneeName ).append( "<br/>" );
										historyBuilder.append( "<b style='color:#0084b0;'>Added By :</b>" ).append( userName ).append( "<br/>" );
										historyBuilder.append( "<b style='color:#0084b0;'>TaskID :</b>" ).append( taskID ).append( "<br/>" );
										historyBuilder.append( "Custom Fields:</br>" );

										for ( int i = 3 ; i < firstRow.size() ; i++ )
											{
												mapOfCustomField = new HashMap <String , Object>();
												header = firstRow.get( i ).toLowerCase().trim();
												value = null;
												if ( row.size() > i )
													value = row.get( i ).trim();

												if ( StringUtil.isBlank( value ) )
													continue;

												if ( fieldInfo.containsKey( header ) )
													{
														mapOfCustomField.put( "fieldInfoID" , fieldInfo.get( header ) );
													}
												mapOfCustomField.put( "entityType" , entityType );

												switch ( header )
													{
													case "amount due" :
													case "past due" :
														mapOfCustomField.put( "dataType" , "currency" );
														mapOfCustomField.put( "value" , value );
														break;
													case "last attempt on" :
													case "scheduled collection date" :
													case "scheduled block date" :
													case "interim payment date" :
													case "last payment date" :
														if ( value.matches( date_pattern ) )
															{
																mapOfCustomField.put( "dataType" , "date" );
																value = new StringBuilder().append( value ).append( " " ).append( "8:00 AM" )
																		.toString();
																mapOfCustomField.put( "value" , value );
															}
														break;
													default :
														mapOfCustomField.put( "dataType" , "string" );
														mapOfCustomField.put( "value" , value );
														break;
													}

												if ( mapOfCustomField.containsKey( "fieldInfoID" ) && mapOfCustomField.containsKey( "value" ) )
													{
														historyBuilder.append( "</br><b style='color:#0084b0;'>" ).append( header ).append( "</b> " )
																.append( value );
														listOfCustomFieldData.add( mapOfCustomField );
													}

											}
										
										if(task.getDueDate() == null)
											task.setDueDate(getUTCTimeForTimeZonePlusOneHour("US/Pacific"));
										
										listOfTask.add( task );

										if ( !Utilities.isEmpty( listOfCustomFieldData ) )
											{
												cfMap = createCustomFieldForBulkTask( listOfCustomFieldData , utcOffsetString , task , departmentID );
												listOfcfMap.add( cfMap );
											}
										lMapOfHistoryInfo.put( "historyComments" , historyBuilder.toString() );
										lMapOfHistoryInfo.put( "taskID" , taskID );
										lMapOfHistoryInfo.put( "type" , "log" );
										lMapOfHistoryInfo.put( "ownerName" , "Log" );
										lMapOfHistoryInfo.put( "linkedAccounts" , linkedAccounts );
										lMapOfHistoryInfo.put( "departmentID" , departmentID );
										lListOfHistoryMap.add( lMapOfHistoryInfo );
										lMapOfContactInfo.put( "history" , lListOfHistoryMap );
									}
								if ( listOfTask.size() < 1 )
									continue;

								// 1.insert the batch tasks
								listOfTask = (List <Task>) DataStoreUtil.batchWrite( listOfTask );

								// 2.associate the task to account for batch operations
								json = mapper.writeValueAsString( listOfAssociateData );
								respJSON = (String) URLFetchService.associateTaskToAccountInBulk( apikey , json );
								mLogger.log( java.util.logging.Level.INFO ,
										"Associated task to account in bulk task creation operaion response json :-> " + respJSON );

								Map <String , Object> respMap = mapper.readValue( respJSON , new TypeReference <Map <String , Object>>()
									{
									} );

								if ( !Utilities.isEmpty( respMap ) && (Boolean) respMap.get( "status" ) )
									{

										if ( respMap.containsKey( "deassociateListOfAccFrmTask" ) )
											{
												List <String> listOfTaskIDs = (List <String>) respMap.get( "deassociateListOfAccFrmTask" );

												for ( String taskId : listOfTaskIDs )
													{
														for ( Task tsk : listOfTask )
															{
																if ( taskId.equals( tsk.getID() ) )
																	{
																		tsk.setLinkedAccount( null );
//																		tsk.setLastUpdatedDate( new Date() );
																	}
															}
													}

											}

										if ( respMap.containsKey( "listOfBrand" ) )
											{
												List <Map <String , Object>> listOfBrand = (List <Map <String , Object>>) respMap.get( "listOfBrand" );

												for ( Map <String , Object> mapOfBrand : listOfBrand )
													{
														for ( Task tsk : listOfTask )
															{
																if ( mapOfBrand.get( "taskID" ).equals( tsk.getID() ) )
																	{
																		tsk.setProductID( (String) mapOfBrand.get( "productID" ) );
//																		tsk.setLastUpdatedDate( new Date() );
																	}
															}
													}
											}

										listOfTask = (List <Task>) DataStoreUtil.batchWrite( listOfTask );
									}

								// 3.create the custom field for batch tasks
								listOfcfMap.removeAll( Collections.singleton( null ) );
								if ( !Utilities.isEmpty( listOfcfMap ) )
									{
										mapOfCustomFieldResp = CustomFieldService.createCustomFieldForBulkTask( apikey , listOfTask ,
												mapper.writeValueAsString( listOfcfMap ) );
										mapOfCustomFieldIDs = (Map <String , List <String>>) mapOfCustomFieldResp.get( "mapOfcustomFieldID" );
									}
								mLogger.log( java.util.logging.Level.INFO ,
										"Created custom fields for bulk task creation operaion response mapOfCustomFieldResp :-> "
												+ mapOfCustomFieldResp );

								// 4.insert activity log for create task in bulk
								historyInfoAsJson = mapper.writeValueAsString( lMapOfContactInfo );
								mLogger.log( java.util.logging.Level.INFO , "Insert Activity Log for task and customField historyInfoAsJson:-> "
										+ historyInfoAsJson );

								lCMSPostURL = StringConstants.INSERT_BULK_HISTORY_URL;
								lReqParams = "?apikey=".concat( apikey );
								lCMSPostURL = lCMSPostURL.concat( lReqParams );

								lRespJson = (String) URLFetchService.URLFetch( lCMSPostURL , "POST" , "application/json" , historyInfoAsJson );
								mLogger.log( java.util.logging.Level.INFO , "Insert Activity Log for task and customField response:-> " + lRespJson );

								// 5.create search index for task comments and custom field values
								mapOfSearchInfo = new HashMap <String , Object>();
								for ( Task taskObj : listOfTask )
									{
										taskDetailMap = new HashMap <String , Object>();
										taskDetailMap.put( "comments" , taskObj.getComments() );
										taskDetailMap.put( "lastUpdatedDate" , taskObj.getLastUpdatedDate().getTime() );
										taskDetailMap.put( "deleted" , false );
										taskDetailMap.put( "departmentID" , taskObj.getDepartmentID() );
										
										listOfTaskIds.add(taskObj.getID());

										if ( !Utilities.isEmpty( mapOfCustomFieldIDs ) )
											taskDetailMap.put( "linkedCustomFields" , mapOfCustomFieldIDs.get( taskObj.getID() ) );
										mapOfSearchInfo.put( taskObj.getID() , taskDetailMap );
									}
								Map <String , Object> searchInfoResp = CustomFieldService.createSearchIndexForCustomFieldsAndTaskInBulk( apikey ,
										mapper.writeValueAsString( mapOfSearchInfo ) );
								mLogger.log( java.util.logging.Level.INFO ,
										"Created search index and GAE document for task and customfields response :-> " + searchInfoResp );

								sendEmail = true;
							}
						if ( !sendEmail )
							return map;

						// 6.send an email to the owner of the tasks
						Map <String , Object> mapOfTaskInfo = new HashMap <String , Object>();
						mapOfTaskInfo.put( "insertTaskToAccountInBulkMail" , true );
						mapOfTaskInfo.put( "userEmail" , userEmail );
						mapOfTaskInfo.put( "userName" , userName );
						mapOfTaskInfo.put( "appUrl" , appUrl );
						mapOfTaskInfo.put( "fileName" , fileName );
						isMailSent = EmailService.sendMailToTaskOwner( mapOfTaskInfo );
						mLogger.log( java.util.logging.Level.INFO , "Sent an Email to Task Owner :-> " + isMailSent );

						status = true;
						
						addToMemcacheAndCheckSubscription(listOfTaskIds, null);
						processWebhooks(listOfTaskIds);
					}
				catch ( Exception e )
					{
						
						String params = "Params- apikey: "+apikey+" inputMap: "+inputMap;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );

					}
				finally
					{
						map.put( "status" , status );
					}
				return map;
			}

		public static Map <String , Object> processMergeTask( String json )
			{

				boolean success = false;

				String oldTaskID = null , accountID = null , cmsURL = null , newTaskID = null;

				List <String> linkedDocuments = null , listDocuments = null;

				Map <String , Object> map = new HashMap <>() , mapInput = null;

				ObjectMapper mapper = new ObjectMapper();
				Task task = null , newTask = null;
				StringBuilder urlBuilder = null;
				List<String> listOfTaskIds = new ArrayList<String>();

				try
					{

						mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
							{
							} );

						oldTaskID = (String) mapInput.get( "oldTaskID" );
						newTaskID = (String) mapInput.get( "newTaskID" );
						accountID = (String) mapInput.get( "accountID" );

						urlBuilder = new StringBuilder();
						urlBuilder.append( StringConstants.MERGE_TASK_JOB_URL ).append( "?apikey=" ).append( accountID );
						cmsURL = urlBuilder.toString();

						task = DataStoreUtil.getObjectByID( Task.class , oldTaskID );

						linkedDocuments = task.getLinkedDocuments();

						if ( !Utilities.isEmpty( linkedDocuments ) )
							{
								mapInput.put( "documents" , linkedDocuments );
								json = mapper.writeValueAsString( mapInput );
							}

						URLFetchService.URLFetch_v2( cmsURL , "POST" , "application/json" , json );

						// mLogger.log(java.util.logging.Level.INFO, "mapOfRespInfo : " +mapOfRespInfo);

						task.setStatus( "deleted" );
						task.setLinkedDocuments( null );
						task = DataStoreUtil.write( task );
						
						listOfTaskIds.add(task.getID());

						if ( !Utilities.isEmpty( linkedDocuments ) )
							{

								newTask = DataStoreUtil.getObjectByID( Task.class , newTaskID );

								listDocuments = Utilities.createNewIfNull(newTask.getLinkedDocuments());

								listDocuments.addAll( linkedDocuments );
								newTask.setLinkedDocuments( listDocuments );

								DataStoreUtil.write( newTask );
								listOfTaskIds.add(newTask.getID());
							}

						success = true;
						addToMemcacheAndCheckSubscription(listOfTaskIds, null);
					}
				catch ( Exception e )
					{
						String errMsg = "Exception in processMergeTask, json : " + json;
						mLogger.log( java.util.logging.Level.SEVERE , errMsg , e );
						EmailUtil.sendJavaErrorMailWithParams( errMsg , e );
					}
				finally
					{
						map.put( "success" , success );
						map.put( "task" , task );
					}
				return map;
			}

		@SuppressWarnings( "unchecked" )
		public static Task updateTaskAndTriggerARForInboundMail( Task task , boolean pushActiveResponseNotification )
			{

				TaskType taskType = null;
				ObjectMapper mapper = new ObjectMapper();
				boolean resetAssigneeID = true;
				Map <String , Object> eventMap = null , actionMap = null;
				String type = null , apiKey = null , department = null , taskID = null , previousStatus = null , eventsJSON = null;

				try
					{

						taskID = task.getID();
						previousStatus = task.getStatus();

						apiKey = task.getAccountID();
						department = task.getDepartment();

						type = task.getType();
						type = Utilities.correctToNull( type );

						if ( !StringUtil.isBlank( type ) )
							{
								type = type.trim();
								taskType = DataStoreUtil.getObjectByID( TaskType.class , type );
								eventsJSON = taskType.getEvents();
							}

						if ( !StringUtil.isBlank( eventsJSON ) )
							eventMap = mapper.readValue( eventsJSON , new TypeReference <Map <String , Object>>()
								{
								} );

						if ( !Utilities.isEmpty( eventMap ) && !StringUtil.isBlank( department ) )
							actionMap = (Map <String , Object>) eventMap.get( department );

						if ( !Utilities.isEmpty( actionMap ) && actionMap.containsKey( "resetAssigneeOnInboundEmail" ) )
							resetAssigneeID = (Boolean) actionMap.get( "resetAssigneeOnInboundEmail" );

						if ( resetAssigneeID )
							task.setAssigneeID( null );

						if ( !StringUtil.isBlank( task.getAssigneeID() ) )
							task.setStatus( "unread" );
						else
							task.setStatus( "pending" );

						task.setDueDate(getUTCTimeForTimeZonePlusOneHour("US/Pacific"));

						task = DataStoreUtil.write( task );

						/* Push active response notification to queue only when updating task happens in the inbound-email flow. 
						 * For new tickets, create task api takes care of queueing */
						NotificationSubscription pushNotificationParameter = new NotificationSubscription("task",taskID,task,pushActiveResponseNotification);
						
						if ( pushActiveResponseNotification )
							SettingsService.pushActiveResponseNotificationToQueue( pushNotificationParameter, "inbound-email" );
					}
				catch ( Exception e )
					{
						String errMsg = "Params- taskID : " + taskID + " taskType: " + type + " previousStatus: " + previousStatus + " department: "
								+ department + " apiKey: " + apiKey;
						mLogger.log( java.util.logging.Level.SEVERE , errMsg , e );
						EmailUtil.sendJavaErrorMailWithParams( errMsg , e );
					}

				return task;
			}

		@SuppressWarnings( "unchecked" )
		public static Map <String , Object> getAllTaskForAccountByDepartment_v3( String accountID , int limit , String cursor , String department ,
																					String departmentID)
			{

				boolean success = false;

				String nextCursor = null;

				Map <String , Object> mapOfData = new HashMap <String , Object>() , result = new HashMap <String , Object>() , mapOfTask = new HashMap <String , Object>();
				List <Task> listOfTask = new ArrayList <Task>();

				try
					{
						departmentID = Utilities.correctToNull( departmentID );

						mapOfData = TaskDAO.readAllTaskForAccountByDepartment_v1( accountID , "pending" , limit , cursor , department , departmentID );

						nextCursor = (String) mapOfData.get( "cursor" );
						listOfTask = (List <Task>) mapOfData.get( "tasks" );

						// for( Task task : listOfAccountTasks ) {
						// setTimeZoneAndOffset(task);
						// }

						if ( !Utilities.isEmpty( listOfTask ) )
							{
								for ( Task task : listOfTask )
									mapOfTask.put( task.getID() , task );
							}

						success = true;
					}
				catch ( Exception e )
					{
						
						String params = "Params- accountId :" + accountID+ " cursor : " + cursor+" limit: "+limit
										+" department: "+department+" departmentID: "+departmentID;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
				finally
					{
						result.put( "cursor" , nextCursor );
						result.put( "tasks" , mapOfTask );
						result.put( "groupID" , department );
						//result.put( "groupCount" , groupCount );
						result.put( "success" , success );
					}
				return result;
			}

		@SuppressWarnings(
			{ "unchecked" , "static-access" } )
		public static Map <String , Object> getAllAssigneeTasks_v2( String accountId , String json )
			{

				boolean status = false;

				String fromDateStr, toDateStr, assigneeID, taskStatus, departmentID;

				Map <String , Object> mapOfTaskInfo = null , mapOfInput = null, mapOfTask = null, responseMap = new HashMap <String , Object>();

				Date fromDate = null , toDate = null;
				Calendar cFromDate = Calendar.getInstance(), cToDate = Calendar.getInstance();
				SimpleDateFormat sdf = new SimpleDateFormat( "MM/dd/yyyy" );
				ObjectMapper mapper = new ObjectMapper();

				try
					{
						mapOfInput = mapper.readValue( json , new TypeReference <Map <String , Object>>(){} );

						assigneeID = (String) mapOfInput.get( "assigneeID" );
						taskStatus = (String) mapOfInput.get( "taskStatus" );

						departmentID = Utilities.getStringValueFromMap( "departmentID" , mapOfInput );
						fromDateStr = Utilities.getStringValueFromMap( "fromdate" , mapOfInput );
						toDateStr = Utilities.getStringValueFromMap( "todate" , mapOfInput );

						if ( !StringUtil.isBlank( fromDateStr ) )
							{

								fromDate = sdf.parse( fromDateStr );
								cFromDate.setTime( fromDate );
								cFromDate.set( cFromDate.get( cFromDate.YEAR ) , cFromDate.get( cFromDate.MONTH ) , cFromDate.get( cFromDate.DATE ) ,
										00 , 00 , 00 );
								fromDate = cFromDate.getTime();
							}

						if ( !StringUtil.isBlank( toDateStr ) )
							{

								toDate = sdf.parse( toDateStr );
								cToDate.setTime( toDate );
								cToDate.set( cToDate.get( cToDate.YEAR ) , cToDate.get( cToDate.MONTH ) , cToDate.get( cToDate.DATE ) , 23 , 59 , 59 );
								toDate = cToDate.getTime();
							}

						mapOfTaskInfo = TaskDAO.getAllAssigneeTasks( accountId , assigneeID , fromDate , toDate , taskStatus , departmentID );
						mapOfTask = (Map <String , Object>) mapOfTaskInfo.get( "tasks" );

						if ( mapOfTask == null )
								throw new NullPointerException( "Assignee Tasks not fetched" );

						status = true;
					}
				catch ( Exception e )
					{
						mLogger.log( java.util.logging.Level.SEVERE , "accountId :" + accountId + "\n json :  " + json , e );
						EmailUtil.sendJavaErrorMailWithParams( "accountId :" + accountId + "\n json :  " + json , e );
					}
				finally
					{
						responseMap.put( "tasks" , mapOfTask );
						responseMap.put( "status" , status );
					}
				return responseMap;
			}

		private static NotificationSubscription checkTaskForPushingActiveResponseNotification( Task task, Long dealID, String userID)
			{

				boolean pushNotification = false;
				NotificationSubscription pushNotificationParameter = null;
				String assigneeID = task.getAssigneeID(), entity = "", entityID = task.getID();
				
				//routing task
				if (!salesEscalationUserID.equals(assigneeID) && (( StringUtil.isBlank( assigneeID ) && StringUtil.isBlank( userID ) )
						|| ( !StringUtil.isBlank( userID ) && !userID.equalsIgnoreCase( assigneeID ) )
						|| ( !StringUtil.isBlank( assigneeID ) && !assigneeID.equalsIgnoreCase( userID ) ) )){
					entity = "task";
					pushNotification = true;
				}//routing deal
				else if(salesEscalationUserID.equals(assigneeID) && dealID != null && dealID != 0L){
					entityID =  String.valueOf(dealID);
					entity = "deal";
					pushNotification = true;
				}
					
				pushNotificationParameter = new NotificationSubscription(entity,entityID, task,pushNotification);
				
				return pushNotificationParameter;
			}

		private static void deleteSearchIndexForTask( String accountID , Task task ) throws Exception
			{

				List <Task> tasks = new ArrayList <Task>();
				tasks.add( task );
				deleteSearchIndexForTask( accountID, tasks );

			}

		private static void deleteSearchIndexForTask( String accountID , List <Task> listOfTask )
			{

				List <String> listOfTaskID = new ArrayList <String>(), 
								basicTypes = Arrays.asList("call","email","to-do");
				String taskType;

				try
					{

						for ( Task task : listOfTask )
							{

								taskType = TaskTypeService.getTaskTypeByTypeID( task.getType() );
								taskType = taskType.toLowerCase();
								
								if(basicTypes.indexOf( taskType ) != -1)
									listOfTaskID.add( task.getID() );
							}

						if ( Utilities.isEmpty( listOfTaskID ) )
							return;

						SearchService.deleteSearchIndex( accountID , listOfTaskID );
						SearchService.deleteSearchDocumentsFromIndex( accountID , listOfTaskID );
					}
				catch ( Exception e )
					{
						String params= "accountID :" + accountID + "\n listOfTask :  " + listOfTask;
						mLogger.log( java.util.logging.Level.SEVERE , params , e );
						EmailUtil.sendJavaErrorMailWithParams( params , e );
					}
			}
		
		@SuppressWarnings( "unchecked" )
		private static Map<String, Object> createHistoryMapsForServiceTasks(Map<String, Object> taskMap, Task task) {
			
			List<Map<String, Object>> history = new ArrayList<Map<String, Object>>(), tempList;
			String logEntry, inboundEmailEntry="", staticContentUrl, taskID=null, agentName="", accountID=null, historyType ="note";
			Map<String, Object> mapHistory, historyKeys;
			
			try {
				
				if(!taskMap.containsKey( "generateHistory" ) || !Boolean.valueOf((String.valueOf( taskMap.get( "generateHistory" )))) )
					return taskMap;
				
				staticContentUrl = StringUtilSales.getStringBasedOnMode( "securedStaticContent.url" );
				taskID = task.getID();
				accountID = task.getAccountID();
				
				logEntry = "Task Info: <br/><br/><b style=color:#0084b0;>Summary : </b>"+task.getComments()+"<br/>";
				
				if(!StringUtil.isBlank(task.getNotes())) {
					
					inboundEmailEntry = "<b style=color:#0084b0;>Description : </b>"+task.getNotes();
					logEntry += "<b style=color:#0084b0;>Description : </b>"+task.getNotes()+"<br/>";
				}

				if(taskMap.containsKey( "typeName" ))
					logEntry +="<b style=color:#0084b0;>Type : </b>"+ taskMap.get("typeName") +"<br/>";
				else
					logEntry +="<b style=color:#0084b0;>Type : </b>"+ TaskTypeService.getTaskTypeByTypeID( task.getType() )+"<br/>";
				
				logEntry += "<b style=color:#0084b0;>URL : </b><a href="+staticContentUrl+"/crm#task/"+taskID+" target=_blank>"
							+staticContentUrl+"/crm#task/"+taskID+"</a>";
				
				if(!StringUtil.isBlank( task.getLinkedAccount() )){
					logEntry+="<br/><b style=color:#0084b0;>Associated Account : </b><a href="+staticContentUrl+"/crm#account/"+task.getLinkedAccount()
							+" target=_blank>"+staticContentUrl+"/crm#account/"+task.getLinkedAccount()+"</a>";
				}
				if(!Utilities.isNull( task.getLinkedDeal() )){
					logEntry+="<br/><b style=color:#0084b0;>Associated Deal : </b><a href="+staticContentUrl+"/crm#deal/"+task.getLinkedDeal()
							+" target=_blank>"+staticContentUrl+"/crm#deal/"+task.getLinkedDeal()+"</a>";
				}
				
				logEntry+="<br/><b style=color:#0084b0;>Task ID : </b>"+taskID;

				if(taskMap.containsKey("historyProperties")){
					
					historyKeys = (Map<String, Object>) taskMap.get("historyProperties");
				
					if(historyKeys.containsKey("name"))
						inboundEmailEntry+="<br/><b style=color:#0084b0;>Name : </b>"+historyKeys.get("name");
					if(historyKeys.containsKey("phone"))
						inboundEmailEntry+="<br/><b style=color:#0084b0;>Phone : </b>"+historyKeys.get("phone");
					if(historyKeys.containsKey("email"))
						inboundEmailEntry+="<br/><b style=color:#0084b0;>Email : </b>"+historyKeys.get("email");
					
					if(historyKeys.containsKey( "accountNumber" )){
						logEntry+="<br/><b style=color:#0084b0;>Account Number : </b>"+historyKeys.get("accountNumber");
						inboundEmailEntry+="<br/><b style=color:#0084b0;>Account Number : </b>"+historyKeys.get("accountNumber");
					}
					
					agentName = (Utilities.isNull(historyKeys.get("agentLogin")) || StringUtil.isBlank((String)historyKeys.get("agentLogin")))?
										"":(String)historyKeys.get("agentLogin");
					
					if(historyKeys.containsKey("submittedBy")){
						//inboundEmailEntry+="<br/><b style=color:#0084b0;>Submitted By : </b>"+historyKeys.get("submittedBy");
						if(StringUtil.isBlank( agentName ))
							agentName = (String) historyKeys.get("submittedBy");
					}

					if(historyKeys.containsKey("message"))
						inboundEmailEntry+="<br/><b style=color:#0084b0;>Message : </b>"+historyKeys.get("message");
					
					if(historyKeys.containsKey( "agentLogin" ))
						logEntry+="<br/><b style=color:#0084b0;>Agent Login : </b>"+historyKeys.get("agentLogin");
					
					if(historyKeys.containsKey( "copyPasteMap" )){
						
						inboundEmailEntry+="<br/>";
						
						Map<String, Object> copyPasteMap = (Map<String, Object>) historyKeys.get( "copyPasteMap" );
						Set<String> keys = copyPasteMap.keySet();
						
						for(String key : keys) {
							inboundEmailEntry+="<br/><b style=color:#0084b0;>"+key+" : </b>"+copyPasteMap.get(key);
						}
					}
				}

				if(!StringUtil.isBlank( inboundEmailEntry )) {
					
					inboundEmailEntry ="Details : <br/><br/>"+inboundEmailEntry;
					
					if(taskMap.containsKey( "isInboundEmail" ) && Boolean.valueOf((String.valueOf( taskMap.get("isInboundEmail")))))
						historyType = "inboundemail";
					
					mapHistory = new HashMap <String , Object>();
					mapHistory.put( "accountID" , accountID );
					mapHistory.put( "ownerName" , agentName );
					mapHistory.put( "taskID" , taskID );
					mapHistory.put( "type" , historyType );
					mapHistory.put( "historyComments" , inboundEmailEntry );
					mapHistory.put( "departmentID" , task.getDepartmentID() );
					history.add(mapHistory);
				}
				
				mapHistory = new HashMap <String , Object>();
				mapHistory.put( "accountID" , accountID );
				mapHistory.put( "ownerName" , "Log" );
				mapHistory.put( "taskID" , taskID );
				mapHistory.put( "type" , "log" );
				mapHistory.put( "historyComments" , logEntry );
				mapHistory.put( "departmentID" , task.getDepartmentID() );
				history.add(mapHistory);
				
				if(taskMap.containsKey( "history" )){
					tempList = (List<Map<String, Object>>) taskMap.get( "history" );
					history.addAll( tempList );
				}
				
				taskMap.put("history", history);
						
				/*mapHistoryData.put( "accountID" , task.getAccountID() );
				mapHistoryData.put( "history" , history );

				Queue queue = QueueFactory.getQueue( "Activity-Log" );
				queue.add( TaskOptions.Builder.withUrl( "/insertBulkHistoryJob" ).method( Method.POST ).payload( mapper.writeValueAsString( mapHistoryData ) ) );*/
				
			} catch (Exception e) {
				
				String params= "inputMap :" + taskMap + "\n task :  " + task+" taskID: "+taskID+" accountID: "+accountID;
				mLogger.log( java.util.logging.Level.SEVERE , params , e );
				EmailUtil.sendJavaErrorMailWithParams( params , e );
			}
			return taskMap;
		}
		
		@SuppressWarnings( "unchecked" )
		private static Map<String, Object> searchAndLinkEntitiesToTask( Map<String, Object> taskMap, String accountID, boolean sendRawData) {
			
			ObjectMapper mapper = new ObjectMapper();
			StringBuilder url = new StringBuilder();
			Map<String, Object> mapOfRespInfo=null, searchMap = null;
			List<Contact> contacts;
			List<Account> accounts;
			List<String> linkedAccounts, linkedContacts;
			String responseJSON, accountsID, accountBrand=null, contactBrand=null;
			JsonNode rootNode, successNode, entityListNode;
			boolean isServiceDeptMessage = false, disregardContactBrandID = false, isSBFeedback = false;

			try {
				
				if(taskMap.containsKey( "searchRelationships" ))
					searchMap = (Map<String, Object>) taskMap.get( "searchRelationships" );
				if(Utilities.isEmpty( searchMap ))
					return taskMap;
				
				if(taskMap.containsKey( "isSBFeedback" ))
					isSBFeedback = Boolean.valueOf((String.valueOf( taskMap.get( "isSBFeedback" ))));
				
				linkedAccounts = Utilities.createNewIfNull( (List<String>)taskMap.get("linkedAccounts") );
				
				if(searchMap.containsKey("accountsID") && !isSBFeedback){
					
					accountsID = Utilities.correctToNull((String) searchMap.get("accountsID"));
					if(accountsID == null)
						throw new NullPointerException("NULL accountsID");
					
					url = new StringBuilder();
					url.append( StringConstants.ACCOUNTS_API_URL ).append( "/" ).append( accountsID )
							.append( StringConstants.GET_ACCOUNT_URL_PATH ).append( "?apikey="+accountID );

					mapOfRespInfo = URLFetchService.URLFetch_v2( url.toString() , "GET" , "application/json" , "" );
					String respJSON = (String) mapOfRespInfo.get( "response" );
					rootNode = mapper.readValue( respJSON , JsonNode.class );

					JsonNode accountNode = rootNode.path( "account" );
					
					if(!accountNode.isMissingNode()) {
					
						Account account = mapper.treeToValue( accountNode , Account.class );
	
						linkedAccounts.add( account.getID() );
						accountBrand = account.getBrandID();
						taskMap.put( "linkedAccounts" , linkedAccounts );
						
						if(sendRawData){
							accounts = new ArrayList<Account>();
							accounts.add(account);
							taskMap.put( "accounts" , accounts );
						}
					}
					else
						mLogger.log( java.util.logging.Level.WARNING , "Response from CMS for accountsID search: "+respJSON );
				}
				
				//key "name" is not taken into consideration while searching
				if(!searchMap.containsKey( "accountNumber" ) && !searchMap.containsKey( "phone" ) && !searchMap.containsKey( "email" ) && !isSBFeedback){

					if(!StringUtil.isBlank(accountBrand) && StringUtil.isBlank( (String)taskMap.get("brandID")) && StringUtil.isBlank( (String)taskMap.get("productID")))
						taskMap.put("brandID",accountBrand);
					
					return taskMap;
				}
				
				if(searchMap.containsKey( "accountNumber" )){
					String acno = (String) searchMap.get("accountNumber");
					searchMap.put("accountNumber", acno.replaceAll("[^0-9]", ""));
				}
				
				if(!taskMap.containsKey( "departmentID" ))
					throw new Exception("departmentID not sent in the map.");

				searchMap.put("departmentID", taskMap.get( "departmentID" ));

				if(taskMap.containsKey("isServiceDeptMessage"))
					isServiceDeptMessage = Boolean.valueOf((String.valueOf( taskMap.get( "isServiceDeptMessage" ))));
				
				searchMap.put("isServiceDeptMessage", isServiceDeptMessage);
				searchMap.put("isSBFeedback", isSBFeedback);

				url = new StringBuilder();
				url.append( StringConstants.SEARCH_ENTITIES_FOR_TASK_CREATION_URL ).append( "?apikey="+accountID );
				
				mapOfRespInfo = URLFetchService.URLFetch_v2( url.toString() , "POST" , "application/json" , mapper.writeValueAsString( searchMap ) );
				responseJSON = (String) mapOfRespInfo.get("response");

				rootNode = mapper.readValue( responseJSON , JsonNode.class );
				successNode = rootNode.path( "success" );
				
				if(successNode.isMissingNode() || !successNode.booleanValue())
					throw new Exception("Unable to search and get entities from backend.");

				mapper.configure( DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES , false );
				
				entityListNode = rootNode.path( "accounts" );
				accounts = mapper.convertValue( entityListNode , new TypeReference <List <Account>>(){});

				if ( !Utilities.isEmpty( accounts )){

					linkedAccounts.add(accounts.get( 0 ).getID());
					taskMap.put( "linkedAccounts" , linkedAccounts );
					
					accountBrand = accounts.get( 0 ).getBrandID();
					
					if(sendRawData)
						taskMap.put( "accounts" , accounts );
				}
					
				entityListNode = rootNode.path( "contacts" );
				contacts = mapper.convertValue( entityListNode , new TypeReference <List <Contact>>(){});
				
				if ( !Utilities.isEmpty( contacts )){
					
					linkedContacts = Utilities.createNewIfNull( (List<String>)taskMap.get("linkedContacts") );

					linkedContacts.add(contacts.get( 0 ).getID());
					taskMap.put( "linkedContacts" , linkedContacts );
					
					if(searchMap.containsKey("disregardContactBrandID"))
						disregardContactBrandID = Boolean.valueOf((String.valueOf( searchMap.get("disregardContactBrandID"))));
					
					if(!disregardContactBrandID)
						contactBrand = contacts.get( 0 ).getBrandID();
					
					if(sendRawData)
						taskMap.put( "contacts" , contacts );
				}
				
				if(StringUtil.isBlank( (String)taskMap.get("brandID")) && StringUtil.isBlank( (String)taskMap.get("productID"))){
					
					if(!StringUtil.isBlank(accountBrand))
						taskMap.put("brandID", accountBrand);
					else if(!StringUtil.isBlank(contactBrand))
						taskMap.put("brandID", contactBrand);
				}

			}
			catch ( Exception e ) {
				String params= "searchMap :" + searchMap +" accountID : "+accountID+" mapOfRespInfo: "+mapOfRespInfo;
				mLogger.log( java.util.logging.Level.SEVERE , params , e );
				EmailUtil.sendJavaErrorMailWithParams( params , e );
			}
			return taskMap;
		}
		
		@SuppressWarnings("unchecked")
		public static Map<String, Object> updateTimeZoneOfLinkedTasks(Map<String, Object> mapOfSessionObj, String json ) {
			
			boolean success = false;
			List <Task> listOfTask = null, persistedTasks = null;
			List<String> listOfTaskID = new ArrayList<String>();
			String timeZone = null, accountID = null, timeZoneID = null;
			Map <String , Object> map = new HashMap <String , Object>() , mapInput = null;
			ObjectMapper mapper = new ObjectMapper();
			long UTCOffset = 0;

			try
				{

					mapInput = mapper.readValue( json , new TypeReference <Map <String , Object>>()
						{
						} );
					
					accountID = (String) mapOfSessionObj.get("AccountPIN");

					listOfTaskID = (ArrayList<String>) mapInput.get( "linkedTasks" );
					timeZone = (String) mapInput.get( "timeZone" );
					
					timeZoneID = Utilities.getTimeZoneId(timeZone);
					UTCOffset = Utilities.getLocalTimeOffset(timeZone);
	    	    	
	    	    	if( !Utilities.isEmpty(listOfTaskID) )   	    	
	    	    		listOfTask = TaskDAO.getTasksByTaskIDS(listOfTaskID);
	    	    	
	    	    	for(Task task : listOfTask) {
	    	    		task.setTimeZone(timeZone);
	    	    		task.setTimeZoneID(timeZoneID);
	    	    		task.setUTCOffset(UTCOffset);
	    	    	}

	    	    	if ( !listOfTask.isEmpty() )
	    	    		persistedTasks = (List <Task>) DataStoreUtil.batchWrite( listOfTask );
					
					success = true;
				}
				catch ( Exception e )
				{
					String error = "updateTimeZoneOfLinkedTasks: Params- json : " + json + "\n timeZone :  " + timeZone + "\n accountID :  " + accountID;
					mLogger.log( java.util.logging.Level.SEVERE , error , e );
					EmailUtil.sendJavaErrorMailWithParams( error , e );
				}
				finally
				{
					map.put( "tasks" , persistedTasks );
					map.put( "success" , success );
				}
			return map;
			
		}
		
	public static boolean checkAndEnablePlainTaskForAnUserBasedOnInboxType_v1(StringBuilder errorInfo, String accountID, String contactID, 
																												String defaultDepartmentID, String defaultGroupID) {
		
		boolean success = false;
		
		try {
			
			List <InboxConfiguration> listOfInboxConfigurationFromDB = DataStoreUtil.getListOfObjectByFilter( InboxConfiguration.class ,
					"accountID == '" + accountID + "' && enabled == true && deleted == false && departmentID == '" + defaultDepartmentID + "' && groupID == '" +defaultGroupID + "'");
			
			if(Utilities.isEmpty(listOfInboxConfigurationFromDB))
				return false;
			
			InboxConfiguration  inboxConfigurationForGroupUnderDepartment = listOfInboxConfigurationFromDB.get(0);
			
			String inboxType = inboxConfigurationForGroupUnderDepartment.getInboxTypeID();
			if(!"aedfd8d1-31ab-4ccf-b6dd-ec3d2926eeb1".equals(inboxType)) {
				return false;
			}
			
			try {  				
				TaskDAO.checkIfPlainTask(contactID);
				return true;
			} catch(EntityNotFoundException notFound) {
				Entity entity = new Entity( "PlainTask" , contactID );
				entity.setProperty( "enabled" , true );
				entity.setProperty( "workshop" , false );
				DataStoreUtil.put(entity);
			}
			
			success = true;
		} catch(Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "checkAndEnablePlainTaskForAnUserBasedOnInboxType_v1 - Error "+ errorInfo, e);
			EmailUtil.sendExceptionMail(errorInfo, e);
		}		
		return success;
	}
	
	@SuppressWarnings("unchecked")
	public static boolean checkIfAnUserHasTasksForAStatusType_v1(StringBuilder errorInfo, String accountID, 
											String contactID, String status) throws Exception {
		
		final int limit = 1;
		
		if(StringUtil.isBlank(accountID) || StringUtil.isBlank(contactID) || StringUtil.isBlank(status))
			throw new NullPointerException();
		
		List <Map <String , Object>> listOfFilterMap = new ArrayList <Map <String , Object>>();
		DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "accountID" , "EQUAL" , accountID );
		DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "assigneeID" , "EQUAL" , contactID );
		DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "status" , "EQUAL" , status );
		
		Map <String , Object> response = DataStoreUtil.getEntityKeysUsingQueryCursor( "Task" , "NAME", limit , limit , null ,
				listOfFilterMap , null );		

		List <Object> listOfKey = (List <Object>) response.get( "entityID" );
		
		if(Utilities.isEmpty(listOfKey))
			return false;
		else 
			return true;		
	}
	
	public static Date getUTCTimeForTimeZonePlusOneHour(String timeZone) throws ParseException {
		
		int coeff = 1000 * 60 * 30;
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss");
		SimpleDateFormat dateFormatLocal = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss");
		
		dateFormat.setTimeZone(TimeZone.getTimeZone(timeZone));
		Date date = dateFormatLocal.parse( dateFormat.format(new Date()));
		date = dateFormatLocal.parse( dateFormatLocal.format(Math.ceil((double)date.getTime() / coeff) * coeff));
		
		return DateUtils.addHours(date, 1);
	}
	
	public static String getLocalTimeForUTC(Date date, String timeZone) throws ParseException {

		SimpleDateFormat dateFormatLocal = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss z");
		dateFormatLocal.setTimeZone(TimeZone.getTimeZone(timeZone));
		return dateFormatLocal.format(date);
	}
	
	public static void taskOverDueAlertsCron() {

		List<NotificationSubscription> notificationSubscriptionsList = new ArrayList<NotificationSubscription>();
		String groupID = null, cacheKey = null;
		Map<String, List<NotificationSubscription>> groupNotificationSubscriptions = new HashMap<String, List<NotificationSubscription>>();
		Map<String, Object> cacheData = new HashMap<String, Object>();
		
		try {
			
			notificationSubscriptionsList = SettingsService.getNotificationSubscriptionsByNotificationID(StringConstants.TASK_OVERDUE_NOTIFICATIONID);
			
			if(Utilities.isEmpty(notificationSubscriptionsList))
				return;
				
			mLogger.log(java.util.logging.Level.INFO, "notificationSubscriptionsList Size: " + notificationSubscriptionsList.size());
				
			for(NotificationSubscription subscription : notificationSubscriptionsList) {
				groupID = subscription.getGroupID();
					
				if(!groupNotificationSubscriptions.containsKey(groupID))
					groupNotificationSubscriptions.put(groupID, new ArrayList<NotificationSubscription>());
					
				groupNotificationSubscriptions.get(groupID).add(subscription);
			}
				
			Iterator<Entry<String, List<NotificationSubscription>>> it = groupNotificationSubscriptions.entrySet().iterator();
			while (it.hasNext()) {
			    	
			    Map.Entry<String, List<NotificationSubscription>> pair = (Map.Entry<String, List<NotificationSubscription>>)it.next();
			    notificationSubscriptionsList = pair.getValue();
			    	
			    cacheKey = "TaskOverDueCron_" + UUID.randomUUID().toString();
			    cacheData.put( cacheKey , notificationSubscriptionsList );
				CacheService.setCacheDataInstantaneously( cacheData );
			        
			    Queue queue = QueueFactory.getQueue( "TaskOverDueAlerts" );
				queue.add( TaskOptions.Builder.withUrl( "/taskOverDueAlertsCronJob" ).method( Method.POST ).method( Method.POST ).param("cacheKey", cacheKey));
			}
		}
		catch(Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "taskOverDueAlertsCron : ", e);
			EmailUtil.sendExceptionMail(new StringBuilder(), e);
		}
	}
	
	@SuppressWarnings("unchecked")
	public static void taskOverDueAlertsCronJob(String cacheKey) {

		Map<String , Object> cacheData = new HashMap<String, Object>(), mapOfTimeZoneInfo = null;
		Map<String, Map<String, Object>> responseMap = null;
		Map<Long, List<NotificationSubscription>> taskQueueNotificationList = new HashMap<Long, List<NotificationSubscription>>();
		String contactID = null, timeZone = null, notificationTime = null, key = null;
		StringBuilder errorInfo = new StringBuilder();
		List<Reminder> reminderConfigList = null;
		List<NotificationSubscription> notificationSubscriptionsList = null, taskQueueSubscriptionList = null;
		Date currentDate = new Date(), currentLocalTimeOfTimeZone = null, notificationTimeOfTimeZone = null;
		int offset = 0;
		Long timeDifference = 0L, countDownMilliseconds = 0L;
		
		try {

			notificationSubscriptionsList = (List<NotificationSubscription>) CacheService.getObjectFromCache(cacheKey);
			
			if(Utilities.isEmpty(notificationSubscriptionsList))
				return;
			
			mLogger.log(java.util.logging.Level.INFO, " notificationSubscriptionsList Size: " + notificationSubscriptionsList.size());
        	
        	for(NotificationSubscription subscription : notificationSubscriptionsList) {
        		
        		contactID = subscription.getContactID();
        		
        		responseMap = getReqUsers(new ArrayList<String>(Arrays.asList(contactID)));
        		timeZone = (String) responseMap.get(contactID).get("timeZone");
        		
        		reminderConfigList = subscription.getListOfReminders();
        		
        		for(Reminder reminder : reminderConfigList) {
            		
        			notificationTime = reminder.getNotificationTime();
        			String timeStr[] = notificationTime.split(":"); 
        			int notificationHours = Integer.parseInt(timeStr[0]); 
        			int notificationMinutes = Integer.parseInt(timeStr[1]); 

        			mapOfTimeZoneInfo = Utilities.getTimeZoneInfo(timeZone);
        			offset = (int) mapOfTimeZoneInfo.get("Offset");
        			currentLocalTimeOfTimeZone = DateUtils.addMilliseconds(currentDate, offset);
        			notificationTimeOfTimeZone = DateUtils.addMilliseconds(currentDate, offset);
        			
        			notificationTimeOfTimeZone = DateUtils.setHours(notificationTimeOfTimeZone, notificationHours);
        			notificationTimeOfTimeZone = DateUtils.setMinutes(notificationTimeOfTimeZone, notificationMinutes);
        			notificationTimeOfTimeZone = DateUtils.setSeconds(notificationTimeOfTimeZone, 0);
        			
        			
        			if(notificationTimeOfTimeZone.getTime() > currentLocalTimeOfTimeZone.getTime())
        				timeDifference = notificationTimeOfTimeZone.getTime() - currentLocalTimeOfTimeZone.getTime();
        			else {
        				notificationTimeOfTimeZone = DateUtils.addDays(notificationTimeOfTimeZone, 1);
        				timeDifference = notificationTimeOfTimeZone.getTime() - currentLocalTimeOfTimeZone.getTime();
        			}
        			
        			if(!taskQueueNotificationList.containsKey(timeDifference))
        				taskQueueNotificationList.put(timeDifference, new ArrayList<NotificationSubscription>());
        			
        			taskQueueNotificationList.get(timeDifference).add(subscription);
        		}
        	}
        	
        	Iterator<Entry<Long, List<NotificationSubscription>>> it = taskQueueNotificationList.entrySet().iterator();
		    while (it.hasNext()) {
		    	
		    	Map.Entry<Long, List<NotificationSubscription>> pair = (Map.Entry<Long, List<NotificationSubscription>>)it.next();
		    	cacheData = new HashMap<String, Object>();
		    	countDownMilliseconds = pair.getKey();
		    	taskQueueSubscriptionList = pair.getValue();
		    	
		    	key = "TaskOverDueCronJob_" + UUID.randomUUID().toString();
		    	cacheData.put( key , taskQueueSubscriptionList );
				CacheService.setCacheDataInstantaneously( cacheData );
				
		    	Queue queue = QueueFactory.getQueue( "TaskOverDueAlerts" );
				queue.add( TaskOptions.Builder.withUrl( "/taskOverDueAlerts" ).countdownMillis(countDownMilliseconds).method( Method.POST ).param("cacheKey", key) );
		    }
		    
		    CacheService.removeObjectFromCache( cacheKey );
			
		} catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "taskOverDueAlerts - Error "+ errorInfo, e);
			EmailUtil.sendExceptionMail(errorInfo, e);
		}
	}

	@SuppressWarnings("unchecked")
	public static void taskOverDueAlerts(String key) {
		
		Date currentDate = new Date();
		Date overDueDateLimit = null;
		String departmentID = null, department = null, cacheKey = null, contactID = null, timeZone = null,accountID=null;
		StringBuilder errorInfo = new StringBuilder();
		List<Reminder> reminderConfigList = null;
		Map<Date, List<Map<String, Object>>> mapOfReminderDurationToEmail = new HashMap<Date, List<Map<String, Object>>>();
		List<NotificationSubscription> notificationSubscriptionsList = null;
		Map<String, Object> userInfo = new HashMap<String, Object>();
		Map<String, Map<String, Object>> responseMap = null;
		List<Map<String, Object>> listOfUserInfo = null;

		mLogger.log(java.util.logging.Level.INFO, "Current Date: " + currentDate + " overDueDateLimit: " + overDueDateLimit );
		errorInfo.append(" Current Date: " + currentDate + " overDueDateLimit: " + overDueDateLimit);
		
		try {
			
			notificationSubscriptionsList = (List<NotificationSubscription>) CacheService.getObjectFromCache(key);
			
			if(Utilities.isEmpty(notificationSubscriptionsList))
				return;
			
			mLogger.log(java.util.logging.Level.INFO, " notificationSubscriptionsList Size: " + notificationSubscriptionsList.size());
        	
        	departmentID = notificationSubscriptionsList.get(0).getDepartmentID();
        	department = notificationSubscriptionsList.get(0).getGroupID();
        	
        	errorInfo.append(" departmentID: " + departmentID);
        	errorInfo.append(" department: " + department);
        	
        	for(NotificationSubscription subscription : notificationSubscriptionsList) {
        	
	        	reminderConfigList = subscription.getListOfReminders();
	        	contactID = subscription.getContactID();//V5P
	        	accountID=subscription.getAccountID();//V5P
	        	responseMap = getReqUsers(new ArrayList<String>(Arrays.asList(contactID)));
        		timeZone = (String) responseMap.get(contactID).get("timeZone");
	        	
	        	for(Reminder reminder : reminderConfigList) {
	        		
	        		overDueDateLimit = currentDate;
	        		userInfo = new HashMap<String, Object>();
	        		
	        		overDueDateLimit = DateUtils.addDays(overDueDateLimit, reminder.getDays());
	        		overDueDateLimit = DateUtils.addHours(overDueDateLimit, reminder.getHours());
	        		overDueDateLimit = DateUtils.addMinutes(overDueDateLimit, reminder.getMinutes());
	        		
	        		if(!mapOfReminderDurationToEmail.containsKey(overDueDateLimit))
	        			mapOfReminderDurationToEmail.put(overDueDateLimit, new ArrayList<Map<String, Object>>());
	        		
	        		userInfo.put("emailAddress", reminder.getEmail());
	        		userInfo.put("timeZone", timeZone);
	        		userInfo.put("accountID", accountID);//V5P
	        		userInfo.put("contactID", contactID);//V5P
	        		
	        		
	        		mapOfReminderDurationToEmail.get(overDueDateLimit).add(userInfo);
	        	}
        	}
	        	
	        Iterator<Entry<Date, List<Map<String, Object>>>> it = mapOfReminderDurationToEmail.entrySet().iterator();
			while (it.hasNext()) {
			    	
				Map<String, Object> overdueAlert = new HashMap<String, Object>(), cacheData = new HashMap<String, Object>();
				Map.Entry<Date, List<Map<String, Object>>> pair = (Map.Entry<Date, List<Map<String, Object>>>)it.next();
				overDueDateLimit = pair.getKey();
				listOfUserInfo = pair.getValue();
			        
				overdueAlert.put("listOfUserInfo", listOfUserInfo);
				overdueAlert.put("overDueDateLimit", overDueDateLimit);
				overdueAlert.put("departmentID", departmentID);
				overdueAlert.put("department", department);
			    	
				cacheKey = "TaskOverDue_" + UUID.randomUUID().toString();
				cacheData.put( cacheKey , overdueAlert );
				CacheService.setCacheDataInstantaneously( cacheData );
					
			   	Queue queue = QueueFactory.getQueue( "TaskOverDueAlerts" );
				queue.add( TaskOptions.Builder.withUrl( "/taskOverDueAlertsJob" ).method( Method.POST ).param("cacheKey", cacheKey) );
		    }
		    
		   CacheService.removeObjectFromCache( key );
			
		} catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "taskOverDueAlerts - Error "+ errorInfo, e);
			EmailUtil.sendExceptionMail(errorInfo, e);
		}
	}
	
	@SuppressWarnings("unchecked")
	public static void taskOverDueAlertsJob(String cacheKey) {
		
		StringBuilder errorInfo = new StringBuilder();
		Map<String, Object> overdueAlert = null, response = null;
		Date overDueDateLimit = null;
		List<Task> listOfTasks = new ArrayList<Task>();
		List<Entity> listOfEntities = new ArrayList<Entity>();
		String department = null, departmentID = null, cursor = null;
		List<Map<String, Object>> listOfUserInfo = null;
		
		try {
			
			overdueAlert = (Map<String, Object>) CacheService.getObjectFromCache(cacheKey);
			
			if(Utilities.isEmpty(overdueAlert))
				return;
			
			listOfUserInfo = (List<Map<String, Object>>) overdueAlert.get("listOfUserInfo");
			overDueDateLimit = (Date) overdueAlert.get("overDueDateLimit");
			department = (String) overdueAlert.get("department");
			departmentID = (String) overdueAlert.get("departmentID");
			
			errorInfo.append(" listOfUserInfo: " + listOfUserInfo);
			errorInfo.append(" overDueDateLimit: " + overDueDateLimit);
        	errorInfo.append(" department: " + department);
        	errorInfo.append(" departmentID: " + departmentID);
		
			List <Map <String , Object>> listOfFilterMap = new ArrayList <Map <String , Object>>();

			DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "department" , "EQUAL" , department );
			DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "departmentID" , "EQUAL" , departmentID );
			DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "dueDate" , "LESS_THAN_OR_EQUAL" , overDueDateLimit );
			DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "open" , "EQUAL" , true );
				
			do {
				response = DataStoreUtil.getEntitiesUsingQueryCursor( "Task" , 1000 , 1000 , cursor , listOfFilterMap , null );
				listOfEntities.addAll((List<Entity>) response.get("entity"));
				cursor = (String) response.get("cursor");
			} while(cursor != null);
				
			for(Entity entity : listOfEntities)
				listOfTasks.add(new Task(entity));
	
			mLogger.log(java.util.logging.Level.INFO, " Total Overdue Tasks: " + listOfTasks.size());
			errorInfo.append(" Total Overdue Tasks: " + listOfTasks.size());
				
			if(listOfTasks.size() > 0)
				sendMailForOverDueTasks(listOfTasks, listOfUserInfo, departmentID);
			
			CacheService.removeObjectFromCache( cacheKey );
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "taskOverDueAlertsJob - Error "+ errorInfo, e);
			EmailUtil.sendExceptionMail(errorInfo, e);
		}
	}

	public static void sendMailForOverDueTasks(List<Task> listOfTasks, List<Map<String, Object>> listOfUserInfo, String departmentID) {

		Map<String, Map<String, Object>> mapOfAssigneeInfo = new HashMap <String, Map<String, Object>>();
		HashMap <String , String> emailMap = new HashMap <String , String>();
		String subject = "", mailContents = "", currentTimeZone = "", timeZoneOfUser = "",trackImageContent = "",mailContentsTemplate="";
		Set<String> listOfAssigneeID = new HashSet<String>();
		StringBuilder errorInfo = new StringBuilder();
		String trackID=null;
		Map<String, Object>  cacheData = new HashMap<String, Object>();
		try {
			errorInfo.append("Task List Size: " + listOfTasks.size());
			errorInfo.append("departmentID: " + departmentID);
			errorInfo.append("listOfUserInfo: " + listOfUserInfo);
			mLogger.log(java.util.logging.Level.INFO, " listOfUserInfo: " + listOfUserInfo);
		
			for(Task task : listOfTasks) {

				if(task.getAssigneeID() != null)
					listOfAssigneeID.add(task.getAssigneeID());
			}
			
			mapOfAssigneeInfo = getReqUsers(new ArrayList<String>(listOfAssigneeID));
		        
		    if(listOfTasks.size() > 1)
		    	subject = "You have " + listOfTasks.size() + " Overdue Tasks";
		    else
		    	subject = "You have " + listOfTasks.size() + " Overdue Task";
		        
		    if(!mode.equalsIgnoreCase("LIVE"))
		    	subject = subject.concat(" - " + mode);
			
			for(Map<String, Object> userInfo : listOfUserInfo) {
				
				userInfo.put("totalTaskCount", listOfTasks.size());//V5P
				emailMap = new HashMap<String, String>();
				timeZoneOfUser = (String) userInfo.get("timeZone");
				trackID = "TaskOverDueMailTrackId_" + UUID.randomUUID().toString();//V5P
				cacheData.put( trackID , userInfo );//V5P
				CacheService.setCacheDataInstantaneously( cacheData );//V5P
				trackImageContent ="<img src='"+staticContentUrl+"/email/events/taskOverDue/"+trackID+"' /><br/>";
				if(!timeZoneOfUser.equals(currentTimeZone))
					mailContentsTemplate = getMailContentsForTaskOverDueAlert(listOfTasks, mapOfAssigneeInfo, departmentID, timeZoneOfUser);
				
				mailContents = trackImageContent + mailContentsTemplate;
				
				emailMap.put( "subject" , subject );
				emailMap.put( "mailContents" , mailContents );
				emailMap.put( "to" , (String) userInfo.get("emailAddress") );
				EmailUtil.sendCustomersSupportMails( emailMap );
				currentTimeZone = timeZoneOfUser;
			}
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "taskOverDueAlerts -sendMailForOverDueTasks - Error ", e);
			EmailUtil.sendExceptionMail(errorInfo, e);
		}
	}

	public static String getMailContentsForTaskOverDueAlert (List<Task> listOfTasks, Map<String, Map<String, Object>> mapOfUsers, String departmentID, String timeZone) {
		
		Hashtable <String , Object> lemailvalue = new Hashtable <String , Object>();
		VelocityUtil template = null;
		Map<String, Object> user = null, productNames = null, taskTypeMap = null, taskMap = null;
		Map<String, Object> productsMap = SettingsService.getAllProducts( "SEN42" , departmentID );
		ObjectMapper mapper = new ObjectMapper();
		String productNamesStr = null, dueDate = null, htmlText = "";
		List<Map<String, Object>> tasksInfo = new ArrayList<Map<String,Object>>();
		
		try {
			
			productNamesStr = (String) productsMap.get("productNames");
			productNames = mapper.readValue( productNamesStr , new TypeReference <Map <String , Object>>(){} );
			
			for(Task task : listOfTasks) {
				taskMap = new HashMap<String, Object>();
				dueDate = new SimpleDateFormat("MM/dd/yyyy hh:mm a").format(task.getDueDate());
				taskTypeMap = TaskTypeService.getTaskTypeByID(task.getType());
				TaskType taskType = (TaskType) taskTypeMap.get("tasktype");
				
				if(productNames.containsKey(task.getProductID()))
					taskMap.put("product", productNames.get(task.getProductID()));
				else
					taskMap.put("product", "No Product");
				
				if(mapOfUsers.containsKey(task.getAssigneeID())) {
					user = (Map<String, Object>) mapOfUsers.get(task.getAssigneeID());
					taskMap.put("assignee", user.get("name"));
				}
				else
					taskMap.put("assignee", "No Assignee");
				
				if((boolean) taskTypeMap.get("success"))
					taskMap.put("taskType", taskType.getType());
				else
					taskMap.put("taskType", "");
				
				taskMap.put("taskID", task.getID());
				taskMap.put("comments", task.getComments());
				taskMap.put("dueDate", dueDate);
				taskMap.put("status", task.getStatus());
				taskMap.put("lastUpdatedDate", getLocalTimeForUTC(task.getLastUpdatedDate(), timeZone));
				
				tasksInfo.add(taskMap);
			}
			
			Collections.sort( tasksInfo, new java.util.Comparator<Map<String, Object>>()
			        {
			            public int compare( Map<String, Object> o1, Map<String, Object> o2 )
			            {
			                return ((String) o1.get("assignee")).compareTo( (String) o2.get("assignee") );
			            }
			        } );

			lemailvalue.put( "tasksInfo" , tasksInfo );
			lemailvalue.put( "staticContentUrl" , staticContentUrl );
		
			String templateContent = EmailService.getTemplateContentFromMemCacheOrDS( staticContentUrl , "overDueTasksAlert.vm" );
			template = new VelocityUtil( templateContent , lemailvalue );
			htmlText = template.getRenderedText();
		}
		catch(Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "taskOverDueAlerts -getMailContentsForTaskOverDueAlert - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		
		return htmlText;
	}
	
public static Map<String, Object> queueDueDateReminders (String json) {
		
		ObjectMapper mapper = new ObjectMapper();
		NotificationSubscription notificationSubscription = null;
		String assigneeID = null, notificationID = null;
		HashMap<String, Map<String, Object>> userInfo = new HashMap<String, Map<String, Object>>();
		HashMap<String, List<Task>>	usersDueTasks = null;
		Map<String, Object> map = new HashMap<String, Object>();
		
		try {
			
			JsonNode rootNode = mapper.readValue( json , JsonNode.class );

			JsonNode notificationSubscriptionNode = rootNode.path( "notificationSubscription" );
			mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
			notificationSubscription = mapper.convertValue( notificationSubscriptionNode , new TypeReference <NotificationSubscription>(){} );
			
			notificationID = notificationSubscription.getNotificationID();
			assigneeID = notificationSubscription.getContactID();
			
			mLogger.log(java.util.logging.Level.INFO, "notificationID: " + notificationID + " assigneeID: " + assigneeID );
			
			userInfo = getReqUsers(Arrays.asList(assigneeID));
			userInfo = setNotificationOffSetForUsers(userInfo, notificationID);
			usersDueTasks = queryDueTasksForAssignees(userInfo);
			map = setTaskJobInMemcacheAndAddToTaskQueue(usersDueTasks, userInfo);
			
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - queueDueDateReminders - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		return map;
	}
	
	@SuppressWarnings("unchecked")
	public static void dequeueDueDateReminders (String json) {
		
		ObjectMapper mapper = new ObjectMapper();
		NotificationSubscription notificationSubscription = null;
		String assigneeID = null, taskJobKeyInCache = null;
		HashMap<String, Map<String, Object>> memCacheObject = new HashMap<String, Map<String, Object>>();
		Map<String, Object> cacheData = new HashMap<String, Object>();
		
		try {
			
			JsonNode rootNode = mapper.readValue( json , JsonNode.class );

			JsonNode notificationSubscriptionNode = rootNode.path( "notificationSubscription" );
			mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
			notificationSubscription = mapper.convertValue( notificationSubscriptionNode , new TypeReference <NotificationSubscription>(){} );
			
			assigneeID = notificationSubscription.getContactID();
			
			mLogger.log(java.util.logging.Level.INFO, " assigneeID: " + assigneeID );

			memCacheObject = (HashMap<String, Map<String, Object>>) CacheService.getObjectFromCache("Memcache_" + assigneeID);
			
			if(Utilities.isNull(memCacheObject))
				return;
			
			for (Entry<String, Map<String, Object>> entry : memCacheObject.entrySet())
			{
				taskJobKeyInCache = entry.getKey();
				memCacheObject.get(taskJobKeyInCache).put("taskIDs", new ArrayList<String>());
			}

			CacheService.remove("Memcache_" + assigneeID);
			cacheData.put( "Memcache_" + assigneeID , memCacheObject );
			CacheService.set(cacheData);
			DataStoreObjectDAO.set(cacheData);

		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - dequeueDueDateReminders - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
	}
	
	@SuppressWarnings("unchecked")
	public static void sendDueDateReminders (String cacheKey, String taskJobName) {
		
		HashMap<String, Map<String, Object>> memCacheObject = new HashMap<String, Map<String, Object>>();
		Map<String, Object> taskJob = new HashMap<String, Object>(), cacheData = new HashMap<String, Object>(), 
				taskTypeResponse = new HashMap<String, Object>(), mapOfTaskTypeToType = new HashMap<String, Object>();
		String toAddress = "", name = "", assigneeID = "", taskPlural = "", dateStringFormatted = "", subject = "", taskObjType = null;
		StringBuilder mailContents = new StringBuilder();
		HashMap <String , String> emailMap = new HashMap <String , String>();
		boolean isMailSent = false;
		List<String> listOfTaskIds = new ArrayList<String>();
		List<Task> listOfTaskObj = new ArrayList<Task>();
		Date taskDueDate = null;
		Map<String, Task> mapOfTaskObj = new HashMap<String, Task>();
		int count = 1;
		TaskType taskType = null;
		List<String> listOfNonTicketTypes = Arrays.asList("Call","Email","To-do","Sms");
		//String supportEmailAddress = StringUtilSales.rsbAR.getString( "support.emailAddress" );
		
		try {
			memCacheObject = (HashMap<String, Map<String, Object>>) CacheService.getObjectFromCache(cacheKey, "instant");
			
			if(Utilities.isNull(memCacheObject))
				return;
			
			if(memCacheObject.containsKey(taskJobName))
				taskJob = memCacheObject.get(taskJobName);
			else
				return;
			
			toAddress = (String) taskJob.get("email");
			name = (String) taskJob.get("name");
			listOfTaskIds = (List<String>) taskJob.get("taskIDs");
			assigneeID = cacheKey.substring(cacheKey.indexOf("_")+1);
			taskDueDate = (Date) taskJob.get("dueDate");
			dateStringFormatted = (String) taskJob.get("dateStringFormatted");
			
			mLogger.log(java.util.logging.Level.INFO, "toAddress: " + toAddress + " assigneeID: " + assigneeID );
			mLogger.log(java.util.logging.Level.INFO, "listOfTaskIds: " + listOfTaskIds);
			
			if(Utilities.isEmpty(listOfTaskIds) || Utilities.isNull(listOfTaskIds))
				return;
			
			listOfTaskObj = TaskDAO.getTasksByTaskIDS( listOfTaskIds );
			
			for(Task task : listOfTaskObj) {
				if(!task.getAssigneeID().equals(assigneeID) || !task.isOpen() || !task.getDueDate().equals(taskDueDate))
					listOfTaskIds.remove(task.getID());
				
				taskTypeResponse = TaskTypeService.getTaskTypeByID(task.getType());
				taskType = (TaskType) taskTypeResponse.get("tasktype");
				
				if((Boolean) taskTypeResponse.get("success"))
					mapOfTaskTypeToType.put(task.getType(), taskType.getType());
				
				mapOfTaskObj.put(task.getID(), task);
			}
			
			taskPlural = (listOfTaskIds.size() > 1) ? "Tasks" : "Task";
			subject = "You have " + listOfTaskIds.size() + " " + taskPlural + " due at " + dateStringFormatted;
			
			mailContents.append("Hi, " + name + ",<br><br>");
			mailContents.append("The following tasks are due at " + dateStringFormatted + "<br><br>");
			
			for(String taskId: listOfTaskIds) {
				Task taskObj = mapOfTaskObj.get(taskId);
				taskObjType = "";
				
				if(mapOfTaskTypeToType.containsKey(taskObj.getType()))
					taskObjType = (String) mapOfTaskTypeToType.get(taskObj.getType());
				
				if(listOfNonTicketTypes.indexOf(taskObjType) >= 0) {
					if(taskObj.getLinkedAccount() != null)
						mailContents.append(count + ". <a href='" + staticContentUrl + "/crm#account/" + taskObj.getLinkedAccount() + "'>" + taskObj.getComments() + "</a><br>" );
					else if(taskObj.getLinkedDeal() != null)
						mailContents.append(count + ". <a href='" + staticContentUrl + "/crm#deal/" + taskObj.getLinkedDeal() + "'>" + taskObj.getComments() + "</a><br>" );
					else if(!Utilities.isEmpty(taskObj.getLinkedContacts()))
						mailContents.append(count + ". <a href='" + staticContentUrl + "/crm#contact/" + taskObj.getLinkedContacts().get(0) + "'>" + taskObj.getComments() + "</a><br>" );
					else
						mailContents.append(count + ". <a href='" + staticContentUrl + "/crm#task/" + taskObj.getID() + "'>" + taskObj.getComments() + "</a><br>" );
				}
				else
					mailContents.append(count + ". <a href='" + staticContentUrl + "/crm#task/" + taskObj.getID() + "'>" + taskObj.getComments() + "</a><br>" );
				
				count++;
			}
	        
	       //emailMap.put( "from" , supportEmailAddress );
			emailMap.put( "to" , toAddress );
			emailMap.put( "subject" , subject );
			//emailMap.put( "salesPersonName" , "DistributedSource" );
			emailMap.put( "mailContents" , mailContents.toString() );

			isMailSent = EmailUtil.sendCustomersSupportMails( emailMap );
			mLogger.log(java.util.logging.Level.INFO, "isMailSent: " + isMailSent + " listOfTaskIds: " + listOfTaskIds);
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - sendDueDateReminders - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		finally {
			if(isMailSent || Utilities.isEmpty(listOfTaskIds)) {
				memCacheObject.remove(taskJobName);
				CacheService.remove(cacheKey);
				cacheData.put( cacheKey , memCacheObject );
				CacheService.set(cacheData);
				DataStoreObjectDAO.set(cacheData);
			}
		}
		
	}

	public static Map<String, Object> scheduleDueDateReminders () {
		
		Map<String, Object> map = new HashMap<String, Object>();
		HashMap<String, Map<String, Object>> mapOfAssigneeInfo = new HashMap<String, Map<String, Object>>();
		HashMap<String, List<Task>> mapOfAssigneeTasksInfo = new HashMap<String, List<Task>>();
		
		try {
			
			mapOfAssigneeInfo = queryNotificationSubScriptionAndGetUsersInfo ();
			mapOfAssigneeTasksInfo = queryDueTasksForAssignees(mapOfAssigneeInfo);
			map = setTaskJobInMemcacheAndAddToTaskQueue(mapOfAssigneeTasksInfo, mapOfAssigneeInfo);
		}
		catch(Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - scheduleDueDateReminders - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		
		return map;
	}

	@SuppressWarnings("unchecked")
	public static void removeTaskJobsFromMemcache (Map<String, List<String>> mapOfOldAssigneeToTaskID) {
		
		String assigneeID = "", memcacheKey = "", taskJobKeyInCache = "";
		HashMap<String, Map<String, Object>> memCacheObject = new HashMap<String, Map<String, Object>>();
		Map<String, Object> taskJobInfo = new HashMap<String, Object>(), cacheData = new HashMap<String, Object>();
		List<String> listOfTaskIdsInCacheObj = new ArrayList<String>();
		
		if(Utilities.isEmpty(mapOfOldAssigneeToTaskID))
			return;
		
		try {
			
			mLogger.log(java.util.logging.Level.INFO, "mapOfOldAssigneeToTaskID: " + mapOfOldAssigneeToTaskID);
			
			for (Entry<String, List<String>> entry : mapOfOldAssigneeToTaskID.entrySet())
			{
				assigneeID = entry.getKey();
				List<String> taskIds = (List<String>) entry.getValue();
				
				if(Utilities.isEmpty(taskIds))
					continue;
				
				memcacheKey = "Memcache_" + assigneeID;
				memCacheObject = (HashMap<String, Map<String, Object>>) CacheService.getObjectFromCache(memcacheKey, "instant");
				
				if(Utilities.isEmpty(memCacheObject))
					continue;
				
				for (Entry<String, Map<String, Object>> taskJob : memCacheObject.entrySet())
				{
					taskJobKeyInCache = taskJob.getKey();
					taskJobInfo = (Map<String, Object>) taskJob.getValue();
					listOfTaskIdsInCacheObj = (List<String>) taskJobInfo.get("taskIDs");
					
					if(Utilities.isNull(listOfTaskIdsInCacheObj) || Utilities.isEmpty(listOfTaskIdsInCacheObj))
						continue;
					
					for(String taskID : taskIds) {
						if(listOfTaskIdsInCacheObj.contains(taskID))
							listOfTaskIdsInCacheObj.remove(taskID);
					}
					memCacheObject.get(taskJobKeyInCache).put("taskIDs", listOfTaskIdsInCacheObj);
				}
				
				CacheService.remove(memcacheKey);
				cacheData.put( memcacheKey , memCacheObject );
				CacheService.set(cacheData);
				DataStoreObjectDAO.set(cacheData);
			}
			
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - removeTaskJobsFromMemcache - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
	}
	
	@SuppressWarnings("unchecked")
	public static Map<String, Object> setTaskJobInMemcacheAndAddToTaskQueue (HashMap<String, List<Task>> mapOfTasksInfo,
			HashMap<String, Map<String, Object>> mapOfAssigneeInfo) {
		
		Map<String, Object> map = new HashMap<String, Object>(), cacheData = new HashMap<String, Object>(), 
				assigneeMemcache = new HashMap<String, Object>(), taskJobInfo = null;
		HashMap<String, Map<String, Object>> memCacheObject = new HashMap<String, Map<String, Object>>();
		String taskJobKey = "", dueDateString = "", memcacheKey = "", assigneeID = null, taskJobKeyInCache = "", dateStringFormatted = "";
		SimpleDateFormat dateFormatLocal = new SimpleDateFormat("MMM-dd-yyyy HH:mm");
		List<String> listOfTaskIds = new ArrayList<String>(), listOfTaskIdsInCacheObj = null, listOfTaskIdsFromObject = new ArrayList<String>();
		long assigneeUTCOffset = 0L, notificationOffset = 0L, dueDate = 0L;
		SimpleDateFormat sdfDateAndTime = new SimpleDateFormat( "hh:mm a" );
		
		try {
			for (Entry<String, List<Task>> entry : mapOfTasksInfo.entrySet())
			{
				List<Task> listOfTasks = (List<Task>) entry.getValue();
				
				if(Utilities.isEmpty(listOfTasks))
					continue;
				
				for(Task task : listOfTasks)
					listOfTaskIdsFromObject.add(task.getID());
				
				assigneeID = entry.getKey();
				memcacheKey = "Memcache_" + assigneeID;
				memCacheObject = (HashMap<String, Map<String, Object>>) CacheService.getObjectFromCache(memcacheKey, "instant");
				
				if(Utilities.isNull(memCacheObject) || Utilities.isEmpty(memCacheObject))
					memCacheObject = new HashMap<String, Map<String, Object>>();
				else {
					for (Entry<String, Map<String, Object>> taskJob : memCacheObject.entrySet())
					{
						taskJobKeyInCache = taskJob.getKey();
						taskJobInfo = (Map<String, Object>) taskJob.getValue();
						listOfTaskIdsInCacheObj = (List<String>) taskJobInfo.get("taskIDs");
						
						if(Utilities.isNull(listOfTaskIdsInCacheObj) || Utilities.isEmpty(listOfTaskIdsInCacheObj))
							continue;
						
						for(String taskID : listOfTaskIdsFromObject) {
							if(listOfTaskIdsInCacheObj.contains(taskID))
								listOfTaskIdsInCacheObj.remove(taskID);
						}
						memCacheObject.get(taskJobKeyInCache).put("taskIDs", listOfTaskIdsInCacheObj);
					}
				}
					
				
				if(!mapOfAssigneeInfo.get(assigneeID).containsKey("timeZone")) {
					mapOfAssigneeInfo.get(assigneeID).put("timeZone", "UTC");
					mapOfAssigneeInfo.get(assigneeID).put("timeZoneID", "UTC");
					mapOfAssigneeInfo.get(assigneeID).put("UTCOffset", 0L);
				}
				
				assigneeUTCOffset = (long) mapOfAssigneeInfo.get(assigneeID).get("UTCOffset");
				notificationOffset = (long) mapOfAssigneeInfo.get(assigneeID).get("notificationOffset");
	
				for(Task task : listOfTasks) {
					
					dueDate = task.getDueDate().getTime() - assigneeUTCOffset;
					long diff = ((new Date(dueDate)).getTime() - (new Date()).getTime());
					long diffMinutes = TimeUnit.MILLISECONDS.toMinutes(diff);
					long diffDays = TimeUnit.MILLISECONDS.toDays(diff);
					
					if(task.getAssigneeID() == null || !task.getAssigneeID().equals(assigneeID) || !task.isOpen() || diffMinutes < 20 || diffDays > 16)
						continue;
					
					dueDateString = dateFormatLocal.format(task.getDueDate()).concat(" " + mapOfAssigneeInfo.get(assigneeID).get("timeZoneID"));
					dateStringFormatted = sdfDateAndTime.format(task.getDueDate());
					dueDateString = dueDateString.replace(" ", "_").replace(":", "_");
					taskJobKey = "taskJob_" + dueDateString + "_" + assigneeID;
					
					if(!memCacheObject.containsKey(taskJobKey))
						memCacheObject.put(taskJobKey, new HashMap<String, Object>());
					
					if(memCacheObject.get(taskJobKey).isEmpty()) {
						memCacheObject.get(taskJobKey).put("name", mapOfAssigneeInfo.get(assigneeID).get("name"));
						memCacheObject.get(taskJobKey).put("email", mapOfAssigneeInfo.get(assigneeID).get("email"));
						memCacheObject.get(taskJobKey).put("dueDate", task.getDueDate());
						memCacheObject.get(taskJobKey).put("taskIDs", new ArrayList<String>(Arrays.asList(task.getID())));
						memCacheObject.get(taskJobKey).put("dateStringFormatted", dateStringFormatted);
						
						Queue queue = QueueFactory.getQueue( "DueDateReminders" );
						queue.add( TaskOptions.Builder.withUrl( "/sendDueDateReminders" ).taskName(taskJobKey).method( Method.POST ).param( "cacheKey", memcacheKey )
								.countdownMillis(task.getDueDate().getTime() - new Date().getTime() - assigneeUTCOffset - notificationOffset));
					}
					else {
						listOfTaskIds = (List<String>) memCacheObject.get(taskJobKey).get("taskIDs");
						listOfTaskIds.add(task.getID());
						memCacheObject.get(taskJobKey).put("taskIDs", listOfTaskIds);
					}
					
				}
				
				CacheService.remove(memcacheKey);
				cacheData.put( memcacheKey , memCacheObject );
				CacheService.set(cacheData);
				DataStoreObjectDAO.set(cacheData);
				
				assigneeMemcache.put(memcacheKey, memCacheObject);
				
			}
			
			map.put("assigneeMemcache", assigneeMemcache);
			map.put("mapOfAssigneeInfo", mapOfAssigneeInfo);
			map.put("listOfTasksForAssignee", mapOfTasksInfo);
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - setTaskJobInMemcacheAndAddToTaskQueue - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		
		return map;
	}
	
	public static void addToMemcacheAndCheckSubscription(List<String> listOfTaskIds, Map<String, List<String>> mapOfOldAssigneeToTaskID)
	{
		
		Map<String, Object> memCacheJson = new HashMap<String, Object>(), cacheData = new HashMap<String, Object>();
		
		try {
	
			String memCacheId = "MemCache_TempID_" + UUID.randomUUID().toString();
			memCacheJson.put("taskIds", listOfTaskIds);
			
			if(!Utilities.isEmpty(mapOfOldAssigneeToTaskID))
				memCacheJson.put("mapOfOldAssigneeToTaskID", mapOfOldAssigneeToTaskID);
		
			cacheData.put( memCacheId , memCacheJson );
			CacheService.setCacheDataInstantaneously( cacheData );
		
			Queue queue = QueueFactory.getQueue( "DueDateReminders" );
			queue.add( TaskOptions.Builder.withUrl( "/checkNotificationSubscriptionAndUpdateTaskQueue" ).method( Method.POST ).param("cacheKey", memCacheId) );
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - addToMemcacheAndCheckSubscription - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
	}
	
	@SuppressWarnings("unchecked")
	public static void checkNotificationSubscriptionAndUpdateTaskQueue(String cacheKey)
	{
		String assigneeID = null;
		Map<String, Object> response = null, memCacheObject = null;
		HashMap<String, Map<String, Object>> mapOfUsersInfo = null;
		List <NotificationSubscription> listOfNotificationSubscription = null;
		Object objectFromCache = null;
		HashMap<String, List<Task>> assigneeToTasksMap = new HashMap<String, List<Task>>();
		List<String> listOfTaskIds = null;
		List<Task> listOfTaskObj = new ArrayList<Task>();
		
		try {
			
			memCacheObject = (Map<String, Object>) CacheService.getObjectFromCache(cacheKey);
			
			if(memCacheObject.containsKey("mapOfOldAssigneeToTaskID"))
				removeTaskJobsFromMemcache((Map<String, List<String>>) memCacheObject.get("mapOfOldAssigneeToTaskID"));
			
			listOfTaskIds = (List<String>) memCacheObject.get("taskIds");
			
			mLogger.log(java.util.logging.Level.INFO, "memCacheObject: " + memCacheObject);
			
			listOfTaskObj = TaskDAO.getTasksByTaskIDS(listOfTaskIds);
			
			CacheService.removeObjectFromCache( cacheKey );
			
			objectFromCache = CacheService.getObjectFromCache(StringConstants.USERS + "SEN42", "instant");
			
			if(!Utilities.isNull(objectFromCache))	
				mapOfUsersInfo = (HashMap<String, Map<String, Object>>) objectFromCache;
			
			for(Task task : listOfTaskObj) {
				
				assigneeID = task.getAssigneeID();
				if(assigneeID == null)
					continue;
				
				response = (Map<String, Object>) SettingsService.getNotificationSubscriptionForContact("SEN42", assigneeID);
				listOfNotificationSubscription = (List<NotificationSubscription>) response.get("notificationSubscription");
				
				if(Utilities.isNull(listOfNotificationSubscription) || Utilities.isEmpty(listOfNotificationSubscription))
					continue;
				
				for(NotificationSubscription notification : listOfNotificationSubscription) {
					if ("65b13a6e-10e5-4d20-bede-848b0da7ff42".equals(notification.getNotificationID()) && !notification.getDeleted() && notification.getEnabled()) {
						mapOfUsersInfo.get(assigneeID).put("notificationOffset", 600000L);
						
						if(!assigneeToTasksMap.containsKey(assigneeID))
							assigneeToTasksMap.put(assigneeID, new ArrayList<Task>());
						
						assigneeToTasksMap.get(assigneeID).add(task);
					}
				}
			}
			
			if(Utilities.isEmpty(assigneeToTasksMap))
				return;
			
			setTaskJobInMemcacheAndAddToTaskQueue(assigneeToTasksMap, mapOfUsersInfo);
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - checkNotificationSubscriptionAndUpdateTaskQueue - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
	}
	
	//Added to process webhook based on NotificationSubscription
	public static void processWebhooks(List<String> listOfTaskIds)
	{
		
		Map<String, Object> memCacheJson = new HashMap<String, Object>(), cacheData = new HashMap<String, Object>();
				
		try {
	
			String memCacheId = "MemCache_TempID_" + UUID.randomUUID().toString();
			memCacheJson.put("taskIds", listOfTaskIds);
			
			cacheData.put( memCacheId , memCacheJson );
			CacheService.setCacheDataInstantaneously( cacheData );
		
			Queue queue = QueueFactory.getQueue( "BillingWebhook" );
			queue.add( TaskOptions.Builder.withUrl( "/checkNotificationSubscriptionAndProcessWebhook" ).method( Method.POST ).param("cacheKey", memCacheId) );
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "Process Webhooks - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
	
	}
	/*Called by processWebhooks with a cachekey for object that contains list of taskIds that need to be checked
	 * whether it satisfies NotificationSubscription schema if so process the webhook based on ticketType
	 */
	@SuppressWarnings("unchecked")
	public static void checkNotificationSubscriptionAndProcessWebhook(String cacheKey)
	{
		
		
		Map<String, Object> memCacheObject = null,mapOfWebhookSubscriptionInfo = null;
		
		List <NotificationSubscription> listOfWebhookSubscriptions = new ArrayList<NotificationSubscription>();
		
		List<String> listOfTaskIds = null;
		List<Task> listOfTaskObj = new ArrayList<Task>();
		
		try {
			
			memCacheObject = (Map<String, Object>) CacheService.getObjectFromCache(cacheKey);
			listOfTaskIds = (List<String>) memCacheObject.get("taskIds");
			listOfTaskObj = TaskDAO.getTasksByTaskIDS(listOfTaskIds);
			CacheService.removeObjectFromCache( cacheKey );
			
			
			
			for(Task task : listOfTaskObj) {
				
				//skipping if task assignee is not null, since it is not assigned to the group 
				if(!(task.getAssigneeID() == null))
					continue;
				
				mapOfWebhookSubscriptionInfo  = (Map<String, Object>) SettingsService.getWebhookSubscription(task.getDepartment(),task.getType(),task.getDepartmentID());
				listOfWebhookSubscriptions = (List<NotificationSubscription>) mapOfWebhookSubscriptionInfo.get("notificationSubscription");
				
				
				//If no NotificationSubscription matches the task criteria skip to next task 
				if(Utilities.isNull(listOfWebhookSubscriptions) || Utilities.isEmpty(listOfWebhookSubscriptions))
					continue;

				for(NotificationSubscription notification : listOfWebhookSubscriptions) {
					
					//If notificationID is that of billing webhook.
					if(jBillingWebhookNotificationID.equals(notification.getNotificationID()) && notification.getEnabled())
					{
						mLogger.info("Task that satisfies billing webhook subscription : "+ task.getID());
						sendPayLoadtoJBilling(task);
					}
				}
			}
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "CheckNotificationSubscription and Process Webhook Queue", e);
			EmailUtil.sendExceptionMail(null, e);
		}
	}
	
	@SuppressWarnings("unchecked")
	public static void sendPayLoadtoJBilling(Task task){
		
		mLogger.warning("Inside send payload to Jbilling for task with Id : "+task.getID());
		ObjectMapper objMapper = new ObjectMapper();
		List<String> listOfCustomFieldIds = new ArrayList<String>();
		List<CustomField> listOfCustomFields = new ArrayList<CustomField>();
		Map<String, Object> mapOfCustomFieldInfo = null;
		HashMap<String, Object> mapOfTicketInfo = new HashMap <String , Object>();
		String customFieldReasonID = StringUtilSales.rsbAR.getString( "jBilling.customField.Reason" ),
				customFieldDateID = StringUtilSales.rsbAR.getString( "jBilling.customField.Date" ),
				activeUntilDate="",cancellationReason="",linkedAccountID = "",brandID = "",
				customFieldCreditAmountID  = StringUtilSales.rsbAR.getString( "jBilling.customField.CreditAmount" ),
				customFieldReasonForCreditID = StringUtilSales.rsbAR.getString( "jBilling.customField.ReasonForCredit" ),
				customFieldCreditOfferedByID = StringUtilSales.rsbAR.getString( "jBilling.customField.CreditOfferedBy" ),
				customFieldExpectedGoLiveDate = StringUtilSales.rsbAR.getString( "jBilling.customField.goLiveDate" ),
				customFieldReasonForNotice = StringUtilSales.rsbAR.getString( "jBilling.customField.reasonForNotice" ),
				//For Staging fieldinfoId = f0e89aa2-8a70-47dd-8209-e6216a7e3da1 for Live fieldInfoId = 9434698c-1dae-4ddc-bfb7-589991b19d55
				customFieldProcessCreditDate = StringUtilSales.rsbAR.getString( "jBilling.customField.processCreditDate" ),
				creditOfferedBy="",creditAmount="",creditReason="",jsonTicketInfo="",creditNotes="", goLiveDate="", reasonForNotice="", processCreditDate="";
		
		
		linkedAccountID = task.getLinkedAccount();
	    brandID = task.getProductID();
	    listOfCustomFieldIds = task.getLinkedCustomFields();
	    
	    try{
	    	//This should never be empty for cancel/credit ticket
	    	if(!Utilities.isEmpty(listOfCustomFieldIds)){
	    		//GMT+0000 cause we need datetime in utc not for local timezone
				mapOfCustomFieldInfo = CustomFieldService.getCustomFields("SEN42", listOfCustomFieldIds, "GMT+0000");
				if((Boolean)mapOfCustomFieldInfo.get("success") && !Utilities.isEmpty((List<CustomField>)mapOfCustomFieldInfo.get("customField")))
				{
					objMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
					listOfCustomFields = objMapper.readValue(objMapper.writeValueAsString(mapOfCustomFieldInfo.get("customField")), new TypeReference<List<CustomField>>(){});
					
					for(CustomField customField : listOfCustomFields) {
						
						if(customField.getFieldInfoID().equals(customFieldReasonID))
							cancellationReason = (String) customField.getValue();
						else if(customField.getFieldInfoID().equals(customFieldDateID))
							activeUntilDate = (String) customField.getValue();
						else if(customField.getFieldInfoID().equals(customFieldCreditOfferedByID))
							creditOfferedBy = (String) customField.getValue();
					    else if(customField.getFieldInfoID().equals(customFieldReasonForCreditID))
					    	creditReason = (String) customField.getValue();
					    else if(customField.getFieldInfoID().equals(customFieldCreditAmountID))
					    	creditAmount = (String) customField.getValue();
					    else if(customField.getFieldInfoID().equals(customFieldExpectedGoLiveDate))
					    	goLiveDate = (String) customField.getValue();
					    else if(customField.getFieldInfoID().equals(customFieldReasonForNotice))
					    	reasonForNotice = (String) customField.getValue();
					    else if(customField.getFieldInfoID().equals(customFieldProcessCreditDate))
					    	processCreditDate = (String) customField.getValue();
					
					}
					
				}else{ 
					throw new Exception("Unable to fetch customFields For Webhook");
				}
			}
	    	
	    	
	    	
			mapOfTicketInfo.put("brandId", brandID);
	    	
		    if(cancelTicketTaskTypeID.equalsIgnoreCase(task.getType()))
			{
	    		mapOfTicketInfo.put("accountPin", linkedAccountID);
	    		mapOfTicketInfo.put("activeUntilDate", activeUntilDate);
				mapOfTicketInfo.put("cancellationReason", cancellationReason);
				mapOfTicketInfo.put("taskId",task.getID());
				
				jsonTicketInfo = objMapper.writeValueAsString(mapOfTicketInfo);	
				mLogger.info("Cancel TicketInfo \n "+jsonTicketInfo);
				Queue queue = QueueFactory.getQueue( "BillingWebhook" );
				queue.add( TaskOptions.Builder.withUrl( "/cancelTicketJBillingTask" ).method( Method.POST ).payload(jsonTicketInfo) );
	    	}
			else if(creditTicketTaskTypeID.equals(task.getType()))
			{
				creditNotes = task.getNotes();
				mapOfTicketInfo.put("uniquePin", linkedAccountID);
				mapOfTicketInfo.put("creditAmount", creditAmount);
				mapOfTicketInfo.put("processDate", processCreditDate);
				mapOfTicketInfo.put("taskId", task.getID());
				if(creditOfferedBy != null && !creditOfferedBy.isEmpty())
					mapOfTicketInfo.put("approvedBy", creditOfferedBy);
				if(creditReason != null && !creditReason.isEmpty())
					mapOfTicketInfo.put("reason", creditReason);
				if(creditNotes != null && !creditNotes.isEmpty())
					mapOfTicketInfo.put("description", creditNotes);
				
				
				jsonTicketInfo = objMapper.writeValueAsString(mapOfTicketInfo);	
				mLogger.info("Credit TicketInfo \n "+jsonTicketInfo);
				Queue queue = QueueFactory.getQueue( "BillingWebhook" );
				queue.add( TaskOptions.Builder.withUrl( "/creditTicketJBillingTask" ).method( Method.POST ).payload(jsonTicketInfo) );
				
			}
			else if(unblockTicketTaskTypeID.equals(task.getType()))
			{
				mapOfTicketInfo.put("accountPin", linkedAccountID);
				
				jsonTicketInfo = objMapper.writeValueAsString(mapOfTicketInfo);	
				mLogger.info("Unblock TicketInfo \n "+jsonTicketInfo);
				Queue queue = QueueFactory.getQueue( "BillingWebhook" );
				queue.add( TaskOptions.Builder.withUrl( "/unblockTicketJBillingTask" ).method( Method.POST ).payload(jsonTicketInfo) );
					
			}
			else if(delayBillingTaskTypeID.equals(task.getType()))
			{
				mapOfTicketInfo.put("accountPin", linkedAccountID);
				mapOfTicketInfo.put("goLiveDate", goLiveDate);
				mapOfTicketInfo.put("reason", reasonForNotice);
				mapOfTicketInfo.put("taskId", task.getID());

				jsonTicketInfo = objMapper.writeValueAsString(mapOfTicketInfo);	
				mLogger.info("Delay Billing Info \n "+jsonTicketInfo);
				Queue queue = QueueFactory.getQueue( "BillingWebhook" );
				queue.add( TaskOptions.Builder.withUrl( "/delayBillingJBillingTask" ).method( Method.POST ).payload(jsonTicketInfo) );
					
			}

	    }
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "sendPayLoadtoJBilling - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}	
	}
	
	
	
	
	@SuppressWarnings("unchecked")
	public static HashMap<String, List<Task>> queryDueTasksForAssignees (HashMap<String, Map<String, Object>> mapOfAssigneeInfo) {
		
		Map<String, Object> response = new HashMap<String, Object>(), userInfo = null;
		List<Entity> listOfEntities = new ArrayList<Entity>();
		String cursor = null, assigneeID = null;
		List <Map <String , Object>> listOfFilterMap = null;
		Date currentDate = new Date();
		Date cutOffDate = DateUtils.addDays(currentDate, 16);
		HashMap<String, List<Task>> listOfTasksForAssignee = new HashMap<String, List<Task>>();
		int seconds = 0;
		
		try {
			
			for (Entry<String, Map<String, Object>> entry : mapOfAssigneeInfo.entrySet())
			{
				listOfFilterMap = new ArrayList <Map <String , Object>>();
				listOfEntities = new ArrayList<Entity>();
				
				assigneeID = entry.getKey();
				userInfo = entry.getValue();
				seconds = (int) ((long) userInfo.get("UTCOffset")/1000L);
			
				DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "dueDate" , "GREATER_THAN" , DateUtils.addSeconds(currentDate, seconds) );
				DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "dueDate" , "LESS_THAN" , DateUtils.addSeconds(cutOffDate, seconds) );
				DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "open" , "EQUAL" , true );
				DataStoreUtil.constructListOfFilterForFields( listOfFilterMap , "assigneeID" , "EQUAL" , assigneeID );
				
				do {
					response = DataStoreUtil.getEntitiesUsingQueryCursor( "Task" , 1000 , 500 , cursor , listOfFilterMap , null );
					listOfEntities.addAll((List<Entity>) response.get("entity"));
					cursor = (String) response.get("cursor");
				} while(cursor != null);
				
				if(Utilities.isEmpty(listOfEntities))
					continue;
					
				if(!listOfTasksForAssignee.containsKey(assigneeID))
					listOfTasksForAssignee.put(assigneeID, new ArrayList<Task>());
				
				for(Entity entity : listOfEntities)
					listOfTasksForAssignee.get(assigneeID).add(new Task(entity));
			}
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - queryDueTasksForAssignees - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		
		return listOfTasksForAssignee;
	}

	public static HashMap<String, Map<String, Object>> queryNotificationSubScriptionAndGetUsersInfo () {
		
		List<NotificationSubscription> notificationSubscriptionsList = new ArrayList<NotificationSubscription>();
		Set<String> listOfContactIds = new HashSet<String>();
		HashMap<String, Map<String, Object>> mapOfAssigneeInfo = new HashMap<String, Map<String, Object>>(),
				usersMap = new HashMap<String, Map<String, Object>>();
		
		try {
			
			for(String notificationID : dueDateReminders) {
				
				notificationSubscriptionsList = SettingsService.getNotificationSubscriptionsByNotificationID(notificationID);
				
				for(NotificationSubscription subscription : notificationSubscriptionsList)
					listOfContactIds.add((String) subscription.getContactID());
				
				if(Utilities.isEmpty(listOfContactIds))
					return null;
				
				usersMap = getReqUsers(new ArrayList<String>(listOfContactIds));
				mapOfAssigneeInfo = setNotificationOffSetForUsers(usersMap, notificationID);
			}
			
			mLogger.log(java.util.logging.Level.INFO, "mapOfAssigneeInfo: " + mapOfAssigneeInfo);
		}
		catch(Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - queryNotificationSubScriptionAndGetUsersInfo - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		
		return mapOfAssigneeInfo;
	}

	public static HashMap<String, Map<String, Object>> setNotificationOffSetForUsers (HashMap<String, Map<String, Object>> usersMap, 
													String NotificationID) {
		
		Map<String, Object> userInfo = new HashMap<String, Object>();
		long notficationOffset = 0L;
		HashMap<String, Map<String, Object>> mapOfAssigneeInfo = new HashMap<String, Map<String, Object>>();
		
		try {
			switch(NotificationID) {
				case "65b13a6e-10e5-4d20-bede-848b0da7ff42" :  // Notification before 10 mins
					notficationOffset = 600000;
					break;
				default:
					notficationOffset = 0;
			}
			
			for (Entry<String, Map<String, Object>> entry : usersMap.entrySet())
			{
				userInfo = entry.getValue();
				userInfo.put("notificationOffset", notficationOffset);
				mapOfAssigneeInfo.put(entry.getKey(), userInfo);
			}
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - setNotificationOffSetForUsers - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		
		return mapOfAssigneeInfo;
	}
	
	@SuppressWarnings("unchecked")
	public static HashMap<String, Map<String, Object>> getReqUsers (List<String> listOfContactIds) {
		
		HashMap<String, Map<String, Object>> response = new HashMap<String, Map<String, Object>>();
		Map<String, Object> mapOfAssigneeInfo = null, responseObj = null;
		Contact contact = null;
		List<ContactMethod> listOfLinkedContactMethods = null;
		Object objectFromCache = null;
		HashMap<String, Map<String, Object>> mapOfUsersInfo = new HashMap<String, Map<String, Object>>();
		List<String> contactIdsNotInCache = new ArrayList<String>();
		
		try {
			
			objectFromCache = CacheService.getObjectFromCache(StringConstants.USERS + "SEN42", "instant");
			
			if(!Utilities.isNull(objectFromCache))	
				mapOfUsersInfo = (HashMap<String, Map<String, Object>>) objectFromCache;
			
			for(String contactId : listOfContactIds) {
				if(mapOfUsersInfo.containsKey(contactId))
					response.put(contactId, mapOfUsersInfo.get(contactId));
				else
					contactIdsNotInCache.add(contactId);
			}
			
			if(!Utilities.isEmpty(contactIdsNotInCache)) {
			
				mapOfAssigneeInfo = (Map<String, Object>) ContactService.getReqContacts("contact", "SEN42", new ArrayList<String>(contactIdsNotInCache)).get("contact");
				for (Entry<String, Object> entry : mapOfAssigneeInfo.entrySet())
				{
					if(!response.containsKey(entry.getKey()))
						response.put(entry.getKey(), new HashMap<String, Object>());
					
					contact = (Contact) entry.getValue();
					
					if(contact.isDeleted())
						continue;
					
					listOfLinkedContactMethods = contact.getLinkedContactMethods();
					if(Utilities.isEmpty(listOfLinkedContactMethods))
						continue;
					
					for(ContactMethod contactMethod: listOfLinkedContactMethods) {
						if("email".equals(contactMethod.getType()) && !contactMethod.isDeleted() && contactMethod.isPrimary())
							response.get(entry.getKey()).put("email", contactMethod.getValue());
					}
					
					response.get(entry.getKey()).put("id", contact.getID());
					response.get(entry.getKey()).put("name", Utilities.getFullName( contact.getFirstName() , contact.getLastName() ));
					response.get(entry.getKey()).put("accountid", contact.getAccountID());
					response.get(entry.getKey()).put("deleted", contact.isDeleted());
				}
			
			}
			
			for (Entry<String, Map<String, Object>> entry : response.entrySet())
			{
				responseObj = entry.getValue();
				if(responseObj.containsKey("timeZone")) {
					response.get(entry.getKey()).put("timeZone", responseObj.get("timeZone"));
					response.get(entry.getKey()).put("timeZoneID", Utilities.getTimeZoneId((String) responseObj.get("timeZone")));
					response.get(entry.getKey()).put("UTCOffset", Utilities.getLocalTimeOffset((String) responseObj.get("timeZone")));
				}
				else {
					response.get(entry.getKey()).put("timeZone", "UTC");
					response.get(entry.getKey()).put("timeZoneID", "UTC");
					response.get(entry.getKey()).put("UTCOffset", 0L);
				}
			}
			
		}
		catch(Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - getReqUsers - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
		
		return response;
	}
	
	@SuppressWarnings("unchecked")
	public static void updateDueDateJobsAndUsersCache (String json) {
		
		Object objectFromCache = null;
		ObjectMapper mapper = new ObjectMapper();
		String contactID = null, memcacheKey = null, taskJobKeyInCache = null, timeZone = null;
		HashMap<String, Map<String, Object>> mapOfUsersInfo = new HashMap<String, Map<String, Object>>();
		Map<String, Object> userInfo = new HashMap<String, Object>(), cacheData = new HashMap<String, Object>(), 
				response = new HashMap<String, Object>(), jsonMap = new HashMap<String, Object>();
		HashMap<String, Map<String, Object>> memCacheObject = new HashMap<String, Map<String, Object>>();
		List<NotificationSubscription> listOfNotificationSubscription = null;
		
		try {
			
			jsonMap = mapper.readValue( json , new TypeReference <Map<String, Object>>()
					{
					} );
			
			contactID = (String) jsonMap.get("id");
			timeZone = (String) jsonMap.get("timeZone");
			objectFromCache = CacheService.getObjectFromCache(StringConstants.USERS + "SEN42", "instant");
			
			if(!Utilities.isNull(objectFromCache))	
				mapOfUsersInfo = (HashMap<String, Map<String, Object>>) objectFromCache;
			
			if(!mapOfUsersInfo.containsKey(contactID))
				return;
			
			userInfo = mapOfUsersInfo.get(contactID);
			
			if(timeZone != null) {
				userInfo.put("timeZone", timeZone);
				userInfo.put("timeZoneID", Utilities.getTimeZoneId(timeZone));
				userInfo.put("UTCOffset", Utilities.getLocalTimeOffset(timeZone));
			}
			else {
				if(userInfo.containsKey("timeZone"))
					userInfo.remove("timeZone");
			}
			
			mapOfUsersInfo.remove(contactID);
			mapOfUsersInfo.put(contactID, userInfo);
			
			CacheService.remove(StringConstants.USERS + "SEN42");
			cacheData.put( StringConstants.USERS + "SEN42" , mapOfUsersInfo );
			CacheService.set(cacheData);
			DataStoreObjectDAO.set(cacheData);
			
			memcacheKey = "Memcache_" + contactID;
			memCacheObject = (HashMap<String, Map<String, Object>>) CacheService.getObjectFromCache(memcacheKey, "instant");
			
			if(Utilities.isNull(memCacheObject))
				return;
			
			for (Entry<String, Map<String, Object>> entry : memCacheObject.entrySet())
			{
				taskJobKeyInCache = entry.getKey();
				memCacheObject.get(taskJobKeyInCache).put("taskIDs", new ArrayList<String>());
			}
			
			CacheService.remove("Memcache_" + contactID);
			cacheData.put( "Memcache_" + contactID , memCacheObject );
			CacheService.setCacheDataInstantaneously( cacheData );
			
			response = (Map<String, Object>) SettingsService.getNotificationSubscriptionForContact("SEN42", contactID);
			listOfNotificationSubscription = (List<NotificationSubscription>) response.get("notificationSubscription");
			
			if(Utilities.isNull(listOfNotificationSubscription) || Utilities.isEmpty(listOfNotificationSubscription))
				return;
			
			for(NotificationSubscription notification : listOfNotificationSubscription) {
				if ("65b13a6e-10e5-4d20-bede-848b0da7ff42".equals(notification.getNotificationID()) && !notification.getDeleted() && notification.getEnabled()) {
					
					Map<String,Object> obj = new HashMap<String,Object>();
					obj.put( "notificationSubscription" , notification );
					
					Queue queue = QueueFactory.getQueue( "DueDateReminders" );
					queue.add( TaskOptions.Builder.withUrl( "/queueDueDateRemindersJob" ).method( Method.POST ).payload(mapper.writeValueAsString(obj)) );
					break;
				}
			}
			
		}
		catch (Exception e) {
			mLogger.log(java.util.logging.Level.SEVERE, "dueDateReminders - updateDueDateJobsAndUsersCache - Error ", e);
			EmailUtil.sendExceptionMail(null, e);
		}
	}

	public static void cancelAccountJBillingWebHook(String json) {
				
		ObjectMapper objMapper = new ObjectMapper();
		Map <String , Object> cancelTicketInfo = null;
		long milliseconds = 0L;
		Map <String , Object> responseMap = null;
		SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy KK:mm a");
		StringBuffer urlBuffer = new StringBuffer();
		String jsonResponse = "", brandID, linkedAccountID, activeUntilDate, taskID;
		String jBillingCancelTicketUrl = StringUtilSales.getStringBasedOnMode("jBilling.CancelAccountUrl");
		
		try
			{
		
			cancelTicketInfo = objMapper.readValue(json, new TypeReference<Map<String, Object>>(){});
			brandID = (String)cancelTicketInfo.get("brandId");
			linkedAccountID = (String) cancelTicketInfo.get("accountPin");
			activeUntilDate = (String)cancelTicketInfo.get("activeUntilDate");
			taskID = (String)cancelTicketInfo.get("taskId");
			
			if(StringUtil.isBlank(brandID) || StringUtil.isBlank(activeUntilDate) || StringUtil.isBlank(linkedAccountID))
				throw new Exception( "Parameters missing");
			
			
			Date activeUntilDateTime = formatter.parse(activeUntilDate);
			Date utcDateTime = new Date(activeUntilDateTime.getTime());
			milliseconds = utcDateTime.getTime();
			
			urlBuffer.append(jBillingCancelTicketUrl).append("?uniquePin=").append(linkedAccountID).append( "&taskId=" ).append(taskID);	
			urlBuffer.append("&brandId=").append(brandID).append("&milliSecs=").append(Long.toString(milliseconds)).append("&reason=").append(URLEncoder.encode((String)cancelTicketInfo.get("cancellationReason"),"UTF-8"));
			jBillingCancelTicketUrl = urlBuffer.toString();
			
			jsonResponse = (String) URLFetchService.URLFetch( jBillingCancelTicketUrl , "DELETE" , "application/json" , null );
			if(StringUtil.isBlank(jsonResponse)){
				String params = "CancelAccount api didn't respond : \n Request :" + jBillingCancelTicketUrl;
				mLogger.warning(params);
				EmailUtil.sendExceptionMailForJBilling(params);
				return;
				}
			
				responseMap = objMapper.readValue(jsonResponse, new TypeReference<Map<String, Object>>(){});
			
				if (!responseMap.containsKey("status") || "failure".equals( responseMap.get("status"))){
					String params = "CancelAccount api responded with status as false : \n Request :" + jBillingCancelTicketUrl+ "\n Response :"+ jsonResponse;
					mLogger.warning(params);
					EmailUtil.sendExceptionMailForJBilling(params);
					}
				else{
					String params = "CancelAccount api responded with status as true : \n Request :" + jBillingCancelTicketUrl+ "\n Response :"+ jsonResponse;
					mLogger.info(params);
				}
			}
		catch ( Exception e )
			{
				String params = "CancelTicketInfo :" + json +"  responseFromJbillingServer :" + jsonResponse +"  jBillingUrl :" + jBillingCancelTicketUrl;
				mLogger.log( java.util.logging.Level.SEVERE , params, e );
				EmailUtil.sendJavaErrorMailWithParams(params, e);
			}
	}
	
	public static void creditTicketJBillingWebHook(String json) {
		
			ObjectMapper objMapper = new ObjectMapper();
			Map <String , Object> creditTicketInfo = null;
			Map <String , Object> responseMap = null;
			long processCreditDateMilliSecs = 0L;
			SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy KK:mm a");
			
			StringBuffer urlBuffer = new StringBuffer();
			String jsonResponse = "", brandId, accountId, creditAmount ,processCreditDate;
			String jBillingCreditTicketUrl = StringUtilSales.getStringBasedOnMode("jBilling.CreditAccountUrl");
			
			try
				{
			
					creditTicketInfo = objMapper.readValue(json, new TypeReference<Map<String, Object>>(){});
					brandId = (String)creditTicketInfo.get("brandId");
					accountId = (String) creditTicketInfo.get("uniquePin");
					creditAmount = (String)creditTicketInfo.get("creditAmount");
					processCreditDate = (String)creditTicketInfo.get("processDate");
					
					if(StringUtil.isBlank(brandId) || StringUtil.isBlank(creditAmount) || StringUtil.isBlank(accountId) || StringUtil.isBlank(processCreditDate))
						throw new Exception( "Parameters missing");
					
					Date processCreditDateTime = formatter.parse(processCreditDate);
					Date utcDateTime = new Date(processCreditDateTime.getTime());
					processCreditDateMilliSecs = utcDateTime.getTime();
					//Updating the json replacing the datetime sting with millisecs long
					creditTicketInfo.put("processDate", processCreditDateMilliSecs);
					
					json = objMapper.writeValueAsString(creditTicketInfo);
					
					urlBuffer.append(jBillingCreditTicketUrl);
					jBillingCreditTicketUrl = urlBuffer.toString();
					jsonResponse = (String) URLFetchService.URLFetch( jBillingCreditTicketUrl , "PUT" , "application/json" , json );
					
					if(StringUtil.isBlank(jsonResponse)){
						String params = "CreditTicket api didn't respond : \n Request :" + jBillingCreditTicketUrl +"with post data \n"+ json.toString();
						mLogger.warning(params);
						EmailUtil.sendExceptionMailForJBilling(params);
						return;
					}
					
					responseMap = objMapper.readValue(jsonResponse, new TypeReference<Map<String, Object>>(){});
					
					if (!responseMap.containsKey("success") || !(boolean)responseMap.get("success")){
						String params = "CreditTicket api responded with success as false : \n Request :" + jBillingCreditTicketUrl+"\n RequestData :"+ json.toString() + "\n Response :"+ jsonResponse;
						mLogger.warning(params);
						EmailUtil.sendExceptionMailForJBilling(params);
					}else{
						String params = "CreditTicket api responded with success as true : \n Request :" + jBillingCreditTicketUrl+"\n RequestData :"+ json.toString() + "\n Response :"+ jsonResponse;
						mLogger.info(params);
					}			
				}
			catch ( Exception e )
				{
					String params = "CreditTicketInfo :" + json +"  responseFromJbillingServer :" + jsonResponse +"  jBillingUrl :" + jBillingCreditTicketUrl;
					mLogger.log( java.util.logging.Level.SEVERE , params, e );
					EmailUtil.sendJavaErrorMailWithParams(params, e);
				}
	}
	
	public static void unblockTicketJBillingWebHook(String json) {
		
			ObjectMapper objMapper = new ObjectMapper();
			Map <String , Object> creditTicketInfo = null;
			Map <String , Object> responseMap = null;
			
			StringBuffer urlBuffer = new StringBuffer();
			String jsonResponse = "", brandId, accountId;
			String jBillingUnblockTicketUrl = StringUtilSales.getStringBasedOnMode("jBilling.UnblockAccountUrl");
			
			try
				{
			
					creditTicketInfo = objMapper.readValue(json, new TypeReference<Map<String, Object>>(){});
					brandId = (String)creditTicketInfo.get("brandId");
					accountId = (String) creditTicketInfo.get("accountPin");
					
					if(StringUtil.isBlank(brandId) || StringUtil.isBlank(accountId))
						throw new Exception( "Parameters missing");
					
					urlBuffer.append(jBillingUnblockTicketUrl);
					jBillingUnblockTicketUrl = urlBuffer.toString();
					jsonResponse = (String) URLFetchService.URLFetch( jBillingUnblockTicketUrl , "PUT" , "application/json" , json );
					
					if(StringUtil.isBlank(jsonResponse)){
						String params = "UnblockTicket api didn't respond : \n Request :" + jBillingUnblockTicketUrl +"with post data \n"+ json.toString();
						mLogger.warning(params);
						EmailUtil.sendExceptionMailForJBilling(params);
						return;
					}
					
					responseMap = objMapper.readValue(jsonResponse, new TypeReference<Map<String, Object>>(){});
					
					if (!responseMap.containsKey("success") || !(boolean)responseMap.get("success")){
						String params = "UnblockTicket api responded with success as false : \n Request :" + jBillingUnblockTicketUrl+"\n RequestData :"+ json.toString() + "\n Response :"+ jsonResponse;
						mLogger.warning(params);
						EmailUtil.sendExceptionMailForJBilling(params);
					}else{
						String params = "UnblockTicket api responded with success as true : \n Request :" + jBillingUnblockTicketUrl+"\n RequestData :"+ json.toString() + "\n Response :"+ jsonResponse;
						mLogger.info(params);
					}			
				}
			catch ( Exception e )
				{
					String params = "UnblockTicketInfo :" + json +"  responseFromJbillingServer :" + jsonResponse +"  jBillingUrl :" + jBillingUnblockTicketUrl;
					mLogger.log( java.util.logging.Level.SEVERE , params, e );
					EmailUtil.sendJavaErrorMailWithParams(params, e);
				}
	}
	
	public static void delayBillingJBillingWebHook(String json) {
		
		ObjectMapper objMapper = new ObjectMapper();
		Map <String , Object> creditTicketInfo = null;
		Map <String , Object> responseMap = null;

		String jsonResponse = "", accountId, goLiveDate, reason, brandId;
		String jBillingDelayBillingUrl = StringUtilSales.getStringBasedOnMode("jBilling.DelayBillingUrl");
		SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy KK:mm a");
		long milliseconds;
		
		try
			{
		
				creditTicketInfo = objMapper.readValue(json, new TypeReference<Map<String, Object>>(){});
				accountId = (String) creditTicketInfo.get("accountPin");
				goLiveDate = (String) creditTicketInfo.get("goLiveDate");
				reason = (String) creditTicketInfo.get("reason");
				brandId = (String) creditTicketInfo.get("brandId");

				if(StringUtil.isBlank(brandId) || StringUtil.isBlank(accountId) || StringUtil.isBlank(goLiveDate))
					throw new Exception( "Parameters missing");
				
				Date goLiveDateTime = formatter.parse(goLiveDate);
				Date utcDateTime = new Date(goLiveDateTime.getTime());
				milliseconds = utcDateTime.getTime();
				creditTicketInfo.put("goLiveDate",milliseconds);
				
				if(StringUtil.isBlank( reason ))
					creditTicketInfo.remove("reason");
				
				json = objMapper.writeValueAsString( creditTicketInfo );

				jsonResponse = (String) URLFetchService.URLFetch( jBillingDelayBillingUrl , "PUT" , "application/json" , json );
				
				if(StringUtil.isBlank(jsonResponse)){
					String params = "DelayBilling api didn't respond : \n Request :" + jBillingDelayBillingUrl +"with post data \n"+ json.toString();
					mLogger.warning(params);
					EmailUtil.sendExceptionMailForJBilling(params);
					return;
				}
				
				responseMap = objMapper.readValue(jsonResponse, new TypeReference<Map<String, Object>>(){});
				
				if (!responseMap.containsKey("success") || !(boolean)responseMap.get("success")){
					String params = "DelayBilling api responded with success as false : \n Request :" + jBillingDelayBillingUrl+"\n RequestData :"+ json.toString() + "\n Response :"+ jsonResponse;
					mLogger.warning(params);
					EmailUtil.sendExceptionMailForJBilling(params);
				}else{
					String params = "DelayBilling api responded with success as true : \n Request :" + jBillingDelayBillingUrl+"\n RequestData :"+ json.toString() + "\n Response :"+ jsonResponse;
					mLogger.info(params);
				}			
			}
		catch ( Exception e )
			{
				String params = "DelayBillingInfo :" + json +"  responseFromJbillingServer :" + jsonResponse +"  jBillingUrl :" + jBillingDelayBillingUrl;
				mLogger.log( java.util.logging.Level.SEVERE , params, e );
				EmailUtil.sendJavaErrorMailWithParams(params, e);
			}
	}
	
	@SuppressWarnings("unchecked")
	public static Map<String,Object> getTasksUnderAccount(Map<String,Object> mapOfSessionInfo, String linkedAccount, 
																String taskStatus, String taskTypeID, String currentCursor) {
		
		boolean success = false;
		final int LIMIT = 10;
		Boolean open = null;
		StringBuilder errorInfo = new StringBuilder();
		Map<String,Object> map = new HashMap<>();
		
		try {
			
			String accountID = (String) mapOfSessionInfo.get("AccountPIN");
			
			errorInfo.append(" accountID :").append(accountID).append("<br/><br/>");
			errorInfo.append(" linkedAccount :").append(linkedAccount).append("<br/><br/>");
			errorInfo.append(" taskStatus :").append(taskStatus).append("<br/><br/>");
			errorInfo.append(" taskTypeID :").append(taskTypeID).append("<br/><br/>");
			errorInfo.append(" currentCursor :").append(currentCursor).append("<br/><br/>");
			
			if(StringUtils.isNotBlank(taskStatus)) {
				
				if("open".equalsIgnoreCase(taskStatus))
					open = Boolean.TRUE;
				else if("closed".equalsIgnoreCase(taskStatus))
					open = Boolean.FALSE;
				else
					open = null;
			}
			
			errorInfo.append(" Open :").append(open).append("<br/><br/>");
			
			Map<String,Object> queryResponse = TaskDAO.getTasksUnderAccount(accountID, linkedAccount, open, taskTypeID, currentCursor, LIMIT);
			String nextCursor = (String) queryResponse.get("nextCursor");
			List<Task> listOfTask = (List<Task>) queryResponse.get("task");
			
			map.put("nextCursor", nextCursor);
			map.put("task", listOfTask);		
			
			success = true;
		} catch(Exception e) {			
			mLogger.log( java.util.logging.Level.SEVERE , " getTasksUnderEntity - Error : " +errorInfo, e );
			EmailUtil.sendExceptionMail(errorInfo, e);
		} finally {
			map.put("success", success);
			map.put("linkedAccount", linkedAccount);
		}
		return map;
	}
	
	@SuppressWarnings("unchecked")
	public static Map<String,Object> updateAssociatedEntitiesForTaskUpdate(Task oldTask, Map<String, Object> newTaskMap, String userID, String accountID) {
		
		boolean success = false;
		Map<String,Object> map = new HashMap<String, Object>(), requestMap = new HashMap<String, Object>(), dealMap, tempResponseMap;
		String taskID=null, oldLinkedAccount, newLinkedAccount, URL;
		Long oldLinkedDeal, newLinkedDeal=null;
		long oldLongValue=0l, newLongValue=0l;
		List<String> oldLinkedContacts = new ArrayList<String>(), newLinkedContacts = new ArrayList<String>(), 
					contactsToAdd=null, contactsToRemove=null, oldLinkedContactsCopy = new ArrayList<String>(), linkedContacts, tempList;
		List<Long> longList;
		ObjectMapper mapper = new ObjectMapper();
		Future <HTTPResponse> cmsResponse=null;
		List<Deal> updatedDeals = new ArrayList<Deal>();
		
		try {
			
			taskID = oldTask.getID();
			
			if(newTaskMap.containsKey( "linkedContacts" )) {
				
				if(!Utilities.isEmpty( oldTask.getLinkedContacts() ))
					linkedContacts = oldTask.getLinkedContacts();
				else
					linkedContacts = new ArrayList<String>();
				
				for(String contactID : linkedContacts){
					oldLinkedContactsCopy.add(contactID);
					oldLinkedContacts.add(contactID);
				}
				
				if(!Utilities.isEmpty( (List<String>) newTaskMap.get("linkedContacts") ))
					linkedContacts = (List<String>) newTaskMap.get("linkedContacts");
				else
					linkedContacts = new ArrayList<String>();
				
				for(String contactID : linkedContacts)
					newLinkedContacts.add(contactID);
				
				if(!Utilities.isEmpty(newLinkedContacts) || !Utilities.isEmpty(oldLinkedContacts)){
					
					oldLinkedContacts.removeAll(newLinkedContacts);
					contactsToRemove = oldLinkedContacts ;
					
					newLinkedContacts.removeAll(oldLinkedContactsCopy);
					contactsToAdd = newLinkedContacts ;
				}
				
				if(!Utilities.isEmpty( contactsToRemove ))
					requestMap.put( "contactsToRemove" , contactsToRemove );
				if(!Utilities.isEmpty( contactsToAdd ))
					requestMap.put( "contactsToAdd" , contactsToAdd );
			}
			
			if(newTaskMap.containsKey( "linkedAccount" )){
				
				oldLinkedAccount = oldTask.getLinkedAccount();
				newLinkedAccount = (String) newTaskMap.get("linkedAccount");
				if(StringUtil.isBlank( oldLinkedAccount ))
					oldLinkedAccount = "";
				if(StringUtil.isBlank( newLinkedAccount ))
					newLinkedAccount = "";
				
				if(!oldLinkedAccount.equals( newLinkedAccount )){
					
					if(!StringUtil.isBlank( newLinkedAccount ))
						requestMap.put("linkAccount", newLinkedAccount);
					if(!StringUtil.isBlank( oldLinkedAccount ))
						requestMap.put("delinkAccount", oldLinkedAccount);
				}
			}

			if(!Utilities.isEmpty( requestMap )){
				requestMap.put( "taskID" , taskID );
				URL = StringConstants.UPDATE_TASK_LINKED_ENTITIES_URL + "?apikey="+accountID;
				cmsResponse = Utilities.makeAsyncPutRequest(URL, mapper.writeValueAsString(requestMap));
			}
			
			if(newTaskMap.containsKey( "linkedDeal" )){
				
				oldLinkedDeal = oldTask.getLinkedDeal();
				if(newTaskMap.containsKey("linkedDeal"))
					newLinkedDeal =  Long.valueOf(String.valueOf(newTaskMap.get("linkedDeal")));
				
				if(oldLinkedDeal != null)
					oldLongValue = oldLinkedDeal.longValue();
				if(newLinkedDeal != null)
					newLongValue = newLinkedDeal.longValue();
				
				if(newLongValue != oldLongValue){
					
					if(newLongValue > 0l){
						
						longList = new ArrayList<Long>();
						dealMap = new HashMap<String, Object>();
						longList.add( newLinkedDeal );
						dealMap.put( "linkedDeals" , longList );
						
						tempResponseMap = DealService.associateTaskToDeals_v2( accountID , taskID , dealMap );
						if(!(Boolean)tempResponseMap.get("status")){
							map.put( "error" , "Failed to associate deal" );
							return map;
						}
						else
							updatedDeals.addAll( (List<Deal>) tempResponseMap.get("deal") );
					}
					if(oldLongValue > 0l){
						
						longList = new ArrayList<Long>();
						tempList = new ArrayList<String>();
						longList.add( oldLinkedDeal );
						tempList.add(taskID);
						
						tempResponseMap = DealService.dissociateBulkTasksFromDeals( accountID , tempList , longList );
						if(!(Boolean)tempResponseMap.get("success")){
							map.put( "error" , "Failed to dissociate from deal" );
							return map;
						}
						else{
							Map<Long, Object> tempMap = (HashMap<Long, Object>)tempResponseMap.get("deal");
							for(Long dealID : tempMap.keySet()){
								updatedDeals.add((Deal) tempMap.get(dealID) );
							}
						}
					}
					
					if(!Utilities.isEmpty( updatedDeals ))
						map.put("deals", updatedDeals);
				}
			}

			if(!Utilities.isEmpty( requestMap ))
				map.put("backendResponse", cmsResponse);
			
			success = true;
		} catch(Exception e) {			
			String params = "newTaskMap: "+newTaskMap+" taskID: "+taskID+" userID: "+userID+" accountID: "+accountID+" requestMap: "+requestMap;
			mLogger.log( java.util.logging.Level.SEVERE , " updateAssociatedEntitiesForTaskUpdate - Error : " +params, e );
			EmailUtil.sendJavaErrorMailWithParams(params, e);
		} finally {
			map.put("success", success);
		}
		return map;
	}
	
	@SuppressWarnings("unchecked")
	public static void updateLinkedTaskTimeZoneForAccountscontactandDealscontactJobs(List<Contact> listOfContact,String contactID) {
		
		boolean success = false;
		StringBuilder errorInfo = new StringBuilder();
		String timezone = null;
		
		try {
			for(Contact list : listOfContact){
				if (list.getID().equals(contactID)) {
					List <String> linkedTask  = list.getLinkedTasks();
					List <Task>  listOfOpenTask = TaskDAO.getTasksByIDAndOpenStatus( linkedTask, true );
					if ( !Utilities.isEmpty( listOfOpenTask ) )
					{
						for(Task task : listOfOpenTask) {
							timezone=list.getTimeZone();
		    	    		task.setTimeZone(timezone);
		    	    		task.setTimeZoneID(Utilities.getTimeZoneId(timezone));
		    	    		task.setUTCOffset(Utilities.getLocalTimeOffset(timezone));
		    	    	}
		    	    	if ( !listOfOpenTask.isEmpty() )
		    	    		DataStoreUtil.batchWrite( listOfOpenTask );
					}
				}
			}
		    Queue queue = QueueFactory.getQueue( "Task-update-with-timezone" );
					queue.add( TaskOptions.Builder.withUrl( "/taskOverDueAlertsCronJob" ).method( Method.POST ).param("Key", timezone ));
			
			success = true;
		} catch(Exception e) {			
			mLogger.log( java.util.logging.Level.SEVERE , " getTasksUnderEntity - Error : " +errorInfo, e );
			EmailUtil.sendExceptionMail(errorInfo, e);
		}
	}
}
	